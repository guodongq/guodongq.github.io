<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>gRPC之protobuf</title>
    <url>/2020/02/13/gRPC/2020-02-13-protobuf/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="Protobuf简介"><a href="#Protobuf简介" class="headerlink" title="Protobuf简介"></a>Protobuf简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Protobuf</strong>也叫做Protocol Buffers,它是由Google公司开发的一种跨语言和平台的序列化数据结构的方式，是一个灵活的、高效的用于序列化数据的协议。<br><strong>Protobuf</strong>是跨语言的，自身带有一个编译器(protoc),我们可以通过protoc集成相关语言的插件(例如protoc-gen-go)就可以快速编译成Go、Java等多种语言代码，并且可以直接使用无需编写其他代码，它自己带有解析的代码。  </p>
<p>protoc的GitHub地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>性能好、效率高<br>与XML相比，protobuf序列化后字节占用空间会少3-10倍，序列化时间会快20-100倍</li>
<li>代码生成机制<br>对结构化的数据操作封装成了一个类，便于使用</li>
<li>支持向后和向前兼容<br>客户端在.proto中添加一个字节时，不会影响客户端的使用</li>
<li>支持多种编程语言</li>
</ul>
</li>
<li>缺点<ul>
<li>可读性差，二进制形式</li>
<li>缺少自描述</li>
</ul>
</li>
</ul>
<h1 id="Protobuf编译器安装"><a href="#Protobuf编译器安装" class="headerlink" title="Protobuf编译器安装"></a>Protobuf编译器安装</h1><h2 id="Protobuf编译器安装-1"><a href="#Protobuf编译器安装-1" class="headerlink" title="Protobuf编译器安装"></a>Protobuf编译器安装</h2><p>在github中的页面<code>https://github.com/protocolbuffers/protobuf/releases</code>找到对应平台的protobuf版本进行下载安装。</p>
<h2 id="Protobuf编译器使用"><a href="#Protobuf编译器使用" class="headerlink" title="Protobuf编译器使用"></a>Protobuf编译器使用</h2><p>Protobuf提供了protoc编译器，用于通过定义好的.proto文件来生成Java，Python，Go等语言代码<br>命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc --proto_path&#x3D;IMPORT_PATH --cpp_out&#x3D;DST_PATH --go_out&#x3D;DST_PATH path&#x2F;to&#x2F;file.proto</span><br></pre></td></tr></table></figure>
<h3 id="导入目录设置"><a href="#导入目录设置" class="headerlink" title="导入目录设置"></a>导入目录设置</h3><ul>
<li>IMPORT_PATH声明了一个.proto文件所在的解析import具体目录  </li>
<li>如果忽略该值，使用当前目录  </li>
<li>如果多个目录可以多次调用–proto_path,会顺序被访问并执行导入  </li>
<li>-I=IMPORT_PATH是–proto_path的简化形式</li>
</ul>
<h3 id="生成代码指定"><a href="#生成代码指定" class="headerlink" title="生成代码指定"></a>生成代码指定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--cpp_out ：在目标目录DST_DIR中产生C++代码</span><br><span class="line">--java_out ：在目标目录DST_DIR中产生Java代码</span><br><span class="line">--python_out ：在目标目录 DST_DIR 中产生Python代码</span><br><span class="line">--go_out ：在目标目录 DST_DIR 中产生Go代码</span><br><span class="line">--ruby_out：在目标目录 DST_DIR 中产生Ruby代码</span><br><span class="line">--javanano_out：在目标目录DST_DIR中生成JavaNano</span><br><span class="line">--objc_out：在目标目录DST_DIR中产生Object代码</span><br><span class="line">--csharp_out：在目标目录DST_DIR中产生Object代码</span><br><span class="line">--php_out：在目标目录DST_DIR中产生Object代码</span><br></pre></td></tr></table></figure>

<h3 id="导入proto消息文件指定"><a href="#导入proto消息文件指定" class="headerlink" title="导入proto消息文件指定"></a>导入proto消息文件指定</h3><p>必须指定一个或多个.proto文件作为输入，多个.proto文件可以只指定一个。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。</p>
<h3 id="生成编程语言相关代码"><a href="#生成编程语言相关代码" class="headerlink" title="生成编程语言相关代码"></a>生成编程语言相关代码</h3><p>当用Protobuf编译器来运行.proto文件时，编译器将生成所选择语言的代码，相应语言的代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中以及从一个输入流中解析消息。<br><code>对Go语言，编译器会为每个消息类型生成了一个.pb.go文件</code></p>
<h1 id="Protobuf3语法"><a href="#Protobuf3语法" class="headerlink" title="Protobuf3语法"></a>Protobuf3语法</h1><h2 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h2><p>消息在Protobuf中就是结构化数据  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;</span><br><span class="line"></span><br><span class="line">message Person&#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">    int32 id &#x3D; 2;</span><br><span class="line">    string email &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person消息有三个字段，在一个消息文件.proto中可以定义多个消息类型，在定义多个相关的消息时较为有用。 </p>
<p>.proto文件中非注释非空的第一行必须使用Proto版本声明，版本声明如下，如果不使用proto3版本声明，Protobuf编译器默认使用proto2版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>添加注释可以使用C风格的双斜杠（//）语法格式。</p>
<h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>.proto文件中可以新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。包的声明符会根据使用语言的不同影响生成的代码：<br>对于Go语言，包可以被用做Go包名称，除非显式的提供一个option go_package在.proto文件中。<br>Protobuf语法中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于Company.Person以“.”分隔的是从最外围开始的。<br>Protobuf编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><ul>
<li>标量类型</li>
</ul>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>Go Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>变长编码，对于负值效率低，如果字段有负值用sint64代替</td>
<td>int32</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，在负值时比int32高效的多</td>
<td>int32</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值，编码时比通常的int64高效</td>
<td>int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是4个字节，如果数值总大于228，比uint32高效</td>
<td>uint32</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8个字节，如果数值总大于256，比uint64高效</td>
<td>uint64</td>
</tr>
<tr>
<td>sfixed32</td>
<td></td>
<td>int32</td>
</tr>
<tr>
<td>sfixed64</td>
<td></td>
<td>int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
</tr>
<tr>
<td>string</td>
<td></td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据</td>
<td>[]byte</td>
</tr>
</tbody></table>
<ul>
<li>合成类型<br>合成类型包括枚举(enumerations)或其它消息类型</li>
</ul>
]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine Synchronized!</title>
    <url>/2018/12/02/golang/2018-12-02-goroutinesync/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="1，time-sleep"><a href="#1，time-sleep" class="headerlink" title="1，time.sleep()"></a>1，time.sleep()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line"> var buf []byte</span><br><span class="line"> var err error</span><br><span class="line"> &#x2F;&#x2F;发送HTTP请求</span><br><span class="line"> go func()&#123;</span><br><span class="line"> buf, err &#x3D; http.Get(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;api&quot;)</span><br><span class="line"> &#125;()</span><br><span class="line"> &#x2F;&#x2F;主线程sleep 5s，等待上面的goroutine发送http请求结束</span><br><span class="line"> time.Sleep(5e9)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2，使用channel机制"><a href="#2，使用channel机制" class="headerlink" title="2，使用channel机制"></a>2，使用channel机制</h2><p>每个goroutine传一个channel进去然后往里写数据，在再主线程中读取这些channel，直到全部读到数据了子goroutine也就全部运行完了，那么主goroutine也就可以结束了。这种模式是子线程去通知主线程结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">  &#x2F;&#x2F;生产者&#x2F;消费者使用的channel</span><br><span class="line">  var proChan &#x3D; make(chan int)</span><br><span class="line">  &#x2F;&#x2F;主线程channel</span><br><span class="line">  var mainChan &#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;生产者</span><br><span class="line">  go func()&#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class="line">            proChan &lt;- i</span><br><span class="line">            fmt.Println(&quot;生产者写入数据&quot;, i)</span><br><span class="line">        &#125;</span><br><span class="line">    close(proChan)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;消费者1</span><br><span class="line">  go func()&#123;</span><br><span class="line">     for v :&#x3D; range proChan &#123;</span><br><span class="line">            fmt.Println(&quot;\t消费者读出数据&quot;, v)</span><br><span class="line"></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;消费者2</span><br><span class="line">  go func()&#123;</span><br><span class="line">     for v :&#x3D; range proChan &#123;</span><br><span class="line">            fmt.Println(&quot;\t消费者读出数据&quot;, v)</span><br><span class="line"></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  &lt;- mainChan</span><br><span class="line">  &lt;- mainChan</span><br><span class="line">  &#x2F;&#x2F;主线程通过mainChan读出数据进行阻塞，达到线程同步的目的  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，使用context中cancel函数"><a href="#3，使用context中cancel函数" class="headerlink" title="3，使用context中cancel函数"></a>3，使用context中cancel函数</h2><p>主线程去通知子线程结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2 * time.Second)</span><br><span class="line">    defer cancel()</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go work(ctx)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;Finished&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func work(ctx context.Context) &#123;</span><br><span class="line">    tr :&#x3D; &amp;http.Transport&#123;&#125;</span><br><span class="line">    client :&#x3D; &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    c :&#x3D; make(chan ResPack, 1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，sync-WaitGroup模式"><a href="#4，sync-WaitGroup模式" class="headerlink" title="4，sync.WaitGroup模式"></a>4，sync.WaitGroup模式</h2><p>Add方法设置等待子goroutine的数量，使用Done方法设置等待子goroutine的数量减1，当等待的数量等于0时，Wait函数返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func download(i int,wg *sync.WaitGroup)&#123;</span><br><span class="line">  defer wg.Done</span><br><span class="line">  &#x2F;&#x2F;下载照片的逻辑代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">  var wg &#x3D; &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">  &#x2F;&#x2F;创建多个协程，同时下载多个图片</span><br><span class="line">  for i :&#x3D;1; i&lt;24; i++ &#123;  </span><br><span class="line">       &#x2F;&#x2F;计数器+1  </span><br><span class="line">       wg.Add(1)</span><br><span class="line">       &#x2F;&#x2F;多个协程去下载照片,在download方法中需要调用wg.Done()让计数器减1</span><br><span class="line">       go download(i， wg)  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;等待所有协程操作完成  </span><br><span class="line">    waitGroup.Wait()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Rand Seed!</title>
    <url>/2018/12/02/golang/2018-12-02-timeseed/</url>
    <content><![CDATA[<a id="more"></a>


<h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>有10台服务器负载均衡，并提供了RESTful请求，每次获取一个实例进行通信。<br>使用rand.Int获取随机数，向其中一个实例发送RESTful请求，经发现每次获取的都是同一台机器，这样所有的流量都打到一台机器上，导致机器挂了。影响其它服务。  </p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>添加随机种子，保证每次产生的随机数不同,不过rand.Seed会导致内存飙升，影响程序的性能，最好放到init方法中。<br>根据官方文档，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Seed uses the provided seed value to initialize the generator to a deterministic state.</span><br><span class="line">&#x2F;&#x2F; Seed should not be called concurrently with any other Rand method.</span><br></pre></td></tr></table></figure>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line"> rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">	 for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">		 x :&#x3D; rand.Intn(100)</span><br><span class="line">		 fmt.Println(x)</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong style="color:red">如果不加rand.Seed每次的结果都一样，加了之后每次结果都是随机的</strong></p>
]]></content>
      <tags>
        <tag>seed</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful之echo</title>
    <url>/2019/04/12/golang/2019-04-12-echo/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><p><a href="https://echo.labstack.com/guide">Echo</a>是一个高性能、可扩展、<strong>极简主义的golang web框架</strong>。它具有下面的特点：</p>
<ul>
<li>高效的路由</li>
<li>支持http/2</li>
<li>简单的数据绑定与渲染 支持json、xml、html和文件等</li>
<li>丰富的<code>Middleware</code> 支持内置和自定义的<code>Middleware</code></li>
</ul>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/labstack/<span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<p>下面是一个hello world示例。</p>
<p>例1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/labstack/echo&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.String(http.StatusOK, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    e.Logger.Fatal(e.Start(<span class="string">&quot;0.0.0.0:1323&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>echo.New()</code>用于创建一个新的echo实例，<code>e.Start(&quot;0.0.0.0:1323&quot;)</code>用来在<code>:1323</code>端口上启动server监听。这里也可以使用自定义的server，用来自定义相关参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := echo.New()</span><br><span class="line">s := &amp;http.Server&#123;</span><br><span class="line">    Addr:         <span class="string">&quot;0.0.0.0:1323&quot;</span>,</span><br><span class="line">    ReadTimeout:  time.Minute * <span class="number">2</span>,</span><br><span class="line">    WriteTimeout: time.Minute * <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">e.StartServer(s)</span><br></pre></td></tr></table></figure>

<p><code>e.GET(&quot;/&quot;, func(c echo.Context) error &#123;...&#125;)</code>方法即是echo的路由，将GET方法的”/“路径请求映射到相应的handle方法。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>echo的路由算法基于<code>radix tree</code>，速度非常快；并且内部实现使用了<code>sync.Pool</code>以使得其内存消耗少，GC压力小。</p>
<p>常规的，可以通过http请求方法将url路径和handle方法绑定在一起，如例1示。也可以使用<code>e.Any(&quot;/&quot;, func(c echo.context) error &#123;...&#125;)</code>。</p>
<p>echo也支持路径参数和匹配。echo的所有路由方法都会放回一个<code>*echo.Route</code>对象。</p>
<p>更为使用的是echo的路由分组功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">g := e.Group(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.POST(<span class="string">&quot;&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    name := context.FormValue(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> context.String(http.StatusOK, <span class="string">&quot;hello, &quot;</span>+name+<span class="string">&quot;.&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.GET(<span class="string">&quot;/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    id := context.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    name := context.QueryParam(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    e.Logger.Infof(<span class="string">&quot;test e.logger&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> context.JSON(http.StatusOK, <span class="string">&quot;hello, &quot;</span>+id+name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此外，<code>e.URI(HandlerFunc, ...interface&#123;&#125;)</code>可以根据handler和url中的参数得到URI；<code>e.Routes()</code>用来返回当前echo实例<code>e</code>中注册的所有路由对象的切片。</p>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p><code>echo.Context</code>封装了所有请求消息的上下文，包括请求和响应的引用、路径、参数、请求数据等等。echo的handler只需要传入一个<code>echo.Context</code>实例即可。</p>
<p><code>echo.Context</code>可以通过其方法<code>c.Param(&quot;id&quot;)</code>获取路径参数，通过<code>c.QueryParam(&quot;name&quot;)</code>获取请求参数。请过<code>c.FormValue(&quot;name&quot;)</code>获取<code>form-data</code>，…</p>
<p>此外<code>c.Bind(interface&#123;&#125;)</code>也可以用来绑定请求数据到一个golang的结构提上去：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span> <span class="string">`json:&quot;name&quot; from:&quot;name&quot; query:&quot;name&quot;`</span></span><br><span class="line">    Id    <span class="keyword">string</span> <span class="string">`json:&quot;id&quot; from:&quot;id&quot; query:&quot;id&quot;`</span></span><br><span class="line">    Phone <span class="keyword">string</span> <span class="string">`json:&quot;phone&quot; from:&quot;phone&quot; query:&quot;phone&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e := echo.New()</span><br><span class="line"></span><br><span class="line">    e.ANY(<span class="string">&quot;/save&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        user := <span class="built_in">new</span>(User)</span><br><span class="line"></span><br><span class="line">        err := context.Bind(user)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.Logger.Errorf(<span class="string">&quot;bind data failed, err : %v&quot;</span>, err)</span><br><span class="line">            context.String(http.StatusBadRequest, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context.JSONPretty(http.StatusOK, user, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个示例后，可以通过以下任意请求得到正确的响应：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://10.62.127.88:1323/save \</span><br><span class="line">-H <span class="string">&#x27;Content-Type=application/json&#x27;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;name&quot; : &quot;jmz&quot;,&quot;id&quot; : &quot;21131&quot;,&quot;phone&quot; : &quot;13661541330&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://10.62.127.88:1323/save \</span><br><span class="line">-H <span class="string">&#x27;Content-Type=application/x-www-form-urlencoded&#x27;</span> \</span><br><span class="line">-d <span class="string">&#x27;name=jmz&#x27;</span> -d <span class="string">&#x27;id=21131&#x27;</span> -d <span class="string">&#x27;phone=13661541330&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XGET http://10.62.127.88:1323/save?name=jmz&amp;id=21131&amp;phone=13661541330</span><br></pre></td></tr></table></figure>

<p>echo没有内建请求数据验证功能，但是提供了<code>e.Validator</code>接收自定义的数据验证模块，如使用<a href="https://github.com/go-playground/validator">validator</a>等第三方验证模块。</p>
<p>可以通过方法<code>c.Request()</code>放回一个<code>*http.Request</code>对象，并从中取得请求的所有参数，包括请求头，请求体，URL，方法等。</p>
<p>数据渲染方面，echo支持text，json，xml，html，File，stream等诸多常见格式。echo是通过<code>echo.Context</code>中的相应方法来渲染数据的。</p>
<p>常见的响应数据渲染方法包括：</p>
<ul>
<li><code>c.NoContent(http.StatusOK)</code> 仅有返回码，无content</li>
<li><code>c.JSON(http.StatusOK, user)</code> 以<code>application/json</code>类型返回<code>user</code>对象的json数据</li>
<li><code>c.JSONPretty(http.StatusOK, user, &quot;  &quot;)</code> 以可读的方式放回<code>user</code>的json数据</li>
<li><code>c.String(http.StatusOK, &quot;hello, world.&quot;)</code> 以文本格式(<code>text/plain</code>)响应请求</li>
<li><code>c.File(fileName)</code> 以<code>fileName</code>指定的文件响应请求</li>
<li><code>c.Blob(http.StatusOK, &quot;text/csv&quot;, data)</code> 以指定的<code>Content-Type</code>返回任意<code>[]byte</code>数据</li>
<li><code>c.Stream(http.StatusOK, &quot;image/png&quot;, pic)</code> 以指定的<code>Content-Type</code>返回任意数据流</li>
<li><code>c.Redirect(http.StatusMovedPermanently, &quot;http://10.62.127.88:1323/log&quot;)</code> 用来重定向请求到指定的url</li>
</ul>
<p>此外，echo还为响应提供了Hook方法，可以在每次写response前后调用hook进行相关操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e.GET(<span class="string">&quot;/picture&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    pic, err := os.Open(<span class="string">&quot;/home/juc.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.String(http.StatusNotFound, <span class="string">&quot;image not found.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> start time.Time</span><br><span class="line"></span><br><span class="line">    c.Response().Before(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        start = time.Now()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    c.Response().After(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        e.Logger.Infof(<span class="string">&quot;write picture caused %v&quot;</span>, time.Since(start))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.Stream(http.StatusOK, <span class="string">&quot;image/png&quot;</span>, pic)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="一个echo实现的文件上传和下载的示例"><a href="#一个echo实现的文件上传和下载的示例" class="headerlink" title="一个echo实现的文件上传和下载的示例"></a>一个echo实现的文件上传和下载的示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/labstack/echo&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uploadDir = <span class="string">&quot;/home/testUpload/&quot;</span></span><br><span class="line"><span class="keyword">var</span> downloadDir = <span class="string">&quot;/root/gopackage/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e := echo.New()</span><br><span class="line"></span><br><span class="line">    s := &amp;http.Server&#123;</span><br><span class="line">        Addr:         <span class="string">&quot;0.0.0.0:1324&quot;</span>,</span><br><span class="line">        ReadTimeout:  time.Minute * <span class="number">2</span>,</span><br><span class="line">        WriteTimeout: time.Minute * <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.GET(<span class="string">&quot;/download/:file&quot;</span>, download)</span><br><span class="line"></span><br><span class="line">    e.POST(<span class="string">&quot;/upload&quot;</span>, upload)</span><br><span class="line"></span><br><span class="line">    e.Logger.Fatal(e.StartServer(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fileName := c.Param(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.File(downloadDir + fileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Source</span></span><br><span class="line">    file, err := c.FormFile(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    src, err := file.Open()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination</span></span><br><span class="line">    dst, err := os.Create(uploadDir + file.Filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy</span></span><br><span class="line">    <span class="keyword">if</span> _, err = io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;File %s uploaded successfully.&quot;</span>, file.Filename))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，文件上传时，请求的<code>Content-Type</code>必须为<code>multipart/form-data</code>，body里的key为<code>test</code>，type为<code>file</code>，value中则是要上传的文件。</p>
<h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><p>MiddleWare是一个函数，这个函数能够嵌入到一对请求-响应中，并获取<code>echo.Context</code>对象以进行一些操作action，功能有点类似于Spring Framework中的拦截器。例如<code>middleware.Logger()</code>就可以对将所有的用户请求打印到日志。</p>
<p>echo的中间件按照作用范围和执行时机分类大概有四个类别：</p>
<h3 id="Before-Route-Root-level"><a href="#Before-Route-Root-level" class="headerlink" title="Before Route(Root level)"></a>Before Route(Root level)</h3><p>这个级别的middleware在请求被路由之前执行action，这类middleware通过<code>echo.Pre()</code>注册。由于作用于路由之前，所有这类middleware不能够访问和操作<code>echo.Context</code>。常用内置的这类middleware包括：</p>
<ul>
<li><code>middleware.HTTPSRedirect()</code> 可以将http请求重定向为https请求</li>
<li><code>middleware.HTTPSWWWRedirect()</code> 可以将http请求重定向到<a href="http://www.***请求/">http://www.***请求</a></li>
</ul>
<p>等等。</p>
<h3 id="After-Route-Root-level"><a href="#After-Route-Root-level" class="headerlink" title="After Route(Root level)"></a>After Route(Root level)</h3><p>这个类型的middleware使用<code>echo.Use()</code>函数注册。middleware的action在请求路由处理完成后执行，因此可以访问请求的<code>echo.Context</code>，所以也注定有着更为广泛的用途，常见的包括日志、压缩、安全认证、请求限制等等。</p>
<h3 id="Group-level"><a href="#Group-level" class="headerlink" title="Group level"></a>Group level</h3><p>通过<code>e.Group(path, middleware)</code>方法在创建group是指定一个或多个middlewares，作用域仅仅为当前的路由分组，也可以使用<code>g.Use()</code>来注册middlewares。</p>
<h3 id="Route-level"><a href="#Route-level" class="headerlink" title="Route level"></a>Route level</h3><p>这种middleware在创建路由时指定，middleware的action仅能够对相应的请求起作用。</p>
<h3 id="自定义middleware"><a href="#自定义middleware" class="headerlink" title="自定义middleware"></a>自定义middleware</h3><p>middleware是一个能够返回<code>HandlerFunc func(Context) error</code>类型函数的函数。通常，还可以通过为middleware配置一个<code>Skipper</code>来指定middleware对那些路由执行action。</p>
<h3 id="内建的中间件"><a href="#内建的中间件" class="headerlink" title="内建的中间件"></a>内建的中间件</h3><ul>
<li><code>CORS</code> 跨域设置中间件，默认为允许来自所有域的访问，echo默认内置了该中间件。也可以通过<code>middleware.CORSWithConfig(middleware.CORSConfig)</code>来自定义跨域配置，其中<code>middleware.CORSConfig</code>的主要配置项包括<ul>
<li><code>Skipper</code>，用来决定哪些路由需要执行action</li>
<li><code>AllowOrigins</code> 定义了可以访问资源的域的集合</li>
<li><code>AllowMethods</code> 定义了允许访问资源的请求方法</li>
<li><code>AllowHeaders</code> 定义了可以用来请求资源的请求体</li>
</ul>
</li>
<li><code>CSRF</code> 跨站请求伪造中间件，又称<code>XSRF</code>。echo内置的CSRF中间件通过请求体的<code>X-CSRF-Token</code>来防止跨站伪造</li>
<li>安全认证类中间件，内置的包括<code>Basic Auth</code>、<code>Casbin Auth</code>、<code>Key Auth</code>、<code>Secure</code>等</li>
<li><code>Logger</code> 日志中间件，用来记录每一次请求到日志，可以通过配置定义日志格式以及output，echo日志系统见下一节</li>
<li><code>Recover</code> 将程序从请求处理的panic中恢复，可以配置是否输出错误栈以及输出栈的深度</li>
<li><code>Body Limit</code> 限制请求体(request body)的大小，通过<code>Content-Length</code>工作。</li>
<li><code>Request ID</code> 为每次请求生成一个唯一ID</li>
<li><code>Session</code> 用于会话管理，基于<a href="https://github.com/gorilla/sessions">gorilla/sessions</a></li>
<li><code>Trailing Slash</code> 为请求URL添加尾部斜杠</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>上一节提到了middleware中间件的日志<code>middleware.Logger</code>，它用来记录请求-响应中的一些信息，如请求处理耗时，请求大小，状态码等。</p>
<p>echo也提供了自己的日志框架：<code>echo.Logger</code>。<code>echo.Logger</code>方便我们在处理请求过程中自定义日志，并且同样可配置。下面是一个通过<a href="https://github.com/lestrrat-go/file-rotatelogs">file-rotatelogs</a>写日志到文件的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := echo.New()</span><br><span class="line"></span><br><span class="line">writer, _ := rotatelogs.New(</span><br><span class="line">    logName+<span class="string">&quot;.%Y%m%d%H&quot;</span>,</span><br><span class="line">    rotatelogs.WithLinkName(logName),</span><br><span class="line">    rotatelogs.WithRotationTime(time.Hour),</span><br><span class="line">    rotatelogs.WithRotationCount(<span class="number">24</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logConf := middleware.LoggerConfig&#123;</span><br><span class="line">    Skipper: <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Format: <span class="string">`&#123;&quot;time&quot;:&quot;$&#123;time_rfc3339_nano&#125;&quot;,&quot;remote_ip&quot;:&quot;$&#123;remote_ip&#125;&quot;,&quot;host&quot;:&quot;$&#123;host&#125;&quot;,`</span> +</span><br><span class="line">        <span class="string">`&quot;method&quot;:&quot;$&#123;method&#125;&quot;,&quot;uri&quot;:&quot;$&#123;uri&#125;&quot;,&quot;status&quot;:$&#123;status&#125;,&quot;error&quot;:&quot;$&#123;error&#125;&quot;,`</span> +</span><br><span class="line">        <span class="string">`&quot;latency_human&quot;:&quot;$&#123;latency_human&#125;&quot;,&quot;bytes_in&quot;:$&#123;bytes_in&#125;,`</span> +</span><br><span class="line">        <span class="string">`&quot;bytes_out&quot;:$&#123;bytes_out&#125;&#125;`</span> + <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    Output: writer,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e.Use(middleware.LoggerWithConfig(logConf))</span><br><span class="line"></span><br><span class="line">e.Logger.SetOutput(writer)</span><br><span class="line">e.Logger.SetHeader(<span class="string">`&#123;&quot;time&quot;:&quot;$&#123;time_rfc3339_nano&#125;&quot;,&quot;level&quot;:&quot;$&#123;level&#125;&quot;,&quot;prefix&quot;:&quot;$&#123;prefix&#125;&quot;,`</span> +</span><br><span class="line">    <span class="string">`&quot;file&quot;:&quot;$&#123;short_file&#125;&quot;,&quot;line&quot;:&quot;$&#123;line&#125;&quot;&#125;`</span>)</span><br><span class="line">e.Logger.SetLevel(log.DEBUG)</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="平滑关闭"><a href="#平滑关闭" class="headerlink" title="平滑关闭"></a>平滑关闭</h3><p>echo支持第三方的<code>Graceful</code>，如标准库的<code>http.Server#Shutdown()</code>、<a href="https://github.com/tylerb/graceful">graceful</a>或者<a href="https://github.com/facebookgo/grace">grace</a>等，下面是官方提供的grace shutdown示例：</p>
<figure class="highlight go"><figcaption><span>facebook/grace</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/facebookgo/grace/gracehttp&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/labstack/echo&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Setup</span></span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.String(http.StatusOK, <span class="string">&quot;Six sick bricks tick&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    e.Server.Addr = <span class="string">&quot;:1323&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serve it like a boss</span></span><br><span class="line">    e.Logger.Fatal(gracehttp.Serve(e.Server))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>graceful</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/labstack/echo&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tylerb/graceful&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Setup</span></span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.String(http.StatusOK, <span class="string">&quot;Sue sews rose on slow joe crows nose&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    e.Server.Addr = <span class="string">&quot;:1323&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serve it like a boss</span></span><br><span class="line">    graceful.ListenAndServe(e.Server, <span class="number">5</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p> echo支持从中间件或者action返回HTTP错误集中处理。这样可以允许我们在统一的地方记录日志提供给第三方或者返回自定义的HTTP响应给客户端，错误可以是<code>error</code>或者<code>*echo.HTTPError</code>。</p>
<p> 下面是一个错误处理的示例：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> e.Use(<span class="function"><span class="keyword">func</span><span class="params">(next echo.HandlerFunc)</span> <span class="title">echo</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Extract the credentials from HTTP request header and perform a security</span></span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For invalid credentials</span></span><br><span class="line">    <span class="keyword">return</span> echo.NewHTTPError(http.StatusUnauthorized, <span class="string">&quot;Please provide valid credentials&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For valid credentials call next</span></span><br><span class="line">    <span class="comment">// return next(c)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实echo算不上完整的web框架，缺乏像beego等web框架那样对MVC、ORM、cache等的支持。但echo一向以极简主义著称，所有很适合作为嵌入式web服务器，以少量代码提供功能完整多样的http服务。</p>
]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>echo</tag>
      </tags>
  </entry>
  <entry>
    <title>Syscall.Exec!</title>
    <url>/2019/04/17/golang/2019-04-17-syscall-exec/</url>
    <content><![CDATA[<a id="more"></a>

<p><strong style="color:green">文章转载自： <a href="https://www.jianshu.com/p/e1de8fc52718">https://www.jianshu.com/p/e1de8fc52718</a></strong></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在docker的docker-entrypoint.sh脚本中我们经常会看到有如下的一句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec $@</span><br></pre></td></tr></table></figure>
<p><strong>Q:</strong> 在shell脚本中exec有什么作用？<br><strong>A:</strong> exec会执行参数指定的命令，但是并不创建新的进程，只在当前进程空间内执行，即替换当前进程的执行内容，他们重用同一个进程号PID.</p>
<h1 id="golang中Exec"><a href="#golang中Exec" class="headerlink" title="golang中Exec"></a>golang中Exec</h1><p>go语言syscall.Exec完成和shell中同样的功能</p>
<p>请看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">executablePath, err :&#x3D; exec.LookPath(&quot;ls&quot;)</span><br><span class="line">if err !&#x3D; nil&#123;</span><br><span class="line">  panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args :&#x3D; []string&#123;&quot;ls&quot;, &quot;-l&quot;&#125;</span><br><span class="line">env :&#x3D; os.Environ()</span><br><span class="line"></span><br><span class="line">if err :&#x3D; syscall.Exec(executablePath, args, env); err !&#x3D; nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>syscall.Exec需要三个参数：</p>
<ul>
<li>第一个参数是可执行文件的路径，注意不会自动从PATH下面去搜索<ul>
<li>要么是显式的指定全路径：/path/to/executable</li>
<li>要么是显式的指定相对路径: ./relpath/to/executable</li>
<li>要么通过exec.LookPath从PATH里面搜索出来,参考本例</li>
</ul>
</li>
<li>第二个参数是参数列表<ul>
<li>注意args[0]是可执行程序名，这个内容会显示在ps -ef的输出中。用户可以改这个值，例如明明执行的是/usr/bin/sleep的可执行程序，但是这里可以改成任意字符串，例如ls，这样用户在ps -ef查看到的就是ls的命令在运行，而不是sleep命令，混淆用户。</li>
<li>后面是正常的参数。</li>
</ul>
</li>
<li>第三个参数是环境变量<ul>
<li>如果没有传，那么不会自动继承caller的环境变量的。</li>
</ul>
</li>
</ul>
<p><strong style="color:red">syscall.Exec只能是main函数的最后一条指令，它后面的代码不会被执行到</strong></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>syscall.Exec</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s basic tutorials!</title>
    <url>/2019/04/18/golang/2019-04-18-k8s-basic-tutorials/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="kubernetes基础"><a href="#kubernetes基础" class="headerlink" title="kubernetes基础"></a>kubernetes基础</h1><h2 id="kuberntes能为你做什么"><a href="#kuberntes能为你做什么" class="headerlink" title="kuberntes能为你做什么?"></a>kuberntes能为你做什么?</h2><ul>
<li>给现代化的web服务提供7*24的运行机制;</li>
<li>随时都能发布新的应用程序版本;</li>
</ul>
<h2 id="kubernetes基本模块"><a href="#kubernetes基本模块" class="headerlink" title="kubernetes基本模块"></a>kubernetes基本模块</h2><ul>
<li>创建k8s集群(kubernetes cluster)</li>
<li>部署一个应用(deploy app)</li>
<li>查看你的应用(describe app)</li>
<li>暴露你的应用(expose app)</li>
<li>扩展你的应用(scale app)</li>
<li>升级你的应用(rolling update app)</li>
</ul>
<h1 id="创建k8s集群"><a href="#创建k8s集群" class="headerlink" title="创建k8s集群"></a>创建k8s集群</h1><p><code>Minikube可以用来搭建最简单的k8s集群，只包含一个 master以及一个node</code></p>
<p>k8s集群的两种类型资源：</p>
<ul>
<li>Master： 协调集群</li>
<li>Nodes： 工作节点，运行应用程序</li>
</ul>
<p>node节点上包含kubelet进程，该进程类似一个agent，用来管理部署在该节点上的pod，它主要负责管理node节点和master之间的通信</p>
<p>pod是k8s抽象的概念，它是原子的，被用来表示一组、一个或多个应用程序容器，以及这些容器的一些共享的资源.Pod是给应用程序的逻辑主机建模，其中pod内包含的容器是相对紧密耦合的。pod中的容器共享一个IP地址和端口空间，总是同时定位和调度，在同一个节点上共享上下文中运行。pod中共享的资源包含：</p>
<ul>
<li>共享存储，作为卷</li>
<li>共享网络，作为唯一的集群ip地址</li>
<li>有关如何运行每个容器的信息，如容器映像版本和要使用的特定的端口</li>
</ul>
<h1 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h1><ul>
<li>kubectl version: 查看版本</li>
<li>kubectl get nodes： 获取k8s的node节点</li>
<li>kubectl cluster-info：获取k8s集群信息</li>
<li>kubectl run app_name –image=image_name –port=8080： 部署应用，并暴露端口为8080</li>
<li>kubectl get deployments： 获取部署单元</li>
</ul>
<h1 id="查看应用"><a href="#查看应用" class="headerlink" title="查看应用"></a>查看应用</h1><ul>
<li>kubectl get: 列出资源</li>
<li>kubectl describe: 查看资源的详细信息</li>
<li>kubectl logs： 打印pod中的容器的日志</li>
<li>kubectl exec: 在pod的容器中执行命令</li>
<li>kubectl get pods: 获取所有pods，具体环境中需要带上namespace(–namespace=abc)</li>
<li>kubectl describe pods: 获取所有pods的详细,具体环境需要带上namespace</li>
<li>kubectl describe pod/$pod_name</li>
<li>kubectl　logs $POD_name: 获取pod中容器的日志，具体环境需要带上namespace,如果pod中有多个容器，会提示需要查看哪一个容器的日志，要用下面的方式进行查看<br>kubectl logs $pod_name  $container_name： 如果pod中包含多个容器，需要用这种方式查看日志</li>
<li>kubectl exec -it –namespace=$NAMESPACE_NAME $POD_NAME –  sh： 进入具体的pod中查看日志</li>
</ul>
<h1 id="暴露应用"><a href="#暴露应用" class="headerlink" title="暴露应用"></a>暴露应用</h1><p><code>pod的生命周期毕竟有限，可能由于其他的原因导致终结，k8s集群发现出现该种情况，会重建新的pod替换原来消亡的pod，但是新的pod的ip地址会发生改变，为了适配因pod的改变导致的ip地址的变化，需要增加一种方式自动协调pod的这种改变</code></p>
<ul>
<li>Service： Kubernetes中的服务是一个抽象，它定义了一组逻辑Pod和访问它们的策略。</li>
<li>Service支持依赖的pod之间的松散耦合</li>
<li>服务可以通过在ServiceSpec中指定类型以不同的方式公开</li>
<li>有些服务没有定义<code>selector</code>, 没有定义<code>selector</code>的服务，不会创建【对应的端点对象】</li>
<li>服务使用标签和选择器匹配一组pod，选择器是一种分组原语，允许对Kubernetes中的对象进行逻辑操作</li>
</ul>
<p>几种ServiceSpec类型：</p>
<ul>
<li>ClusterIP(默认)： 在集群中的内部IP上公开服务。这种类型使服务只能从集群中访问。</li>
<li>NodePort： 使用NAT在集群中每个选定节点的相同端口上公开服务。使用<NodeIP>:<NodePort>从集群外部访问服务。ClusterIP的超集。</li>
<li>LoadBalancer： 在当前云中创建一个外部负载平衡器(如果受支持)，并为服务分配一个固定的外部IP。NodePort的超集。</li>
<li>ExternalName： 通过返回带有名称的CNAME记录，使用任意名称(在规范中由externalName指定)公开服务。没有使用代理。这种类型需要使用v1.7或更高版本的kube-dns。</li>
</ul>
<p>pod和deployment的关系?<br>pod是单一或者一组容器的合集，deployment是pod版本管理的工具，用来区分不用版本的pod<br>pod是可以单独创建并进行生命周期管理的，单独创建pod的时候就不会出现depoloyment，但是创建deployment一定会创建pod，因为pod是一个基础单位。<br>任何控制器单位的具体实现必须落到pod中去实现。</p>
<p>标签Label，是k/v键值对，可以有以下几种使用方式：</p>
<ul>
<li>为开发、测试和生产指定对象</li>
<li>嵌入版本标记</li>
<li>使用标签对对象进行分类</li>
</ul>
<h1 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h1><h1 id="升级应用"><a href="#升级应用" class="headerlink" title="升级应用"></a>升级应用</h1>]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubectl!</title>
    <url>/2019/04/22/golang/2019-04-22-kubernetes-kubectl/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>kubernetes中的命令行接口叫做kubectl，用来控制kubernetes集群。</p>
<p>kubectl采用Cobra库进行构建，关于Cobra的简单使用，请参考<a href="https://guodongq.github.io/2019/04/19/golang-cli-about-cobra/">Cobra Cli</a></p>
<h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><ul>
<li>api: 接口文档，基本上都是json源码</li>
<li>build: 构建脚本</li>
<li>cluster: 关于集群的相关配置</li>
<li>cmd: 所有二进制可执行文件入口代码，即各种命令的接口代码</li>
<li>docs: 文档</li>
<li>Godeps: 项目依赖的Go第三方包，比如docker客户端sdk、rest等</li>
<li>hack: 工具箱，各种编译、构建、校验脚本</li>
<li>logo: kubernetes logo</li>
<li>pkg: 项目diamante主目录，cmd只是接口，这里是具体实现，cmd类似业务代码，pkg类似核心</li>
<li>plugin: 插件</li>
<li>staging: 外部存储库</li>
<li>test: 测试相关工具</li>
<li>third_party: 第三方工具</li>
<li>translations:  翻译说明文档</li>
<li>vendor: 代码库依赖</li>
</ul>
<h1 id="kubectl结构"><a href="#kubectl结构" class="headerlink" title="kubectl结构"></a>kubectl结构</h1><h2 id="1-main"><a href="#1-main" class="headerlink" title="1.main()"></a>1.main()</h2><ul>
<li>Location: <code>cmd/kubectl/kubectl.go</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">         &#x2F;&#x2F; 使用时间作为随机数生成器，具体参考https:&#x2F;&#x2F;guodongq.github.io&#x2F;2018&#x2F;12&#x2F;02&#x2F;golang-time-seed</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建kubectl命令以及子命令，最后生成*cobra.Command对象</span><br><span class="line">	command :&#x3D; cmd.NewDefaultKubectlCommand()    </span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; TODO: once we switch everything over to Cobra commands, we can go back to calling</span><br><span class="line">	&#x2F;&#x2F; cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span><br><span class="line">	&#x2F;&#x2F; normalize func and add the go flag set by hand.</span><br><span class="line">	pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line">	pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class="line">	&#x2F;&#x2F; cliflag.InitFlags()</span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	defer logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 执行命令，Cobra主框架函数</span><br><span class="line">	if err :&#x3D; command.Execute(); err !&#x3D; nil &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, &quot;%v\n&quot;, err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-cmd-NewDefaultKubectlCommand"><a href="#2-cmd-NewDefaultKubectlCommand" class="headerlink" title="2.cmd.NewDefaultKubectlCommand()"></a>2.cmd.NewDefaultKubectlCommand()</h2><ul>
<li>Location: <code>pkg/kubectl/cmd/cmd.go</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func NewDefaultKubectlCommand() *cobra.Command &#123;</span><br><span class="line">    return NewDefaultKubectlCommandWithArgs(</span><br><span class="line">        NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), </span><br><span class="line">        os.Args, </span><br><span class="line">        os.Stdin,</span><br><span class="line">        os.Stdout, </span><br><span class="line">        os.Stderr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建kubectl命令使用默认的参数：</p>
<ul>
<li>plugin.ValidPluginFilenamePrefixes: 定义了一个切片，里面包含一个元素<code>[]string&#123;&quot;kubectl&quot;&#125;</code></li>
<li>os.Args: 命令行参数,包含程序路径本身。类型是 []string ，也就是字符串切片</li>
<li>os.Stdin/os.Stdout/os.Stderr: 每次在调用os 包的时候都会创建三个全局的变量，本质上是创建三个绑定在std输出/输入IO的File对象, 所以我们像对待普通的File对象一样对待这三个对象即可 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   var (</span><br><span class="line">	Stdin  &#x3D; NewFile(uintptr(syscall.Stdin), &quot;&#x2F;dev&#x2F;stdin&quot;)</span><br><span class="line">	Stdout &#x3D; NewFile(uintptr(syscall.Stdout), &quot;&#x2F;dev&#x2F;stdout&quot;)</span><br><span class="line">	Stderr &#x3D; NewFile(uintptr(syscall.Stderr), &quot;&#x2F;dev&#x2F;stderr&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>NewDefaultPluginHandler: 实例化类DefaultPluginHandler，该结构是接口PluginHandler的实现类，主要实现了两个方法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> type PluginHandler interface &#123;</span><br><span class="line">Lookup(filename string) (string, bool)</span><br><span class="line">Execute(executablePath string, cmdArgs, environment []string) error</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="3-NewDefaultKubectlCommandWithArgs"><a href="#3-NewDefaultKubectlCommandWithArgs" class="headerlink" title="3.NewDefaultKubectlCommandWithArgs()"></a>3.NewDefaultKubectlCommandWithArgs()</h2><ul>
<li>Location: <code>pkg/kubectl/cmd/cmd.go</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func NewDefaultKubectlCommandWithArgs(pluginHandler PluginHandler, args []string, in io.Reader, out, errout io.Writer) *cobra.Command &#123;</span><br><span class="line">        &#x2F;&#x2F; 构造kubectl命令</span><br><span class="line">	cmd :&#x3D; NewKubectlCommand(in, out, errout)</span><br><span class="line"></span><br><span class="line">	if pluginHandler &#x3D;&#x3D; nil &#123;</span><br><span class="line">		return cmd</span><br><span class="line">	&#125;</span><br><span class="line">	if len(args) &gt; 1 &#123;</span><br><span class="line">                &#x2F;&#x2F; cmdPathPieces是除了文件名之外的其他参数</span><br><span class="line">		cmdPathPieces :&#x3D; args[1:]</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; only look for suitable extension executables if</span><br><span class="line">		&#x2F;&#x2F; the specified command does not already exist</span><br><span class="line">		if _, _, err :&#x3D; cmd.Find(cmdPathPieces); err !&#x3D; nil &#123;</span><br><span class="line">			if err :&#x3D; HandlePluginCommand(pluginHandler, cmdPathPieces); err !&#x3D; nil &#123;</span><br><span class="line">				fmt.Fprintf(errout, &quot;%v\n&quot;, err)</span><br><span class="line">				os.Exit(1)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-NewKubectlCommand"><a href="#4-NewKubectlCommand" class="headerlink" title="4.NewKubectlCommand()"></a>4.NewKubectlCommand()</h2><ul>
<li>Location： <code>pkg/kubectl/cmd/cmd.go</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func NewKubectlCommand(in io.Reader, out, err io.Writer) *cobra.Command &#123;</span><br><span class="line">	&#x2F;&#x2F; 利用cobra库初始化构造一个*cobra.Command对象</span><br><span class="line">	cmds :&#x3D; &amp;cobra.Command&#123;</span><br><span class="line">		Use:   &quot;kubectl&quot;,</span><br><span class="line">		Short: i18n.T(&quot;kubectl controls the Kubernetes cluster manager&quot;),</span><br><span class="line">		Long: templates.LongDesc(&#96;</span><br><span class="line">      kubectl controls the Kubernetes cluster manager.</span><br><span class="line">      Find more information at:</span><br><span class="line">            https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;reference&#x2F;kubectl&#x2F;overview&#x2F;&#96;),</span><br><span class="line">		Run: runHelp,</span><br><span class="line">		&#x2F;&#x2F; PresistentPreRunE和PresistentPostRunE两个方法分别在Run方法执行之前或者之后运行</span><br><span class="line">		PersistentPreRunE: func(*cobra.Command, []string) error &#123;</span><br><span class="line">			return initProfiling()</span><br><span class="line">		&#125;,</span><br><span class="line">		PersistentPostRunE: func(*cobra.Command, []string) error &#123;</span><br><span class="line">			return flushProfiling()</span><br><span class="line">		&#125;,</span><br><span class="line">		&#x2F;&#x2F; bash 命令自动补全</span><br><span class="line">		BashCompletionFunction: bashCompletionFunc,</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 初始化*flag.FlagSet对象</span><br><span class="line">	flags :&#x3D; cmds.PersistentFlags()</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 将flags中的 &quot;_&quot; 替换成 &quot;-&quot; 并打印日志</span><br><span class="line">	flags.SetNormalizeFunc(cliflag.WarnWordSepNormalizeFunc) &#x2F;&#x2F; Warn for &quot;_&quot; flags</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将flags中的 &quot;_&quot; 替换成 &quot;-&quot;</span><br><span class="line">	flags.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 增加两个变量用于配置 &quot;profile&quot;和&quot;profile-output&quot;</span><br><span class="line">	addProfilingFlags(flags)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 实例化*ConfigFlags对象</span><br><span class="line">	kubeConfigFlags :&#x3D; genericclioptions.NewConfigFlags(true).WithDeprecatedPasswordFlag()</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;将 *ConfigFlags对象中的每一个元素，通过指针的方式绑定到 *pflag.FlagSet对象</span><br><span class="line">	kubeConfigFlags.AddFlags(flags)</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 实例化*MatchVersionFlags对象，该对象内部持有genericclioptions.RESTClientGetter接口，而*ConfigFlags(kubeConfigFlags)对象实现了该接口，并作为入参实例化了*MatchVersionFlags对象, 其实*MatchVersionFlags也是实现了接口genericclioptions.RESTClientGetter接口</span><br><span class="line">	matchVersionKubeConfigFlags :&#x3D; cmdutil.NewMatchVersionFlags(kubeConfigFlags)</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 往*pflag.FlagSet对象中添加了一个bool类型的flag【--match-server-version】,它的值来自上面matchVersionKubeConfigFlags对象中的RequireMatchedServerVersion属性的值</span><br><span class="line">	matchVersionKubeConfigFlags.AddFlags(cmds.PersistentFlags())</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将*pflag.FlagSet对象添加到原生的*goflag.FlagSet对象中，最后再将原生的newSet(*goflag.FlagSet)添加到 *pflag.FlagSet对象的属性addedGoFlagSets上</span><br><span class="line">	cmds.PersistentFlags().AddGoFlagSet(flag.CommandLine)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 实例化接口Factory(factoryImpl), 将matchVersionKubeConfigFlags（实现了接口genericclioptions.RESTClientGetter）作为参数传递给factoryImpl的属性clientGetter上</span><br><span class="line">	f :&#x3D; cmdutil.NewFactory(matchVersionKubeConfigFlags)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 传入nil，会获取系统的语言(依次获取环境变量中的LC_ALL&#x2F;LC_MESSAGES&#x2F;LANG），将结果返回，如果是zh_CN.UTF-8将返回zh_CN， 默认会返回default字符串，主要是加载翻译的文件&#123;kubectl&#x2F;en_US&#x2F;LC_MESSAGES&#x2F;k8s.po(.mo)&#125;</span><br><span class="line">	i18n.LoadTranslations(&quot;kubectl&quot;, nil)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 给命令以及子命令设置 &quot;_&quot;变成&quot;-&quot;, 包括所有的命令*cobra.Command中的属性flags以及pflags</span><br><span class="line">	cmds.SetGlobalNormalizationFunc(cliflag.WarnWordSepNormalizeFunc)</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;将std.in&#x2F;std.out&#x2F;std.errout放在类IOStreams中封装</span><br><span class="line">	ioStreams :&#x3D; genericclioptions.IOStreams&#123;In: in, Out: out, ErrOut: err&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 定义kubectl的子命令，按照分组的方式，传入了上面的 factoryImpl(f)实例和ioStreams</span><br><span class="line">	groups :&#x3D; templates.CommandGroups&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Basic Commands (Beginner):&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				create.NewCmdCreate(f, ioStreams),</span><br><span class="line">				expose.NewCmdExposeService(f, ioStreams),</span><br><span class="line">				run.NewCmdRun(f, ioStreams),</span><br><span class="line">				set.NewCmdSet(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Basic Commands (Intermediate):&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				explain.NewCmdExplain(&quot;kubectl&quot;, f, ioStreams),</span><br><span class="line">				get.NewCmdGet(&quot;kubectl&quot;, f, ioStreams),</span><br><span class="line">				edit.NewCmdEdit(f, ioStreams),</span><br><span class="line">				delete.NewCmdDelete(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Deploy Commands:&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				rollout.NewCmdRollout(f, ioStreams),</span><br><span class="line">				rollingupdate.NewCmdRollingUpdate(f, ioStreams),</span><br><span class="line">				scale.NewCmdScale(f, ioStreams),</span><br><span class="line">				autoscale.NewCmdAutoscale(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Cluster Management Commands:&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				certificates.NewCmdCertificate(f, ioStreams),</span><br><span class="line">				clusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class="line">				top.NewCmdTop(f, ioStreams),</span><br><span class="line">				drain.NewCmdCordon(f, ioStreams),</span><br><span class="line">				drain.NewCmdUncordon(f, ioStreams),</span><br><span class="line">				drain.NewCmdDrain(f, ioStreams),</span><br><span class="line">				taint.NewCmdTaint(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Troubleshooting and Debugging Commands:&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				describe.NewCmdDescribe(&quot;kubectl&quot;, f, ioStreams),</span><br><span class="line">				logs.NewCmdLogs(f, ioStreams),</span><br><span class="line">				attach.NewCmdAttach(f, ioStreams),</span><br><span class="line">				cmdexec.NewCmdExec(f, ioStreams),</span><br><span class="line">				portforward.NewCmdPortForward(f, ioStreams),</span><br><span class="line">				proxy.NewCmdProxy(f, ioStreams),</span><br><span class="line">				cp.NewCmdCp(f, ioStreams),</span><br><span class="line">				auth.NewCmdAuth(f, ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Advanced Commands:&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				diff.NewCmdDiff(f, ioStreams),</span><br><span class="line">				apply.NewCmdApply(&quot;kubectl&quot;, f, ioStreams),</span><br><span class="line">				patch.NewCmdPatch(f, ioStreams),</span><br><span class="line">				replace.NewCmdReplace(f, ioStreams),</span><br><span class="line">				wait.NewCmdWait(f, ioStreams),</span><br><span class="line">				convert.NewCmdConvert(f, ioStreams),</span><br><span class="line">				kustomize.NewCmdKustomize(ioStreams),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Message: &quot;Settings Commands:&quot;,</span><br><span class="line">			Commands: []*cobra.Command&#123;</span><br><span class="line">				label.NewCmdLabel(f, ioStreams),</span><br><span class="line">				annotate.NewCmdAnnotate(&quot;kubectl&quot;, f, ioStreams),</span><br><span class="line">				completion.NewCmdCompletion(ioStreams.Out, &quot;&quot;),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将定义的groups命令组，添加到cmds实例上，即调用了cmds.AddCommand(cmds... *cobra.Command)命令</span><br><span class="line">	groups.Add(cmds)</span><br><span class="line"></span><br><span class="line">	filters :&#x3D; []string&#123;&quot;options&quot;&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 定义alpha命令，当alpha命令没有子命令的时候，将其加入filters列表中</span><br><span class="line">	alpha :&#x3D; NewCmdAlpha(f, ioStreams)</span><br><span class="line">	if !alpha.HasSubCommands() &#123;</span><br><span class="line">		filters &#x3D; append(filters, alpha.Name())</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 使用go template将入参进行组合，最后全部设置到对象 cmds中</span><br><span class="line">	templates.ActsAsRootCommand(cmds, filters, groups...)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 判断命令的flag中是否包含namespace&#x2F;context&#x2F;cluster&#x2F;user这几项，如果包含，就生成各自的annotations map，每个元素中都包含两个值，其中第一个值是cobra_annotation_bash_completion_custom，结果是类似这种&quot;namespace&quot;:[&quot;cobra_annotation_bash_completion_custom&quot;, &quot;_kubectl_get_resource_namespace&quot;]等</span><br><span class="line">	for name, completion :&#x3D; range bashCompletionFlags &#123;</span><br><span class="line">		if cmds.Flag(name) !&#x3D; nil &#123;</span><br><span class="line">			if cmds.Flag(name).Annotations &#x3D;&#x3D; nil &#123;</span><br><span class="line">				cmds.Flag(name).Annotations &#x3D; map[string][]string&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cmds.Flag(name).Annotations[cobra.BashCompCustom] &#x3D; append(</span><br><span class="line">				cmds.Flag(name).Annotations[cobra.BashCompCustom],</span><br><span class="line">				completion,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 增加alpha命令</span><br><span class="line">	cmds.AddCommand(alpha)</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 增加config命令</span><br><span class="line">	cmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 增加plugin命令</span><br><span class="line">	cmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 增加version命令</span><br><span class="line">	cmds.AddCommand(version.NewCmdVersion(f, ioStreams))</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 增加api-verisons命令</span><br><span class="line">	cmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 增加api-resources命令</span><br><span class="line">	cmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 增加options命令</span><br><span class="line">	cmds.AddCommand(options.NewCmdOptions(ioStreams.Out))</span><br><span class="line"></span><br><span class="line">	return cmds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Integrate error codes for the go app!</title>
    <url>/2019/05/27/golang/2019-05-27-errcode/</url>
    <content><![CDATA[<a id="more"></a>

<p>Golang provides a lot of open source frameworks for rest, such as <a href="https://beego.me/">beego</a>, <a href="http://go-echo.org/">echo</a>,<a href="https://iris-go.com/">iris</a> and so on.<br>In practice, when we use these frameworks, we will expose the unfriendly prompts such as exception information and stacks directly to the user. In this case, it is necessary to integrate error codes for your golang application.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Q：小明,不好了,你使用beego框架开发出来的微服务报错了<blockquote>
<p>啊，报的啥错呀？</p>
</blockquote>
</li>
<li>Q：界面上打印的是一串堆栈信息，看不懂<blockquote>
<p>我勒个去，可能是直接把堆栈抛出去了</p>
</blockquote>
</li>
<li>Q：中英文环境下结果还都是一样<blockquote>
<p>尼玛，没有区分不同环境了</p>
</blockquote>
</li>
<li>Q: 你难道没有在框架中引入错误码自定义异常信息吗? <blockquote>
<p>What ??? 什么是错误码 ???</p>
</blockquote>
</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在微服务盛行的今日，单体应用可能会被拆分成多个微服务，微服务之间通过rest接口进行交互。<br>如何准确定义微服务之间的REST接口显得尤为重要，好的接口对于快速定位问题很有帮助。<br>针对前言中出现的问题，归根结底是REST接口定义的问题，错误码信息缺失。</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>针对以上出现的错误，博主尝试编写了项目<a href="https://github.com/qianguodong/go.errcode">go.errcode</a>,该项目可以提供多语言支持，用以提高用户的操作体验。</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="导入项目模块"><a href="#导入项目模块" class="headerlink" title="导入项目模块"></a>导入项目模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;github.com&#x2F;qianguodong&#x2F;go.errcode&quot;</span><br></pre></td></tr></table></figure>

<h3 id="定义errcode文件"><a href="#定义errcode文件" class="headerlink" title="定义errcode文件"></a>定义errcode文件</h3><p>假设你需要支持en-US和zh-CN两种语言，那么你就需要定义<code>errcode_en-US.json</code>和<code>errcode_zh-CN.json</code>   </p>
<ul>
<li><p>文件<code>errcode_en-US.json：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errcodes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: 10001,</span><br><span class="line">      &quot;message&quot;: &quot;not found&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: 10002,</span><br><span class="line">      &quot;message&quot;: &quot;hello, %s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件 <code>errcode_zh-CN.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errcodes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: 10001,</span><br><span class="line">      &quot;message&quot;: &quot;无法找到&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: 10002,</span><br><span class="line">      &quot;message&quot;: &quot;你好, %s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="项目集成"><a href="#项目集成" class="headerlink" title="项目集成"></a>项目集成</h3><h4 id="与普通项目集成"><a href="#与普通项目集成" class="headerlink" title="与普通项目集成"></a>与普通项目集成</h4><h5 id="初始化资源文件"><a href="#初始化资源文件" class="headerlink" title="初始化资源文件"></a>初始化资源文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">		zhCN &#x3D; &quot;zh-CN&quot;</span><br><span class="line">		enUS &#x3D; &quot;en-US&quot;</span><br><span class="line">	)</span><br><span class="line">	var supportLangs &#x3D; []string&#123;zhCN, enUS&#125;</span><br><span class="line">	&#x2F;&#x2F; init loading errcode</span><br><span class="line">	for _, lan :&#x3D; range supportLangs &#123;</span><br><span class="line">		filename :&#x3D; fmt.Sprintf(&quot;errcode_%s.json&quot;, lan)</span><br><span class="line">		if err :&#x3D; errcode.TryLoadErrCodeConfig(lan, filename); err !&#x3D; nil &#123;</span><br><span class="line">			panic(fmt.Sprintf(&quot;init errcode file%s failed, error %v&quot;, filename, err))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="业务代码调用"><a href="#业务代码调用" class="headerlink" title="业务代码调用"></a>业务代码调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var language &#x3D; zhCN</span><br><span class="line">message :&#x3D; errcode.GetErrMessage(language, 10002, &quot;world!&quot;)</span><br></pre></td></tr></table></figure>
<p>message将根据请求头里面的Accept-Language不同产生不同的结果：</p>
<ul>
<li>en-US： <code>hello, world!</code></li>
<li>zh-CN： <code>你好, world!</code></li>
</ul>
<h4 id="与beego项目集成"><a href="#与beego项目集成" class="headerlink" title="与beego项目集成"></a>与beego项目集成</h4><h5 id="初始化资源文件-1"><a href="#初始化资源文件-1" class="headerlink" title="初始化资源文件"></a>初始化资源文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func init()&#123;</span><br><span class="line">	lanTypes :&#x3D; strings.Split(beego.AppConfig.String(&quot;langs-define-in-app.conf&quot;), &quot;|&quot;)</span><br><span class="line">	for _, lan :&#x3D; range lanTypes&#123;</span><br><span class="line">		if err :&#x3D; errcode.TryLoadErrCodeConfig(lan, &quot;errcode_&quot;+lan+&quot;.json&quot;); err !&#x3D; nil&#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化控制器语言"><a href="#初始化控制器语言" class="headerlink" title="初始化控制器语言"></a>初始化控制器语言</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type BaseController struct&#123;</span><br><span class="line">	&#x2F;&#x2F; ...other fields</span><br><span class="line">	errcode.Locale</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(b *BaseController) Prepare()&#123;</span><br><span class="line">	&#x2F;&#x2F; ... setter language by http header</span><br><span class="line">	b.Lan &#x3D; b.Ctx.Request.Header.Get(&quot;Accept-Language&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="业务代码调用-1"><a href="#业务代码调用-1" class="headerlink" title="业务代码调用"></a>业务代码调用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type BusinessController struct&#123;</span><br><span class="line">	BaseController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(b BusinessController)...()&#123;</span><br><span class="line">	...</span><br><span class="line">	message :&#x3D; b.GetErrMessage(10001)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>message将根据请求头里面的Accept-Language产生不同的结果：</p>
<ul>
<li>en-US： <code>not found</code></li>
<li>zh-CN： <code>无法找到</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>首先需要提供不同语言环境下的资源文件，并对资源文件进行初始化<ul>
<li>若使用类似beego这样的第三方框架，可定义<code>BaseController</code>匿名包含<code>errcode.Locale</code>,业务模块都继承自<code>BaseController</code></li>
</ul>
</li>
<li>调用获取错误码方法GetErrMessage，将语言，以及键传入，就可以得到国际化之后的错误信息</li>
<li>如果未找到相应键的对应值，则会输出键的原字符串</li>
</ul>
]]></content>
      <tags>
        <tag>error_code</tag>
      </tags>
  </entry>
  <entry>
    <title>Testify!</title>
    <url>/2019/05/30/golang/2019-05-30-testify/</url>
    <content><![CDATA[<a id="more"></a>

<p>testing是go标准库中提供的关于单元测试的相关包，不过断言我感觉是其真正缺失的东西。<br>你绝对可以通过<code>if</code>比较或者其他任何方式获得相同的结果，但相比java中提供的junit框架，golang中testing并不是最简洁的方法。<br><code>stretchr/testify</code>框架的出现，终于解决了go单元测试断言方面的缺陷，它优雅的语法使您能够编写简单得难以置信的断言。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>你可以通过如下命令来进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">go get -u github.com&#x2F;stretchr&#x2F;testify</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>我们计算数字a和数字b相加的功能函数sum，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Sum(a ,b int) int&#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们利用传统的testing的方式编写单元测试如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func TestSum(t *testing.T)&#123;</span><br><span class="line">    expected :&#x3D; 5</span><br><span class="line">    actual :&#x3D; Sum(2,6)</span><br><span class="line">    if expected !&#x3D; actual&#123;</span><br><span class="line">        t.Errorf(&quot;Sum(2,6) Expected:%v, actual:%v&quot;, expected, actual)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过传统的方式我么你发现代码不够优雅，我们将其改成使用testify的方式，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func TestSum(t *testing.T)&#123;</span><br><span class="line">    assert.Equal(t, 5, Sum(2,6))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很好，如你所见，我们使用 assert.Equal 函数简单地测试了相等性。这看起来是一种改进，因为我们需要阅读的代码行数更少了，而且我们可以清楚地看到测试函数想要达到的效果。</p>
<h1 id="将-Testify-与表驱动测试相结合"><a href="#将-Testify-与表驱动测试相结合" class="headerlink" title="将 Testify 与表驱动测试相结合"></a>将 Testify 与表驱动测试相结合</h1><p>将<code>testify</code>并入到我们测试套件中并不会妨碍我们使用诸如表驱动测试之类的方法，事实上，它能使测试变得更简单。<br>请看如下例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func TestSum(t *testing.T)&#123;</span><br><span class="line">    assert :&#x3D; assert.New(t)</span><br><span class="line">    var datas &#x3D; struct&#123;</span><br><span class="line">        a, b int</span><br><span class="line">        expected int</span><br><span class="line">    &#125;&#123;</span><br><span class="line">    &#123;2, 3, 5&#125;,</span><br><span class="line">    &#123;4, 6, 10&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for _, data :&#x3D; range datas&#123;</span><br><span class="line">        assert.Equal(data.expected, Sum(data.a, data.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意我们在此示例中调用的 assert.Equal() 与上面例子中的细微差别。我们用 assert using assert.New(t) 初始化了断言，然后我们可以多次调用 assert.Equal() ，只需传入输入值和期望值，而不是每次都将 t 作为第一个参数传入。当然这不是什么大问题，但它确实使我们的测试看起来更简洁明了.</p>
<h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>testify 包另外一个优秀的功能就是它的模拟功能。有效的模拟允许我们在代码里创建一个替代的对象，用来模拟对象的某些行为，这样我们在运行测试用例时就不用每次都期望它能够触发.</p>
<blockquote>
<p>个人感觉gomonkey的功能比testify的mock功能强大，这里就不介绍testify的模拟功能了，后面专门有一节讲解gomonkey的功能。</p>
</blockquote>
]]></content>
      <tags>
        <tag>unit test</tag>
        <tag>testify</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug with gdb!</title>
    <url>/2019/07/05/golang/2019-07-05-gdb/</url>
    <content><![CDATA[<a id="more"></a>

<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的golang程序员，gdb是必不可少的工具；</p>
<h1 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h1><h2 id="准备源码"><a href="#准备源码" class="headerlink" title="准备源码"></a>准备源码</h2><p>hello.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;debug init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mainMethod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mainMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; -ldflags &quot;-s -w&quot; -o hello hello.go</span><br></pre></td></tr></table></figure>
<ul>
<li>删除调试符号 -ldflags “-s -w”<ul>
<li>s: 去掉符号信息</li>
<li>w: 去掉DWARF调试信息</li>
</ul>
</li>
<li>关闭内联优化 -gcflags “-N -l”</li>
</ul>
<p>成功编译后，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@qgd:~&#x2F;bruce# tree src&#x2F;</span><br><span class="line">src&#x2F;</span><br><span class="line"> |-- hello</span><br><span class="line"> |-- hello.go</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure>


<h1 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h1><h2 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h2><p>通过<code>gdb 文件名</code>将待调试的程序载入，载入时会打印gdb的一些版本信息说明之类的，<code>-q</code>选项可以忽略这些输出  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@qgd:~&#x2F;bruce&#x2F;src# gdb -q hello</span><br><span class="line">Reading symbols from hello...(no debugging symbols found)...done.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>我们也可以先进入gdb模式，然后再加载文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@qgd:~&#x2F;bruce&#x2F;src# gdb -q</span><br><span class="line">(gdb) file hello</span><br><span class="line">Reading symbols from hello...(no debugging symbols found)...done.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<h2 id="显示源码"><a href="#显示源码" class="headerlink" title="显示源码"></a>显示源码</h2><p>在调试过程中，如果我们想查看源码怎么办？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) list </span><br><span class="line">1	package main</span><br><span class="line">2	</span><br><span class="line">3	import &quot;fmt&quot;</span><br><span class="line">4	</span><br><span class="line">5	func init()&#123;</span><br><span class="line">6		fmt.Println(&quot;debug init&quot;)</span><br><span class="line">7	&#125;</span><br><span class="line">8	</span><br><span class="line">9	func main()&#123;</span><br><span class="line">10		mainMethod()</span><br><span class="line">(gdb) 回车</span><br><span class="line">11	&#125;</span><br><span class="line">12	</span><br><span class="line">13	func mainMethod()&#123;</span><br><span class="line">14		fmt.Println(&quot;hello,world&quot;)</span><br><span class="line">15	&#125;</span><br><span class="line">(gdb) 回车</span><br><span class="line">Line number 16 out of range; &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go has 15 lines.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<ul>
<li>通过list命令可以显示源码，每次可以显示10行，直接enter键回车，显示接下来的10行</li>
<li>list默认参数可以用show listsize来查看，如果感觉10行太多或者太少，还可以用set listsize count来更改</li>
<li>list 还可以加上其他参数:<ul>
<li>list 5,10   显示第5行到第10行的代码</li>
<li>list hello.go:5,10  显示源文件hello.go第5行到第10行的代码，一般用于调试含多个源文件的程序</li>
<li>search str   从当前行开始，<code>向前</code>查找含str的字符串；</li>
<li>reverse-search str   从当前行开始，<code>向后</code>查找含str的字符串</li>
</ul>
</li>
</ul>
<h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) shell clear</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>感觉第6行代码可能有点问题，现在就需要我就需要设置一个断点，让程序停在第6行之前  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x48504d: file &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go, line 6.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>gdb还可以以条件表达式设置断点(条件断点)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) break 14 if 1&#x3D;&#x3D;1</span><br><span class="line">Breakpoint 2 at 0x48511d: file &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go, line 14.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>还可以直接在某个函数处设置断点；直接break 函数名就可以了  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) break main.main</span><br><span class="line">Breakpoint 6 at 0x4850d0: file &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go, line 9.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<h3 id="查询所有设置的断点"><a href="#查询所有设置的断点" class="headerlink" title="查询所有设置的断点"></a>查询所有设置的断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x000000000048504d in main.init.0 </span><br><span class="line">                                                   at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:6</span><br><span class="line">2       breakpoint     keep y   0x000000000048511d in main.mainMethod </span><br><span class="line">                                                   at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:14</span><br><span class="line">	stop only if 1&#x3D;&#x3D;1</span><br><span class="line">6       breakpoint     keep y   0x00000000004850d0 in main.main </span><br><span class="line">                                                   at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:9</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<ul>
<li>Num表示断点的编号</li>
<li>Type表示断点的断点的类型，第二个断点类型还加上了条件</li>
<li>Disp表示中断点在执行一次之后是否失去作用，dis为是，keep为不是</li>
<li>Enb表示当前中断点是否有效，y为是，n为否</li>
<li>Address表示中断点所处的内存地址</li>
<li>What指出断点所处的位置</li>
</ul>
<h3 id="断点删除"><a href="#断点删除" class="headerlink" title="断点删除"></a>断点删除</h3><p>如果不需要程序在该断点暂停时，有两种方法，一种是使该断点失效，一种是直接删除该断点。  </p>
<ul>
<li><p>断点失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disable 1</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x000000000048504d in main.init.0 </span><br><span class="line">                                                   at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:6</span><br><span class="line">2       breakpoint     keep y   0x000000000048511d in main.mainMethod </span><br><span class="line">                                                   at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:14</span><br><span class="line">	stop only if 1&#x3D;&#x3D;1</span><br><span class="line">6       breakpoint     keep y   0x00000000004850d0 in main.main </span><br><span class="line">                                                   at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:9</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>第一个断点的Enb变为n了，表示该断点已经无效了，如果需要恢复，可以使用enable命令。这里需要注意的是，disable后面的参数为断点的编号,而不是行号.</p>
</li>
<li><p>断点删除<br>可以使用clear命令和delete命令直接删除断点<br>clear命令后面的参数为设置断点的行号，clear后面参数还可以加设置断点的函数名<br>delete命令后面的参数为断点的编号；可以一次删除多个断点，断点编号之间用空格隔开；如果delete后没有参数，默认删除所以断点，会给出提示选择是否操作  </p>
</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) run                                &#x2F;&#x2F;开始执行程序</span><br><span class="line">Starting program: &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.init.0 () at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:6  &#x2F;&#x2F;设置的第一个断点，程序在第6行暂停</span><br><span class="line">6		fmt.Println(&quot;debug init&quot;)</span><br><span class="line">(gdb) continue               &#x2F;&#x2F;让程序继续运行，直到下个断点或者结束</span><br><span class="line">Continuing.</span><br><span class="line">debug init</span><br><span class="line"></span><br><span class="line">Breakpoint 6, main.main () at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:9   &#x2F;&#x2F;设置的第二个断点，程序在第9行暂停</span><br><span class="line">9	func main()&#123;</span><br><span class="line">(gdb) next                    &#x2F;&#x2F;继续执行下一条语句，只执行一条。</span><br><span class="line"></span><br><span class="line">Breakpoint 6, main.main () at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:9</span><br><span class="line">9	func main()&#123;</span><br><span class="line">(gdb) next</span><br><span class="line"></span><br><span class="line">Breakpoint 6, main.main () at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:9</span><br><span class="line">9	func main()&#123;</span><br><span class="line">(gdb) continue            &#x2F;让程序继续运行，直到下个断点或者结束</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 6, main.main () at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:9</span><br><span class="line">9	func main()&#123;</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main.mainMethod () at &#x2F;root&#x2F;bruce&#x2F;src&#x2F;hello.go:14     &#x2F;&#x2F;设置的第三个断点，程序在第14行暂停</span><br><span class="line">14		fmt.Println(&quot;hello,world&quot;)</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">hello,world</span><br><span class="line">[LWP 2116 exited]</span><br><span class="line">[Inferior 1 (process 2116) exited normally]</span><br></pre></td></tr></table></figure>
<ul>
<li>run，开始运行程序；</li>
<li>continue，程序暂停时继续运行程序的命令；</li>
<li>print 变量名或表达式，打印该变量或者该表达式的值。whatis 变量名或者表达式，可以显示该变量或表达式的数据类型。</li>
<li>print  变量=值，这种形式还可以给对应的变量赋值；类似的还有set variable 变量=值。作用和用print赋值相同。</li>
<li>next，继续执行下一条语句；还有一条命令step，与之类似，不同的是，当下一条语句遇到函数调用的时候，next不会跟踪进入函数，而是继续执行下面的语句，而step命令则会跟踪进入函数内部</li>
</ul>
]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Deduplicate slice elements!</title>
    <url>/2019/07/21/golang/2019-07-21-duplicate/</url>
    <content><![CDATA[<a id="more"></a>

<p>开发过程中，我们经常会遇到对切片中的数据进行加工，如何很优雅的对切片中的元素进行去重，本文通过代码的实例告诉大家优雅的对切片进行去重处理。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现有一个字符串的切片，如何将该切片中的元素进行去重。</p>
<h1 id="代码逻辑实现-参考k8s，-clientcmd包中的deduplicate方法"><a href="#代码逻辑实现-参考k8s，-clientcmd包中的deduplicate方法" class="headerlink" title="代码逻辑实现(参考k8s， clientcmd包中的deduplicate方法)"></a>代码逻辑实现(参考k8s， clientcmd包中的deduplicate方法)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func deduplicate(s []string) []string&#123;</span><br><span class="line">  encountered :&#x3D; map[string]bool&#123;&#125;</span><br><span class="line">  ret :&#x3D; make([]string,0)</span><br><span class="line">  for i :&#x3D; rang s&#123;</span><br><span class="line">    if encountered[s[i]] &#123;</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    encountered[s[i]] &#x3D; true</span><br><span class="line">    ret &#x3D; append(ret, s[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>duplicate_slice</tag>
      </tags>
  </entry>
  <entry>
    <title>Testing!</title>
    <url>/2019/07/29/golang/2019-07-29-testing/</url>
    <content><![CDATA[<a id="more"></a>

<p>An important part of the development process is testing, how to ensure the quality of the code, how to ensure that each function can run and the results are correct, and how to ensure the best performance of the written code.   </p>
<p>The focus of unit testing is to discover logic errors in programming or implementation, to expose problems early, and to facilitate problem location. The focus of performance testing is to find some problems in programming, so that online programs can be in high concurrency. It can still be stable.</p>
<h1 id="testing"><a href="#testing" class="headerlink" title="testing"></a>testing</h1><h2 id="单元测试准则"><a href="#单元测试准则" class="headerlink" title="单元测试准则"></a>单元测试准则</h2><ul>
<li>文件名必须<code>_test.go</code>结尾</li>
<li>必须<code>import testing</code>包</li>
<li>所有的测试用例函数必须Test开头</li>
<li>测试用例会按照源代码中定义的顺序依次执行</li>
<li>测试函数<code>TestXXX()</code>函数入参为<code>testing.T</code></li>
<li>测试格式<code>func TestXXX(t *testing.T)</code>,<code>XXX</code>部分可以为任意的字母数字组合，但是首字母必须为大写<code>[A-Z]</code></li>
<li>函数中通过调用<code>testing.T</code>的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息</li>
<li>go test命令执行的测试目标，默认为package级别，直接执行不带任何参数，会尝试执行当前目录所在的package的所有测试用例</li>
<li>go test只会在当前或用户指定的目录下查找测试函数，不会去查找子目录  </li>
<li>go test -run可以指定package中执行的函数名，如：<code>go test -run &quot;^TestA|TestB$&quot;</code>,执行名为TestA和TestB的测试函数</li>
<li>go test -v 会输出执行过程信息</li>
<li>go test -cover可以用来统计行覆盖率</li>
<li>go test 具体用法可以参考<code>go test --help</code>查询帮助信息进行查看</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生产代码</span><br><span class="line">package cal</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int&#123;</span><br><span class="line">	return a + b</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 功能测试</span><br><span class="line">package cal</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T)&#123;</span><br><span class="line">	expected :&#x3D; 5</span><br><span class="line">	actual :&#x3D; Add(3,4)</span><br><span class="line">	if expected !&#x3D; actual&#123;</span><br><span class="line">		t.Errorf(&quot;Add(3,4) got:%v, expected:%v&quot;, actual,expected)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 性能测试</span><br><span class="line">package cal</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func Benchmark(b *testing.B)&#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; b.N; i++&#123;</span><br><span class="line">		Add(4, 5)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行功能测试"><a href="#执行功能测试" class="headerlink" title="执行功能测试"></a>执行功能测试</h3><ul>
<li><code>go test -v</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ src&gt; go test -v .&#x2F;cal</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAdd</span><br><span class="line">--- FAIL: TestAdd (0.00s)</span><br><span class="line">    add_test.go:12: Add(3,4) got:7, expected:5</span><br><span class="line">FAIL</span><br><span class="line">FAIL	cal	0.007s</span><br></pre></td></tr></table></figure>



<ul>
<li>执行指定函数<code>go test -run</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ src&gt; go test -run TestAdd .&#x2F;testcase</span><br><span class="line">### 输出 ###</span><br><span class="line">--- FAIL: TestAdd (0.00s)</span><br><span class="line">    main_test.go:9: Add(3,4) got:7, expected:5</span><br><span class="line">FAIL</span><br><span class="line">FAIL    gitlab.zte.com.cn&#x2F;testcase      0.147s</span><br></pre></td></tr></table></figure>

<ul>
<li>执行性能测试<code>go test -brench</code><ul>
<li>benchmem：输出内存分配统计</li>
<li>benchtime：指定测试时间</li>
<li>cpu：指定GOMAXPROCS</li>
<li>timeout：超时限制</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ src&gt; go test -v -bench&#x3D;.  -cpu&#x3D;8 -benchtime&#x3D;&quot;3s&quot; -timeout&#x3D;&quot;5s&quot; -benchmem</span><br><span class="line">### 输出 ###</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">goos: windows</span><br><span class="line">goarch: 386</span><br><span class="line">pkg: github.com&#x2F;testcase</span><br><span class="line">Benchmark-8     1000000000               0.31 ns&#x2F;op            0 B&#x2F;op          0</span><br><span class="line">allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;testcase      1.144s</span><br></pre></td></tr></table></figure>

<h2 id="Pprof"><a href="#Pprof" class="headerlink" title="Pprof"></a>Pprof</h2><h3 id="命令行生成测试数据文件"><a href="#命令行生成测试数据文件" class="headerlink" title="命令行生成测试数据文件"></a>命令行生成测试数据文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ src&gt; go test -bench&#x3D;. -cpuprofile cpu.out</span><br><span class="line">### 输出 ###</span><br><span class="line">goos: windows</span><br><span class="line">goarch: 386</span><br><span class="line">pkg: github.com&#x2F;testcase</span><br><span class="line">Benchmark-4     2000000000               0.31 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;testcase      1.590s</span><br></pre></td></tr></table></figure>

<h4 id="命令行分析"><a href="#命令行分析" class="headerlink" title="命令行分析"></a>命令行分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ src&gt; go tool pprof -text cpu.out</span><br><span class="line">### 输出 ###</span><br><span class="line">Type: cpu</span><br><span class="line">Time: May 30, 2019 at 3:19pm (CST)</span><br><span class="line">Duration: 800.05ms, Total samples &#x3D; 690ms (86.25%)</span><br><span class="line">Showing nodes accounting for 690ms, 100% of 690ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     650ms 94.20% 94.20%      650ms 94.20%  github.com&#x2F;testcase.Benchmark</span><br><span class="line"></span><br><span class="line">      10ms  1.45% 95.65%       10ms  1.45%  runtime.findrunnable</span><br><span class="line">      10ms  1.45% 97.10%       10ms  1.45%  runtime.heapBitsSetType</span><br><span class="line">      10ms  1.45% 98.55%       10ms  1.45%  runtime.siftupTimer</span><br><span class="line">      10ms  1.45%   100%       10ms  1.45%  runtime&#x2F;pprof.(*profMap).lookup</span><br><span class="line">         0     0%   100%       20ms  2.90%  runtime.(*timersBucket).addtimerLocked</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.malg</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.mallocgc</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.mcall</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.newobject</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.newproc</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.newproc.func1</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.newproc1</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.park_m</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.schedule</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.systemstack</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime&#x2F;pprof.(*profileBuilder).addCPUData</span><br><span class="line">         0     0%   100%       30ms  4.35%  runtime&#x2F;pprof.profileWriter</span><br><span class="line">         0     0%   100%      650ms 94.20%  testing.(*B).launch</span><br><span class="line">         0     0%   100%      650ms 94.20%  testing.(*B).runN</span><br><span class="line">         0     0%   100%       20ms  2.90%  time.Sleep</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pprof交互模式分析"><a href="#pprof交互模式分析" class="headerlink" title="pprof交互模式分析"></a>pprof交互模式分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ src&gt; go tool pprof main_test.go cpu.out</span><br><span class="line">### 输出 ###</span><br><span class="line">main_test.go: parsing profile: unrecognized profile format</span><br><span class="line">Fetched 1 source profiles out of 2</span><br><span class="line">Type: cpu</span><br><span class="line">Time: May 30, 2019 at 3:19pm (CST)</span><br><span class="line">Duration: 800.05ms, Total samples &#x3D; 690ms (86.25%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 690ms, 100% of 690ms total</span><br><span class="line">Showing top 10 nodes out of 21</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     650ms 94.20% 94.20%      650ms 94.20%  github.com&#x2F;testcase.Benchmark</span><br><span class="line"></span><br><span class="line">      10ms  1.45% 95.65%       10ms  1.45%  runtime.findrunnable</span><br><span class="line">      10ms  1.45% 97.10%       10ms  1.45%  runtime.heapBitsSetType</span><br><span class="line">      10ms  1.45% 98.55%       10ms  1.45%  runtime.siftupTimer</span><br><span class="line">      10ms  1.45%   100%       10ms  1.45%  runtime&#x2F;pprof.(*profMap).lookup</span><br><span class="line">         0     0%   100%       20ms  2.90%  runtime.(*timersBucket).addtimerLocked</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.malg</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.mallocgc</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.mcall</span><br><span class="line">         0     0%   100%       10ms  1.45%  runtime.newobject</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>

<h3 id="代码生成测试数据文件"><a href="#代码生成测试数据文件" class="headerlink" title="代码生成测试数据文件"></a>代码生成测试数据文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;runtime&#x2F;pprof&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    w, _ :&#x3D; os.Create(&quot;cpu.out&quot;)</span><br><span class="line">    defer w.Close()</span><br><span class="line">    pprof.StartCPUProfile(w)</span><br><span class="line">    defer pprof.StopCPUProfile()</span><br><span class="line"></span><br><span class="line">    w2, _ :&#x3D; os.Create(&quot;mem.out&quot;)</span><br><span class="line">    defer w2.Close()</span><br><span class="line">    defer pprof.WriteHeapProfile(w2)</span><br><span class="line"></span><br><span class="line">    Add(3, 5)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行以上文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build main.go   </span><br><span class="line">.&#x2F;main  </span><br><span class="line">ls（.&#x2F;main命令生成cpu.out和mem.out文件）  </span><br><span class="line">cpu.out     mem.out     pprof       pprof.go  </span><br></pre></td></tr></table></figure>

<p>生成pdf文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go tool pprof -pdf cpu.out &gt; cpu.pdf  </span><br><span class="line">go tool pprof -pdf mem.out &gt; mem.pdf  </span><br></pre></td></tr></table></figure>

<h2 id="与CI集成"><a href="#与CI集成" class="headerlink" title="与CI集成"></a>与CI集成</h2><h3 id="go-junit-report"><a href="#go-junit-report" class="headerlink" title="go-junit-report"></a>go-junit-report</h3><p>类似java的junit，go test可以与go-junit-report工具结合生成junit报告，然后集成到jenkins中进行查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOPATH&#x3D;$(pwd)</span><br><span class="line">ut_modules&#x3D;&#96;go list src&#x2F;...&#96;</span><br><span class="line">go test -v $&#123;ut_modules[*&#125;&#125; 2 &gt;&amp;1 | go-junit-report &gt; go_junit.xml</span><br></pre></td></tr></table></figure>


<h3 id="gocover-cobertura"><a href="#gocover-cobertura" class="headerlink" title="gocover-cobertura"></a>gocover-cobertura</h3><p>也可以类似和cobertura进行集成,生成coverage.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOPATH&#x3D;$(pwd)</span><br><span class="line">ut_modules&#x3D;&#96;go list src&#x2F;...&#96;</span><br><span class="line">go test -coverprofile&#x3D;coverage.txt -covermode count $&#123;ut_modules[*&#125;&#125;</span><br><span class="line">gocover-cobertura &lt; coverage.txt &gt; coverage.xml</span><br></pre></td></tr></table></figure>

<h3 id="goreporter"><a href="#goreporter" class="headerlink" title="goreporter"></a>goreporter</h3><p>可以和goreporter集成，生成html格式的报告文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOPATH&#x3D;$(pwd)</span><br><span class="line">goreporter -p $&#123;projectRelativePath&#125;  -r $&#123;report_dir&#125; -f html</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>unit_test</tag>
        <tag>testing</tag>
      </tags>
  </entry>
  <entry>
    <title>Beego!</title>
    <url>/2019/07/30/golang/2019-07-30-beego/</url>
    <content><![CDATA[<a id="more"></a>

<p>Beego is an HTTP framework for rapid development of Go applications. It can be used to quickly develop applications such as APIs, Web and back-end services. It is a RESTful framework, mainly inspired by the three frameworks of tornado, sinatra and flask. But a framework designed to combine some of Go’s own features (interface, struct embedding, etc.).</p>
<h2 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h2><ul>
<li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）</li>
<li>CORS允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制</li>
<li>CORS与JSONP的使用目的相同，但是比JSONP更强大，JSONP只支持GET请求，CORS支持所有类型的HTTP请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</li>
</ul>
<h3 id="什么叫做跨域？"><a href="#什么叫做跨域？" class="headerlink" title="什么叫做跨域？"></a>什么叫做跨域？</h3><p>当两个域具有相同的协议(如http)，相同的端口(如80)，相同的host(如<code>www.github.com</code>),则认为它们是相同的域，否则就是跨域</p>
<h3 id="限制跨域访问的作用？"><a href="#限制跨域访问的作用？" class="headerlink" title="限制跨域访问的作用？"></a>限制跨域访问的作用？</h3><p>限制跨域资源访问的作用可以从服务端和客户端两个方面进行分析：  </p>
<ul>
<li>服务端<br>当服务端收到一个请求时，会检查该请求来源，如果来源的客户端页面自己无法识别，而且服务端的数据又是比较敏感的，则可能做出限制或者拒绝访问(例如黑客对服务器的攻击)</li>
<li>客户端<br>浏览器的同源策略可限制对跨域资源的访问，若是与服务器的域不相同，则浏览器可能进行限制甚至拒绝访问(例如，黑客通过让你访问他的服务器数据来攻击你的客户端页面)<br>跨域访问失败时，实际上浏览器发送请求成功，浏览器也接收到了响应，但是它会限制xmlhttprequest接受响应并在js控制台报错。  </li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过在响应中增加Access-Control-Allow-Origin标识的header，指定服务器端运行进行跨域资源访问的来源域<br>其中 Access-Control-Allow-Origin: * 表示该资源谁都可以用，在Beego框架中可以通过CORS显式定义支持跨域的功能，定义如下：     </p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">beego.InsertFilter(<span class="string">&quot;*&quot;</span>, beego.BeforeRouter, cors.Allow(&amp;cors.Options&#123;</span><br><span class="line">		AllowAllOrigins:  <span class="literal">true</span>,</span><br><span class="line">		AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">		AllowMethods:     []<span class="keyword">string</span>&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>&#125;,</span><br><span class="line">		AllowHeaders:     []<span class="keyword">string</span>&#123;<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;language-option&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>&#125;,</span><br><span class="line">		ExposeHeaders:    []<span class="keyword">string</span>&#123;<span class="string">&quot;*&quot;</span>&#125;,</span><br><span class="line">		MaxAge:           <span class="number">5</span> * time.Minute,</span><br><span class="line">	&#125;))</span><br></pre></td></tr></table></figure>


<h2 id="添加日志支持"><a href="#添加日志支持" class="headerlink" title="添加日志支持"></a>添加日志支持</h2><p>beego的日志可以通过配置文件app.conf中定义<br>定义格式如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Emergency:0, Alert:1, Critical:2, Error:3, Warn:4, Notice:5, Info:6, Debug:7</span><br><span class="line">LogOutputs &#x3D; console,&#123;&quot;level&quot;:7&#125;;file, &#123;&quot;filename&quot;:&quot;work&#x2F;logs&#x2F;prism.log&quot;,&quot;level&quot;:7,&quot;maxlines&quot;:30000,&quot;maxsize&quot;:20000000,&quot;daily&quot;:false,&quot;maxdays&quot;:10,&quot;rotate&quot;:true&#125;</span><br></pre></td></tr></table></figure>

<p><strong>work/logs目录需要手动创建，因为beego框架不会帮我们创建</strong></p>
<h2 id="从请求头中获取数据"><a href="#从请求头中获取数据" class="headerlink" title="从请求头中获取数据"></a>从请求头中获取数据</h2><p>A系统有UI和后端两个微服务，现A系统的后端需要访问B系统提供的REST服务，由于安全的考虑，访问B系统时，都需要在请求头部加上Token。<br>A系统在UI访问后端时可以通过HTTP头部将此Token传递过来，假设A系统的后端目前采取Beego框架实现，如何编写优雅的代码获取UI传递的Token？</p>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;github.com&#x2F;astaxie&#x2F;beego&quot;</span><br><span class="line"></span><br><span class="line">type MainController struct&#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MainController) Get()&#123;</span><br><span class="line">	token :&#x3D; this.Ctx.Request.Header.Get(consts.AcceptToken)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的实例，我们先要知道它干了什么： </p>
<ul>
<li>自定义了一个内含beego.Controller控制器的MainController。</li>
<li>重写了MainController的Get()方法，熟悉go语言的应该知道这个方法来自beego.Controller。</li>
<li>在Get()方法内部，通过Content从http请求头中获取token。</li>
</ul>
<h3 id="ControllerInterface接口"><a href="#ControllerInterface接口" class="headerlink" title="ControllerInterface接口"></a>ControllerInterface接口</h3><p>在介绍本文的重点之前，我们先来认识一下beego中定义的ControllerInterface接口  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type  ControllerInterface interface&#123;</span><br><span class="line">	Init(ctx *context.Context, controllerName, actionName string, app interface&#123;&#125;)</span><br><span class="line">	Prepare()</span><br><span class="line">	Get()</span><br><span class="line">	Post()</span><br><span class="line">	Delete()</span><br><span class="line">	Put()</span><br><span class="line">	Head()</span><br><span class="line">	Patch()</span><br><span class="line">	Options()</span><br><span class="line">	Finish()</span><br><span class="line">	Render() error</span><br><span class="line">	XSRFToken() string</span><br><span class="line">	CheckXSRFCookie() bool</span><br><span class="line">	HandlerFunc(fn string) bool</span><br><span class="line">	URLMapping()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这些接口的定义我们可以知道，它主要定义了Http请求过程中针对不同Method所作出的不同响应。而 beego.Controller 就是对这些接口的一个实现，对于其中方法的一些解释：</p>
<ul>
<li>Init(ct *context.Context, controllerName, actionName string, app interface{})<br>这个函数主要初始化了Context，相应Controller的名称，模板名，初始化模板参数的容器Data</li>
<li>Prepare()<br>这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些Method方法之前执行，用户可以重写这个函数实现类似用户验证之类。</li>
<li>Get()<br>如果用户请求的Http Method是Get，那么就执行该函数，默认是403，用户继承的子struct可以实现该方法，以处理Get请求</li>
<li>Finish()<br>这个函数是在执行完相关Http Method方法之后执行的，默认为空，用户可以在子Struct中重写这个函数，执行例如关闭数据库，清理数据之类的操作。</li>
</ul>
<h3 id="重写beego框架函数"><a href="#重写beego框架函数" class="headerlink" title="重写beego框架函数"></a>重写beego框架函数</h3><p>通过上文的介绍，我们可以知道，能够通过重写beego框架中定义函数的使用，快速便利实现自己各种业务处理。<br><strong>业务场景:</strong> A系统要和B系统进行通讯，每次都需要带上Token操作。<br><strong>解决手段:</strong> 针对这种情况，我们可以封装一个BaseController用来继承beego.Controller，重写Prepare()函数并从Http头部解析获取Token,而其他业务Controller都继承BaseController，那么每次就可以很方便的获取Token了。</p>
<p>具体实现代码如下：</p>
<ul>
<li>基础类：base.go</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;github.com&#x2F;astaxie&#x2F;beego&quot;</span><br><span class="line"></span><br><span class="line">type BaseController struct&#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">	Token string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(b *BaseController) Prepare()&#123;</span><br><span class="line">	b.Token &#x3D; b.Ctx.Request.Header.Get(consts.AcceptToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>业务类： main.go</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type MainController struct&#123;</span><br><span class="line">	BaseController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *BaseController) Get()&#123;</span><br><span class="line">	token :&#x3D; this.Token</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title>Monkey!</title>
    <url>/2019/11/07/golang/2019-11-07-monkey/</url>
    <content><![CDATA[<a id="more"></a>

<p>Monkey是Golang的一个猴子补丁（monkeypatching）框架，在运行时通过汇编语句重写可执行文件，将待打桩函数或方法的实现跳转到桩实现，原理和热补丁类似</p>
<p>通过Monkey，我们可以解决函数或方法的打桩问题，但Monkey不是线程安全的，不要将Monkey用于并发的测试中</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;bouk&#x2F;monkey</span><br></pre></td></tr></table></figure>
<p>运行完后你会发现，在$GOPATH/src/github.com目录下，新增了bouk/monkey子目录</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>目前有一个项目app，app的整体架构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GOPATH</span><br><span class="line">   |- src</span><br><span class="line">       |- app</span><br><span class="line">           |- vnpm.go</span><br><span class="line">           |- vnpm_test.go</span><br><span class="line">           |- swr.go</span><br><span class="line">           |- swr_test.go </span><br></pre></td></tr></table></figure>

<h3 id="为函数打桩"><a href="#为函数打桩" class="headerlink" title="为函数打桩"></a>为函数打桩</h3><p>目前有一个业务场景：我们需要通过vnpm查询所有服务信息，我们可以将通过http请求查询vnpm数据的地方打桩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*** 生产代码开始 ***&#x2F;</span><br><span class="line">package app</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;encoding&#x2F;json&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io&#x2F;ioutil&quot;</span><br><span class="line">	&quot;net&#x2F;http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type (</span><br><span class="line">	Srv struct &#123;</span><br><span class="line">		Name    string &#96;json:&quot;name&quot;&#96;</span><br><span class="line">		Version string &#96;json:&quot;version&quot;&#96;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Header map[string]string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http get请求的工具类</span><br><span class="line">func HTTPGet(url string, header Header) ([]byte, error) &#123;</span><br><span class="line">	request, err :&#x3D; http.NewRequest(http.MethodGet, url, nil)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if header !&#x3D; nil &amp;&amp; len(header) &gt; 0 &#123;</span><br><span class="line">		for k, v :&#x3D; range header &#123;</span><br><span class="line">			request.Header.Set(k, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err :&#x3D; http.DefaultClient.Do(request)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	buf, err :&#x3D; ioutil.ReadAll(resp.Body)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if resp.StatusCode &lt; http.StatusOK || resp.StatusCode &gt; http.StatusIMUsed &#123;</span><br><span class="line">		return buf, fmt.Errorf(&quot;%d %s&quot;, resp.StatusCode, resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	return buf, nil</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过http请求获取服务列表[]Srv</span><br><span class="line">func RequestVNPM(endpoint, token string) (srvs []Srv, err error) &#123;</span><br><span class="line">	url :&#x3D; fmt.Sprintf(&quot;https:&#x2F;&#x2F;%s&#x2F;vnpm&#x2F;tenants&#x2F;service&quot;, endpoint)</span><br><span class="line">	resp, err :&#x3D; HTTPGet(url, Header&#123;&quot;Access-Token&quot;: token&#125;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if err &#x3D; json.Unmarshal(resp, &amp;srvs); err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*** 生产代码结束 ***&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*** 测试代码开始 ***&#x2F;</span><br><span class="line">package app_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;app&quot;</span><br><span class="line">	&quot;encoding&#x2F;json&quot;</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;github.com&#x2F;bouk&#x2F;monkey&quot;</span><br><span class="line">	&quot;github.com&#x2F;smartystreets&#x2F;goconvey&#x2F;convey&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestRequestVNPM(t *testing.T) &#123;</span><br><span class="line">	convey.Convey(&quot;RequestVNPM&quot;, t, func() &#123;</span><br><span class="line">		convey.Convey(&quot;should be return error when http get failed&quot;, func() &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过monkey.Patch对函数进行打桩，模拟异常情况</span><br><span class="line">			patch :&#x3D; monkey.Patch(app.HTTPGet, func(url string, header app.Header) ([]byte, error) &#123;</span><br><span class="line">				return nil, errors.New(&quot;http get failed&quot;)</span><br><span class="line">			&#125;)</span><br><span class="line">			defer patch.Unpatch()</span><br><span class="line">			resp, err :&#x3D; app.RequestVNPM(&quot;1.2.3.4:80&quot;, &quot;token-1345&quot;)</span><br><span class="line">			convey.So(resp, convey.ShouldBeNil)</span><br><span class="line">			convey.So(err, convey.ShouldNotBeNil)</span><br><span class="line">			convey.So(err.Error(), convey.ShouldEqual, &quot;http get failed&quot;)</span><br><span class="line">		&#125;)</span><br><span class="line">		convey.Convey(&quot;should be success return when http get success&quot;, func() &#123;</span><br><span class="line">            &#x2F;&#x2F; 通过monkey.Patch对函数进行打桩，模拟正常情况</span><br><span class="line">			patch :&#x3D; monkey.Patch(app.HTTPGet, func(url string, header app.Header) ([]byte, error) &#123;</span><br><span class="line">				srvs :&#x3D; []app.Srv&#123;</span><br><span class="line">					&#123;Name: &quot;abc&quot;, Version: &quot;123&quot;&#125;,</span><br><span class="line">					&#123;Name: &quot;def&quot;, Version: &quot;mnt&quot;&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">				buf, _ :&#x3D; json.Marshal(srvs)</span><br><span class="line">				return buf, nil</span><br><span class="line">			&#125;)</span><br><span class="line">			defer patch.Unpatch()</span><br><span class="line">			resp, err :&#x3D; app.RequestVNPM(&quot;1.2.3.4:80&quot;, &quot;token-1345&quot;)</span><br><span class="line">			convey.So(err, convey.ShouldBeNil)</span><br><span class="line">			fmt.Println(resp)</span><br><span class="line">			convey.So(len(resp), convey.ShouldEqual, 2)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*** 测试代码结束 ***&#x2F;</span><br></pre></td></tr></table></figure>
<p>Patch是Monkey提供给用户用于函数打桩的API：</p>
<ul>
<li>第一个参数是目标函数的函数名</li>
<li>第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包</li>
<li>返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁</li>
</ul>
<h3 id="为方法打桩"><a href="#为方法打桩" class="headerlink" title="为方法打桩"></a>为方法打桩</h3><p>我们也可以对基于结构体struct的方法进行打桩，假设目前我们有一个请求，是从swr从查询所有的Bins，具体请看代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*** 生产代码开始 ***&#x2F;</span><br><span class="line">package app</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;encoding&#x2F;json&quot;</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;github.com&#x2F;tidwall&#x2F;gjson&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从swr中查询bins的结果如下</span><br><span class="line">type BinResponse struct &#123;</span><br><span class="line">	List []struct &#123;</span><br><span class="line">		Name string &#96;json:&quot;name&quot;&#96;</span><br><span class="line">		VERs []struct &#123;</span><br><span class="line">			Ver string   &#96;json:&quot;version&quot;&#96;</span><br><span class="line">			Uri []string &#96;json:&quot;uri&quot;&#96;</span><br><span class="line">		&#125; &#96;json:&quot;versions&quot;&#96;</span><br><span class="line">	&#125; &#96;json:&quot;list&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对结果进行序列化</span><br><span class="line">func (b *BinResponse) String() string &#123;</span><br><span class="line">	str, _ :&#x3D; json.Marshal(b)</span><br><span class="line">	return string(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过调用请求至swr，获取bins结果BinResp</span><br><span class="line">func (b *BinResponse) InitFromHttpResp(endpoint, tenantID, binName, token string) (*BinResponse, error) &#123;</span><br><span class="line">	url :&#x3D; fmt.Sprintf(&quot;%s&#x2F;swr&#x2F;v1&#x2F;tenants&#x2F;%s&#x2F;bins?name&#x3D;%s&amp;reponame&#x3D;%s&quot;, endpoint, tenantID, binName, tenantID)</span><br><span class="line">	resp, err :&#x3D; HTTPGet(url, Header&#123;&quot;Access-Token&quot;: token&#125;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if exist :&#x3D; gjson.Get(string(resp), &quot;list.#[name&#x3D;&quot;+binName+&quot;]#.versions&quot;); !exist.Exists() &#123;</span><br><span class="line">		return nil, errors.New(&quot;no matched binName&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if err &#x3D; json.Unmarshal(resp, &amp;b); err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return b, nil</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*** 生产代码结束 ***&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*** 测试代码开始 ***&#x2F;</span><br><span class="line">package app_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;app&quot;</span><br><span class="line">	&quot;encoding&#x2F;json&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;github.com&#x2F;bouk&#x2F;monkey&quot;</span><br><span class="line">	&quot;github.com&#x2F;smartystreets&#x2F;goconvey&#x2F;convey&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestBinResponse_InitFromHttpResp(t *testing.T) &#123;</span><br><span class="line">	convey.Convey(&quot;TestBinResponse&quot;, t, func() &#123;</span><br><span class="line">		convey.Convey(&quot;response success&quot;, func() &#123;</span><br><span class="line">            &#x2F;&#x2F; 对BinResponse的方法InitFromHttpResp进行打桩</span><br><span class="line">			var binResp *app.BinResponse</span><br><span class="line">			guard :&#x3D; monkey.PatchInstanceMethod(reflect.TypeOf(binResp), &quot;InitFromHttpResp&quot;,</span><br><span class="line">				func(b *app.BinResponse, endpoint, tenantID, binName, token string) (*app.BinResponse, error) &#123;</span><br><span class="line">					var resp *app.BinResponse</span><br><span class="line">					jsonStr :&#x3D; &#96;&#123;</span><br><span class="line">    &quot;list&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;:&quot;abc&quot;,</span><br><span class="line">            &quot;versions&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;version&quot;:&quot;123&quot;,</span><br><span class="line">                    &quot;uri&quot;:[&quot;&#x2F;abc&#x2F;123&quot;]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;version&quot;:&quot;456&quot;,</span><br><span class="line">                    &quot;uri&quot;:[&quot;&#x2F;abc&#x2F;456&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;&#96;</span><br><span class="line">					_ &#x3D; json.Unmarshal([]byte(jsonStr), &amp;resp)</span><br><span class="line">					return resp, nil</span><br><span class="line">				&#125;)</span><br><span class="line">			defer guard.Unpatch()</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; 模拟调用</span><br><span class="line">			binResp, err :&#x3D; new(app.BinResponse).InitFromHttpResp(&quot;1.2.3.4:80&quot;, &quot;ranoss&quot;, &quot;abc&quot;, &quot;token----&quot;)</span><br><span class="line">            &#x2F;&#x2F; 结果校验</span><br><span class="line">			convey.So(err, convey.ShouldBeNil)</span><br><span class="line">			fmt.Println(binResp)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*** 测试代码结束 ***&#x2F;</span><br></pre></td></tr></table></figure>
<p>PatchInstanceMethod API是Monkey提供给用户用于方法打桩的API：</p>
<ul>
<li>在使用前，先要定义一个目标类的指针变量x</li>
<li>第一个参数是reflect.TypeOf(x)</li>
<li>第二个参数是字符串形式的函数名</li>
<li>返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁</li>
</ul>
]]></content>
      <tags>
        <tag>unit_test</tag>
        <tag>monkey</tag>
      </tags>
  </entry>
  <entry>
    <title>GoConvey!</title>
    <url>/2019/11/08/golang/2019-11-08-goconvey/</url>
    <content><![CDATA[<a id="more"></a>

<p>GoConvey是Golang的测试框架，它提供了丰富的断言，支持web界面，能够与Golang自带的单元测试框架无缝集成，可以让程序员简洁优雅的编写测试代码</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;smartystreets&#x2F;goconvey  </span><br></pre></td></tr></table></figure>
<p>运行成功后，你会发现：</p>
<ul>
<li>$GOPATH/src目录下新增github.com/smartystreets/goconvey框架源代码</li>
<li>$GOPATH/bin目录下新增可执行程序 goconvey</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>我们通过一个案例来介绍GoConvey使用方法，下面是一个能够实现整数基本四则运算(加、减、乘、除)的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cal</span><br><span class="line"></span><br><span class="line">import &quot;errors&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func Subtract(a, b int) int &#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func Multiply(a, b int) int &#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func Division(a, b int) (int, error) &#123;</span><br><span class="line">    if b &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        return 0, errors.New(&quot;被除数不能为 0&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return a &#x2F; b, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cal</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">    . &quot;github.com&#x2F;smartystreets&#x2F;goconvey&#x2F;convey&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    Convey(&quot;将两数相加&quot;, t, func() &#123;</span><br><span class="line">        So(Add(1, 2), ShouldEqual, 3)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func TestSubtract(t *testing.T) &#123;</span><br><span class="line">    Convey(&quot;将两数相减&quot;, t, func() &#123;</span><br><span class="line">        So(Subtract(1, 2), ShouldEqual, -1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func TestMultiply(t *testing.T) &#123;</span><br><span class="line">    Convey(&quot;将两数相乘&quot;, t, func() &#123;</span><br><span class="line">        So(Multiply(3, 2), ShouldEqual, 6)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func TestDivision(t *testing.T) &#123;</span><br><span class="line">    Convey(&quot;将两数相除&quot;, t, func() &#123;</span><br><span class="line"> </span><br><span class="line">        Convey(&quot;除以非 0 数&quot;, func() &#123;</span><br><span class="line">            num, err :&#x3D; Division(10, 2)</span><br><span class="line">            So(err, ShouldBeNil)</span><br><span class="line">            So(num, ShouldEqual, 5)</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">        Convey(&quot;除以 0&quot;, func() &#123;</span><br><span class="line">            _, err :&#x3D; Division(10, 0)</span><br><span class="line">            So(err, ShouldNotBeNil)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>import goconvey包时，前面加点号”.”，以减少冗余的代码</li>
<li>使用 GoConvey 书写单元测试，每个测试用例需要使用 Convey 函数包裹起来。它接受的第一个参数为 string 类型的描述；第二个参数一般为 *testing.T，即本例中的变量 t；第三个参数为不接收任何参数也不返回任何值的函数（习惯以闭包的形式书写</li>
<li>Convey 语句同样可以无限嵌套，以体现各个测试用例之间的关系，例如 TestDivision 函数就采用了嵌套的方式体现它们之间的关系。需要注意的是，只有最外层的 Convey 需要传入变量 t，内层的嵌套均不需要传入</li>
<li>最后，需要使用 So 语句来对条件进行判断</li>
</ul>
<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@qgd:~&#x2F;qgd&#x2F;projects&#x2F;src&#x2F;gitlab.zte.com.cn&#x2F;10172605&#x2F;gonote&#x2F;src&#x2F;calculator# go test -v </span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAddConvey</span><br><span class="line"></span><br><span class="line">  将两数相加 ✔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 total assertion</span><br><span class="line"></span><br><span class="line">--- PASS: TestAddConvey (0.00s)</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSubtract</span><br><span class="line"></span><br><span class="line">  将两数相减 ✔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2 total assertions</span><br><span class="line"></span><br><span class="line">--- PASS: TestSubtract (0.00s)</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestMultiply</span><br><span class="line"></span><br><span class="line">  将两数相乘 ✔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 total assertions</span><br><span class="line"></span><br><span class="line">--- PASS: TestMultiply (0.00s)</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDivision</span><br><span class="line"></span><br><span class="line">  将两数相除 </span><br><span class="line">    除以非 0 数 ✔✔</span><br><span class="line">    除以 0 ✔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6 total assertions</span><br><span class="line"></span><br><span class="line">--- PASS: TestDivision (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      calculator      0.013s</span><br></pre></td></tr></table></figure>

<h2 id="Web-界面"><a href="#Web-界面" class="headerlink" title="Web 界面"></a>Web 界面</h2><p>想要使用 GoConvey 的 Web 界面特性，需要在相应目录下执行 goconvey（需使用go get安装到$GOPATH/bin目录下），然后打开浏览器，访问 <a href="http://localhost:8080/">http://localhost:8080</a> ，就可以看到界面</p>
]]></content>
      <tags>
        <tag>unit_test</tag>
        <tag>goconvey</tag>
      </tags>
  </entry>
  <entry>
    <title>GoMock!</title>
    <url>/2019/11/08/golang/2019-11-08-gomock/</url>
    <content><![CDATA[<a id="more"></a>

<p>GoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的testing包良好集成，也能用于其它的测试环境中<br>GoMock测试框架包含了GoMock包和mockgen工具两部分，其中GoMock包完成对桩对象生命周期的管理，mockgen工具用来生成interface对应的Mock类源文件</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在命令行运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;golang&#x2F;mock&#x2F;gomock</span><br></pre></td></tr></table></figure>
<p>运行完后你会发现，在$GOPATH/src目录下有了github.com/golang/mock子目录，且在该子目录下有GoMock包和mockgen工具</p>
<p>继续运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $GOPATH&#x2F;src&#x2F;github.com&#x2F;golang&#x2F;mock&#x2F;mockgen</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>
<p>则在当前目录下生成了一个可执行程序mockgen,将mockgen程序移动到$GOPATH/bin目录下</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="测试用例编写步骤"><a href="#测试用例编写步骤" class="headerlink" title="测试用例编写步骤"></a>测试用例编写步骤</h2><ul>
<li>想清楚整体逻辑</li>
<li>定义想要（模拟）依赖项的 interface（接口）</li>
<li>使用 mockgen 命令对所需 mock 的 interface 生成 mock 文件</li>
<li>编写单元测试的逻辑，在测试中使用 mock</li>
<li>进行单元测试的验证</li>
</ul>
<h2 id="定义依赖的接口Repository"><a href="#定义依赖的接口Repository" class="headerlink" title="定义依赖的接口Repository"></a>定义依赖的接口Repository</h2><p>假设我们定义一个接口Repository,Repository是领域驱动设计中战术设计的一个元素，用来存储领域对象，一般将对象持久化在数据库中，比如Aerospike，Redis或Etcd等。对于领域层来说，只知道对象在Repository中维护，并不care对象到底在哪持久化，这是基础设施层的职责。微服务在启动时，根据部署参数实例化Repository接口，比如AerospikeRepository，RedisRepository或EtcdRepository。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package db</span><br><span class="line"></span><br><span class="line">type Repository interface &#123;</span><br><span class="line">	Create(key string, value []byte) error</span><br><span class="line">	Get(key string) ([]byte, error)</span><br><span class="line">	Update(key string, value []byte) error</span><br><span class="line">	Delete(key string) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="生成mock类文件"><a href="#生成mock类文件" class="headerlink" title="生成mock类文件"></a>生成mock类文件</h2><p>回到项目目录shop下，我们执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GOPATH&#x2F;bin&#x2F;mockgen -source&#x3D;.&#x2F;db&#x2F;repo.go -destination&#x3D;.&#x2F;mock&#x2F;repo_mock.go -package&#x3D;mock</span><br></pre></td></tr></table></figure>
<p>执行完毕之后，我们会发现在当前目录下多了一个mock目录，并在该目录下发现多了一个repo_mock.go文件，这个就是mock文件</p>
<ul>
<li>source: 设置需要模拟(mock)的接口文件 </li>
<li>destination: 设置 mock 文件输出的地方，若不设置则打印到标准输出中</li>
<li>package： 设置 mock 文件的包名，若不设置则为 mock_ 前缀加上文件名（如本文的包名会为 mock_repo）</li>
</ul>
<p>在<code>mockgen</code>命令中，支持两种生成模式:</p>
<ul>
<li>source: 从源文件生成mock接口(通过-source启用)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockgen -source&#x3D;foo.go [other options]</span><br></pre></td></tr></table></figure></li>
<li>reflect: 通过使用反射程序生成mock接口，它通过传递两个非标志参数来启用：导入路径和逗号分割的接口列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockgen database&#x2F;sql&#x2F;Driver Conn,Driver</span><br></pre></td></tr></table></figure>
<code>PS: 从本质上讲，两种方式生成的mock代码没有区别，因此选择合适的就可以了</code></li>
</ul>
<h2 id="service层调用repo进行入库操作"><a href="#service层调用repo进行入库操作" class="headerlink" title="service层调用repo进行入库操作"></a>service层调用repo进行入库操作</h2><p>当我们的srv层有代码对repo层进行调用入库时，<code>srv/repo_srv.go</code>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package srv</span><br><span class="line"></span><br><span class="line">import &quot;shop&#x2F;db&quot;</span><br><span class="line"></span><br><span class="line">type RepoService struct &#123;</span><br><span class="line">	repo db.Repository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewRepoService(repo db.Repository) *RepoService &#123;</span><br><span class="line">	return &amp;RepoService&#123;</span><br><span class="line">		repo: repo,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *RepoService) Create(key string, value []byte) error &#123;</span><br><span class="line">	return r.repo.Create(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="针对service层代码我们编写测试代码"><a href="#针对service层代码我们编写测试代码" class="headerlink" title="针对service层代码我们编写测试代码"></a>针对service层代码我们编写测试代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package srv</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;db&#x2F;mock&quot;</span><br><span class="line">	&quot;github.com&#x2F;golang&#x2F;mock&#x2F;gomock&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestRepository_Create(t *testing.T) &#123;</span><br><span class="line">	ctl :&#x3D; gomock.NewController(t)</span><br><span class="line">	defer ctl.Finish()</span><br><span class="line"></span><br><span class="line">	mockRepo :&#x3D; mock.NewMockRepository(ctl)</span><br><span class="line"></span><br><span class="line">	mockRepo.EXPECT().Create(gomock.Any(), gomock.Any()).Return(nil)</span><br><span class="line"></span><br><span class="line">	repoSrv :&#x3D; NewRepoService(mockRepo)</span><br><span class="line">	err :&#x3D; repoSrv.Create(&quot;abc&quot;, []byte(&quot;abc&quot;))</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		t.Errorf(&quot;repo.Create error: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后代码结构"><a href="#最后代码结构" class="headerlink" title="最后代码结构"></a>最后代码结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GOPATH</span><br><span class="line">  |- src</span><br><span class="line">      |- shop</span><br><span class="line">           |- db</span><br><span class="line">               |- repo.go</span><br><span class="line">           |- mock</span><br><span class="line">               |- repo_mock.go</span><br><span class="line">           |- srv</span><br><span class="line">               |- repo_srv.go</span><br><span class="line">               |- repo_srv_test.go</span><br></pre></td></tr></table></figure>

<h2 id="gomock详细解析"><a href="#gomock详细解析" class="headerlink" title="gomock详细解析"></a>gomock详细解析</h2><ol>
<li>gomock.NewController：返回 gomock.Controller，它代表 mock 生态系统中的顶级控件。定义了 mock 对象的范围、生命周期和期待值。另外它在多个goroutine中是安全的</li>
<li>ctl.Finish()：当用例结束后，控制器会检查所有剩余期望的调用是否满足条件，一般会使用 defer 延迟执行，以防止我们忘记这一操作</li>
<li>mock.NewMockRepository(ctl)：创建一个新的mock实例</li>
<li>mockRepo.EXPECT().Create(gomock.Any(), gomock.Any()).Return(nil)：这里有三个步骤，EXPECT()返回一个允许调用者设置期望和返回值的对象。Create(gomock.Any(), gomock.Any()) 是设置入参并调用 mock 实例中的方法。Return(nil) 是设置先前调用的方法出参。简单来说，就是设置入参并调用，最后设置返回值</li>
<li>NewRepoService(mockRepo)：创建RepoService实例，值得注意的是，在这里注入了mock对象，因此实际在随后的 repo.Create(key,value)调用（入参：key为”abc”,value为[]byte(“abc”）中。它调用的是我们事先模拟好的 mock 方法</li>
</ol>
]]></content>
      <tags>
        <tag>unit_test</tag>
        <tag>gomock</tag>
      </tags>
  </entry>
  <entry>
    <title>GoStub!</title>
    <url>/2019/11/08/golang/2019-11-08-gostub/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;prashantv&#x2F;gostub</span><br></pre></td></tr></table></figure>

<h2 id="gostub用法"><a href="#gostub用法" class="headerlink" title="gostub用法"></a>gostub用法</h2><h3 id="为全局变量进行打桩"><a href="#为全局变量进行打桩" class="headerlink" title="为全局变量进行打桩"></a>为全局变量进行打桩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var configFile &#x3D; &quot;config.json&quot;</span><br><span class="line"></span><br><span class="line">func GetConfig() ([]byte, error) &#123;</span><br><span class="line">    return ioutil.ReadFile(configFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Test code</span><br><span class="line">stubs :&#x3D; gostub.Stub(&amp;configFile, &quot;&#x2F;tmp&#x2F;test.config&quot;)</span><br><span class="line"></span><br><span class="line">data, err :&#x3D; GetConfig()</span><br><span class="line">&#x2F;&#x2F; data will now return contents of the &#x2F;tmp&#x2F;test.config file</span><br></pre></td></tr></table></figure>
<ul>
<li>本例中对变量configFile进行打桩，替换了原来的值</li>
<li>调用GetConfig返回的结果用自己替换的文件替代了</li>
</ul>
<h3 id="为函数进行打桩"><a href="#为函数进行打桩" class="headerlink" title="为函数进行打桩"></a>为函数进行打桩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timeNow &#x3D; time.Now</span><br><span class="line"></span><br><span class="line">func GetDate() int &#123;</span><br><span class="line">    return timeNow().Day()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Test code</span><br><span class="line">stubs :&#x3D; gostub.Stub(&amp;timeNow, func() time.Time &#123;</span><br><span class="line">    return time.Date(2015, 6, 1, 0, 0, 0, 0, time.UTC)</span><br><span class="line">&#125;)</span><br><span class="line">defer stubs.Reset()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Test can check that GetDate returns 6</span><br></pre></td></tr></table></figure>

<p><strong>对于非变量定义出的函数，我们需要进行一些修改，以适配为函数进行打桩的方式</strong></p>
<p>假设工程中自定义函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Exec(cmd string, args ...string) (string, error) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exec函数是不能通过GoStub框架打桩的。如果想要通过GoStub框架对Exec函数进行打桩，则仅需对自定义函数进行简单的重构，即将Exec函数定义为匿名函数，同时将其赋值给Exec变量，重构后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Exec &#x3D; func(cmd string, args ...string) (string, error) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Exec函数重构成Exec变量后，并不影响既有代码中对Exec函数的调用。由于Exec变量是函数变量，因此一般函数变量也叫做函数。对Exec函数变量进行打桩的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stubs :&#x3D; Stub(&amp;Exec, func(cmd string, args ...string) (string, error) &#123;</span><br><span class="line">   return &quot;test&quot;, nil</span><br><span class="line">&#125;)</span><br><span class="line">defer stubs.Reset()</span><br></pre></td></tr></table></figure>
<p>GoStub框架专门提供了StubFunc函数用于函数打桩，对于函数的打桩代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stubs :&#x3D; StubFunc(&amp;Exec,&quot;test&quot;, nil)</span><br><span class="line">defer stubs.Reset()</span><br></pre></td></tr></table></figure>

<p><strong>工程代码中会调用Golang库函数或第三方库函数，由于不能重构库函数，因此需要在工程代码中增加一层适配层，在适配层中定义库函数的变量，然后在工程代码中使用函数变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">Marshal &#x3D; json.Marshal</span><br><span class="line">Unmarshal &#x3D; json.Unmarshal</span><br></pre></td></tr></table></figure>

<h2 id="对环境变量值进行打桩"><a href="#对环境变量值进行打桩" class="headerlink" title="对环境变量值进行打桩"></a>对环境变量值进行打桩</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stubs :&#x3D; gostub.New()</span><br><span class="line">stubs.SetEnv(&quot;GOSTUB_VAR&quot;, &quot;test_value&quot;)</span><br><span class="line">defer stubs.Reset()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>unit_test</tag>
        <tag>gostub</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux new and add Swap partition!</title>
    <url>/2019/04/12/linux/2019-04-12-linux-add-swap-area/</url>
    <content><![CDATA[<a id="more"></a>

<p><strong>文章转载自 <a href="https://www.cnblogs.com/wuxie1989/p/5888595.html">https://www.cnblogs.com/wuxie1989/p/5888595.html</a></strong>    </p>
<p> 我们都知道在安装Linux系统时在分区时可以分配swap分区，而系统安装后（在运行中）如何建立或调整swap分区呢？    </p>
<p> 在装完Linux系统之后，建立Swap分区有两种方法。    </p>
<ul>
<li><p>1.新建磁盘分区作为swap分区    </p>
</li>
<li><p>2.用文件作为swap分区 （操作更简单，我更常用）    </p>
<p>下面介绍这两种方法：（都必须用root权限，操作过程应该小心谨慎。）    </p>
<h1 id="方法一：新建磁盘分区作为swap分区"><a href="#方法一：新建磁盘分区作为swap分区" class="headerlink" title="方法一：新建磁盘分区作为swap分区"></a>方法一：新建磁盘分区作为swap分区</h1><p>1.以root身份进入控制台（登录系统），输入    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a #停止所有的swap分区    </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>用fdisk命令（例：# fdisk /dev/sdb）对磁盘进行分区，添加swap分区，新建分区，在fdisk中用“t”命令将新添的分区id改为82（Linux swap类型），最后用w将操作实际写入硬盘（没用w之前的操作是无效的）。    </p>
</li>
<li><p>mkswap /dev/sdb2 #格式化swap分区，这里的sdb2要看您加完后p命令显示的实际分区设备名    </p>
</li>
<li><p>swapon /dev/sdb2 #启动新的swap分区    </p>
</li>
<li><p>为了让系统启动时能自动启用这个交换分区，可以编辑/etc/fstab,加入下面一行    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdb2 swap swap defaults 0 0    </span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="方法二：用文件作为Swap分区"><a href="#方法二：用文件作为Swap分区" class="headerlink" title="方法二：用文件作为Swap分区"></a>方法二：用文件作为Swap分区</h1><p>1.创建要作为swap分区的文件:增加1GB大小的交换分区，则命令写法如下，其中的count等于想要的块的数量（bs*count=文件大小）。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;root&#x2F;swapfile bs&#x3D;1M count&#x3D;1024    </span><br></pre></td></tr></table></figure>

<p>2.格式化为交换分区文件:    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkswap &#x2F;root&#x2F;swapfile #建立swap的文件系统    </span><br></pre></td></tr></table></figure>

<p>3.启用交换分区文件:    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapon &#x2F;root&#x2F;swapfile #启用swap文件    </span><br></pre></td></tr></table></figure>

<p>4.使系统开机时自启用，在文件/etc/fstab中添加一行：    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;root&#x2F;swapfile swap swap defaults 0 0    </span><br></pre></td></tr></table></figure>

<p> <strong>总结：</strong>    </p>
<ul>
<li>新建和增加交换分区用到的命令为：mkswap、swapon等    </li>
<li>关闭掉某个交换分区则用“swapoff /dev/sdb2”这样的命令</li>
</ul>
]]></content>
      <tags>
        <tag>linux_swap</tag>
      </tags>
  </entry>
  <entry>
    <title>unzip error:symlink error:File name too long!</title>
    <url>/2019/04/12/linux/2019-04-12-unzip-broken-with-symlink-error/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>从github上下载了kubernetes源码的压缩包kubernetes-master.zip，将其放到linux环境上进行解压，解压过程中出现symlink error: File name too long</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>通过对出错文件的分析，事实上这些文件本来可能就是一个文本文件，现在变成了一个符号链接文件，文件名指向的“文件”就是文件内容本身，所以才会有文件名过长的错误报出。<br>网上搜了一下，说是Linux下的unzip的一个bug：在OSX上解压,OSX的HFS+文件系统是不区分大小写的,而linux文件系统是区分大小写的，这就会造成文件Fuck.TXT会被fuck.txt覆盖的悲惨命运。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><code>网上有人分析出问题出在unzip身上，并且给出了unzip 6.0版本的补丁patch，并且通知了info-zip，很不幸，unzip 6.0版本自从2009年4月20号发布以来，再未更新过。http://www.info-zip.org/UnZip.html</code></p>
<h2 id="解决方法一：搞到unzip6-0的源码，打上补丁，重新编译"><a href="#解决方法一：搞到unzip6-0的源码，打上补丁，重新编译" class="headerlink" title="解决方法一：搞到unzip6.0的源码，打上补丁，重新编译"></a>解决方法一：搞到unzip6.0的源码，打上补丁，重新编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- a&#x2F;process.c    2014-07-11 18:02:34.671611514 +0800</span><br><span class="line">+++ b&#x2F;process.c    2014-07-11 18:03:09.639609859 +0800</span><br><span class="line">@@ -1751,6 +1751,12 @@</span><br><span class="line">         &#x3D; (G.crec.general_purpose_bit_flag &amp; (1 &lt;&lt; 11)) &#x3D;&#x3D; (1 &lt;&lt; 11);</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line">+#ifdef SYMLINKS </span><br><span class="line">+    &#x2F;* Initialize the symlink flag, may be set by the platform-specific </span><br><span class="line">+       mapattr function.  *&#x2F; </span><br><span class="line">+    G.pInfo-&gt;symlink &#x3D; 0; </span><br><span class="line">+#endif </span><br><span class="line">+</span><br><span class="line">     return PK_COOL;</span><br><span class="line"></span><br><span class="line"> &#125; &#x2F;* end function process_cdir_file_hdr() *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="解决方法二：使用替代软件"><a href="#解决方法二：使用替代软件" class="headerlink" title="解决方法二：使用替代软件"></a>解决方法二：使用替代软件</h2><p>Linux下可以使用p7zip,ubuntu下的安装过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install p7zip-full</span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7za x archive.zip</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux_unzip</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to my blogger!</title>
    <url>/2018/07/22/mood/2018-07-22-welcome/</url>
    <content><![CDATA[<a id="more"></a>

<p>时光荏苒，转眼六年时间过去了。刚工作的时候我给自己的计划之中有一项就是搞一个自己的网站，没想到拖了这么久，一直没有耐心好好研究一下怎么做。偶然之时，突然看到jekyll可以将Markdown直接转化成博客。经过我一两天的模仿学习，网站在今天终于正式上线啦。</p>
<p>我建站的目的很简单，就是发表一些自己的所见所得，学习心得，读书笔记等等。不仅可以对自己的学习过程做一个简单的总结，还能锻炼一下自己的写作能力。</p>
<p>期待与你相遇，一同成长前行！</p>
]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Print python function name with decorator!</title>
    <url>/2019/07/15/python/2019-07-15-decorate/</url>
    <content><![CDATA[<a id="more"></a>

<p>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>有一个打开文件进行读写操作的类FileManager，现在想要给其每一个执行的方法都加上打印方法名，以及方法执行时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s -%(name)s -%(levelname)s -%(message)s&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_method_name</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start_time = datetime.datetime.now()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = datetime.datetime.now()</span><br><span class="line">        logger.info(</span><br><span class="line">            <span class="string">&quot;---call function=&#123;func&#125;, escaped=&#123;escaped&#125;ms---&quot;</span>.<span class="built_in">format</span>(func=func.__name__,</span><br><span class="line">                                                                     escaped=(</span><br><span class="line">                                                                             end_time - start_time).microseconds)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileManager</span>:</span></span><br><span class="line"><span class="meta">    @print_method_name</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, mode</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @print_method_name</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.file = <span class="built_in">open</span>(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @print_method_name</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">        logger.info(<span class="string">&quot;exec_type=&#123;&#125;,exc_val=&#123;&#125;, exc_tb=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(exc_type, exc_val, exc_tb))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @print_method_name</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">business</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.file.write(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> FileManager(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> fm:</span><br><span class="line">    fm.business()</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://segmentfault.com/a/1190000012315090">https://segmentfault.com/a/1190000012315090</a></li>
</ul>
]]></content>
      <tags>
        <tag>decorators</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>with as usage in python!</title>
    <url>/2019/07/15/python/2019-07-15-with-as/</url>
    <content><![CDATA[<a id="more"></a>

<p>有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python的with语句提供了一种非常方便的处理方式。<br>一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。</p>
<h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h1><p>当我们进行文件处理时，需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。<br>要正确的处理涉及到的异常资源管理时，在2.6版本之前，需要使用try/finally代码结构，实现如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">		print(line)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="keyword">if</span> f <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		f.close()	</span><br></pre></td></tr></table></figure>

<p>这种清理方式不够优雅，python设计者们希望这种清理工作不要暴露给使用者，with语句并由此产生了。<br>with语句基本语法结构如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with expression [as variable]:</span><br><span class="line">	with-block</span><br></pre></td></tr></table></figure>

<p>使用with语句重写上面的读取文件操作，如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;abc.txt&quot;) as f:</span><br><span class="line">	for line in f.readlines():</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure>


<h2 id="with语句执行过程"><a href="#with语句执行过程" class="headerlink" title="with语句执行过程"></a>with语句执行过程</h2><p>with语句的expression是上下文管理器，with语句的[as variable]可选，上下文管理器实现了__enter__和__exit__两个函数。</p>
<ul>
<li>首先生成一个上下文管理器expression，上面的读文件例子中生成了上下文管理器<code>open(&quot;abc.txt&quot;)</code></li>
<li>然后执行expression.<strong>enter</strong>()，如果指定了as variable，那个<strong>enter</strong>()返回值赋给variable</li>
<li>执行with-block语句块</li>
<li>执行expression.<strong>exit</strong>(),在<strong>exit</strong>()函数中可以进行资源清理工作</li>
</ul>
<p>with语句不仅可以管理文件，还可以管理锁、连接等等  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock &#x3D; threading.lock()</span><br><span class="line">with lock:</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>

<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>with语句简单但强大，主要依赖上下文管理器。<br>上下文管理器是实现了上下文协议的类，上下文协议就是要实现<strong>enter</strong>()和<strong>exit</strong>()的两个方法。  </p>
<ul>
<li><strong>enter</strong>(): 主要执行一些环境准备工作，同时返回资源对象， 例如上文管理器open(“abc.txt”)的<strong>enter</strong>()返回一个文件对象。</li>
<li><strong>exit</strong>(): 完整形式为<strong>exit</strong>(type, value, traceback),三个参数和调用sys.exec_info()函数返回值一致，分为异常类型、异常信息和堆栈。<ul>
<li>如果执行体语句没有引发异常，那么三个参数均被设置为None，否则他们将包含上下文异常信息。  </li>
<li><strong>exit</strong>()方法返回True或者False，分别指示被引发的异常有没有被处理。</li>
<li>如果返回False，则表示引发的异常将会被传递出上下文。</li>
<li>如果<strong>exit</strong>()函数内部引发了异常，则会覆盖掉执行体中引发的异常。</li>
<li>处理异常时，不需要重新抛出异常，只需要返回False，with语句会检测<strong>exit</strong>()返回False来处理异常。</li>
</ul>
</li>
</ul>
<p>针对上下文管理，我们可以编写一个例子来说明该问题：<br>DBConnection需要提供一项功能： <strong>enter</strong>()要返回一个连接的cursor， 当没有异常发生时，<strong>exit</strong>()函数commit所有的数据库操作，如果有异常发生，则回滚数据库，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def DBConnection(object):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		pass</span><br><span class="line">	</span><br><span class="line">	def cursor(self):</span><br><span class="line">		print(&#39;start cursor, return transaction&#39;)</span><br><span class="line">	</span><br><span class="line">	def commit(self):</span><br><span class="line">		print(&#39;commit current transaction&#39;)</span><br><span class="line">	</span><br><span class="line">	def rollback(self):</span><br><span class="line">		print(&#39;rollback current transaction&#39;)</span><br><span class="line">		</span><br><span class="line">	def execute(self, sql):</span><br><span class="line">		print(&#39;execute sql segment&#39;)</span><br><span class="line">		</span><br><span class="line">	def __enter__(self):</span><br><span class="line">		return self.cursor()</span><br><span class="line">		</span><br><span class="line">	def __exit__(self, type, value, traceback):</span><br><span class="line">		if traceback is None:</span><br><span class="line">			self.commit()</span><br><span class="line">		</span><br><span class="line">		else: </span><br><span class="line">			self.rollback()</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">with DBConnection() as cursor:</span><br><span class="line">	cursor.execute(sql)</span><br><span class="line">	cursor.execute(sql)</span><br><span class="line">	cursor.execute(sql)	</span><br></pre></td></tr></table></figure>

<h1 id="contextlib模块"><a href="#contextlib模块" class="headerlink" title="contextlib模块"></a>contextlib模块</h1><p>自定义的上下文管理器，需要实现__enter__和__exit__两个方法，显然不是很方便。<br>python的contextlib模块提供了一个更方便的自定义管理器,可以利用装饰器contextmanager和一些辅助函数代替自定义的管理器，用法如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def generator_func(&lt;arguments&gt;):</span><br><span class="line">	&lt;setup&gt;</span><br><span class="line">	try:</span><br><span class="line">		yield &lt;value&gt;</span><br><span class="line">	finally:</span><br><span class="line">		&lt;clearup&gt;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用with语句调用contextmanager生成上下文管理器了， 语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with generator_func(&lt;arguments&gt;) as &lt;variable&gt;:</span><br><span class="line">	&lt;body&gt;</span><br></pre></td></tr></table></figure>
<p>生成器函数generator_func和普通函数一样，原理如下：  </p>
<ul>
<li>generator_func函数在yield之前的代码等同于上下文管理器的 <strong>enter</strong> 函数</li>
<li>yield的返回值等同于__enter__函数的返回值，即如果with语句声明了as <variable>, 则yield的值会赋给variable</li>
<li>执行<clearup>代码块，等同于上下文管理器的__exit__函数，此时发生的任何异常都会再次通过yield函数返回</li>
</ul>
<p>锁资源自动获取和释放例子：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">locked</span>(<span class="params">lock</span>):</span></span><br><span class="line">	lock.acquire()</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">yield</span></span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		lock.release()</span><br><span class="line">		</span><br><span class="line"><span class="keyword">with</span> locked(myLock):</span><br><span class="line">	<span class="comment"># 代码执行到此处，myLock已经自动上锁</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">	<span class="comment"># 执行完毕后，会自动释放锁</span></span><br></pre></td></tr></table></figure>

<p>文件打开后自动管理例子：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def myopen(filename, mode&#x3D;&#39;r&#39;):</span><br><span class="line">	f &#x3D; open(filename, mode)</span><br><span class="line">	try:</span><br><span class="line">		yield f</span><br><span class="line">	finally:</span><br><span class="line">		f.close()</span><br><span class="line">		</span><br><span class="line">with myopen(&quot;abc.txt&quot;) as f:</span><br><span class="line">	for line in f:</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure>

<p>数据库事务处理例子：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def transaction(db):</span><br><span class="line">	db.begin()</span><br><span class="line">	try:</span><br><span class="line">		yield</span><br><span class="line">	except:</span><br><span class="line">		db.rollback()</span><br><span class="line">		raise</span><br><span class="line">	else:</span><br><span class="line">		db.commit()</span><br><span class="line">		</span><br><span class="line">with transaction(mydb):</span><br><span class="line">	mydb.cursor.execute(sql)</span><br><span class="line">	mydb.cursor.execute(sql)</span><br></pre></td></tr></table></figure>


<h1 id="closing对象"><a href="#closing对象" class="headerlink" title="closing对象"></a>closing对象</h1><p>contextlib模块包含一个closing对象，这个对象就是一个上下文管理器，它的__exit__函数仅仅调用传入参数的close函数，closing源码如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class closing(object):</span><br><span class="line">     def __init__(self, thing):</span><br><span class="line">         self.thing &#x3D; thing</span><br><span class="line">     def __enter__(self):</span><br><span class="line">         return self.thing</span><br><span class="line">     def __exit__(self, *exc_info):</span><br><span class="line">         self.thing.close()</span><br></pre></td></tr></table></figure>

<p>可以利用closing对象关闭具有close()方法的资源对象，例如打开网页如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib, sys</span><br><span class="line">from contextlib import closing</span><br><span class="line"></span><br><span class="line">with closing(urllib.urlopen(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        sys.stdout.write(line)</span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/nnnkkk/p/4309275.html">https://www.cnblogs.com/nnnkkk/p/4309275.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>with_as</tag>
      </tags>
  </entry>
  <entry>
    <title>vue grammar learning!</title>
    <url>/2019/07/04/vue/2019-07-04-vue-basic/</url>
    <content><![CDATA[<a id="more"></a>

<p>Vue.js是一套构建用户界面的渐进式框架。<br>与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。<br>Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。<br>另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用</p>
<h1 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h1><ul>
<li>Vue.js是目前最火的一个框架，React是最流行的一个框架（react除了开发网站，还可以开发手机APP）</li>
<li>Vue.js是前端的<strong>主流框架之一</strong>，和Angular.js、React.js一起，并称为前端三大主流框架</li>
<li>Vue.js是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合（Vue有配套的第三方类库，可以整合起来做大型项目开发）</li>
<li>前端的主要工作？主要负责MVC中的V这一层，主要工作就是和界面打交道</li>
</ul>
<h1 id="为什么学习流行框架"><a href="#为什么学习流行框架" class="headerlink" title="为什么学习流行框架"></a>为什么学习流行框架</h1><ul>
<li>企业是为了提高开发效率；在企业中时间就是效率，效率就是金钱</li>
<li>提高开发效率的发展历程：原生JS &gt;&gt; Jquery之类的类库 &gt;&gt; 前端模版引擎 &gt;&gt; Angular.js/Vue.js</li>
<li>在Vue中，一个核心的概念：让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多时间去关注业务逻辑</li>
<li>增强自己就业时的竞争力</li>
</ul>
<h1 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h1><ul>
<li>框架：一套完整的解决方案；对项目的侵入性较大，项目如果要更换框架，需要重新架构整个项目<ul>
<li>node的express</li>
</ul>
</li>
<li>库(插件)：提供某一个小功能，对项目的侵入型较小，如果某个库无法完成某些需求，很容易切换到其他库实现需求</li>
</ul>
<h1 id="Node-后端-中的MVC与前端中的MVVM的区别"><a href="#Node-后端-中的MVC与前端中的MVVM的区别" class="headerlink" title="Node(后端)中的MVC与前端中的MVVM的区别"></a>Node(后端)中的MVC与前端中的MVVM的区别</h1><ul>
<li>MVC是后端分层开发的概念；</li>
<li>MVVM是前端视图层的概念，主要关注于视图层分离，也就是说： MVVM把前端的视图层，分为了三部分： Model， View， VM ViewModel<ul>
<li>app.js： 项目的入口模块，一切请求，都要先进入这里进行处理。注意：app.js并没有路由分发的功能，需要调用router.js模块进行路由分发处理。</li>
<li>router.js： 路由分发处理模块，为了保证路由模块的职能单一，router.js只负责分发路由，不负责具体业务逻辑的处理。如果涉及到了业务处理操作，router.js无能为力，只能调用controller模块进行逻辑处理。</li>
<li>controller： 业务逻辑处理层，封装了一些具体业务逻辑处理的逻辑代码，也是为了保证职能单一，此模块只负责处理业务，不负责数据的CRUD，如果涉及到了数据的CRUD，需要调用Model层。</li>
<li>Model层： 职能单一，只负责操作数据库，执行对应的sql语句，进行数据的CRUD。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobra cli interface!</title>
    <url>/2019/07/21/golang/2019-07-21-cobra/</url>
    <content><![CDATA[<a id="more"></a>

<p>Cobra is a library that provides a simple interface to create powerful modern Cli interfaces, similar to git and go tools.<br>Cobra is also an application that will generate your application scaffold to quickly develop Cobra-based applications.</p>
<h2 id="Cobra可以提供哪些功能？"><a href="#Cobra可以提供哪些功能？" class="headerlink" title="Cobra可以提供哪些功能？"></a>Cobra可以提供哪些功能？</h2><ul>
<li>简单的基于子命令的命令行：如app server，app fetch等</li>
<li>完全兼容posix的标志flags(包括短版本和长版本)</li>
<li>嵌套的子命令</li>
<li>支持全局、本地和级联标志flags</li>
<li>使用cobra init appname和cobra add cmdname轻松生成应用程序和命令</li>
<li>智能建议(app srver…你是说app server吗?)</li>
<li>自动生成命令和标志的帮助</li>
<li>自动识别帮助标志-h, –help等</li>
<li>为您的应用程序自动生成bash自动完成</li>
<li>自动生成应用程序的man手册</li>
<li>命令别名，这样您就可以在不破坏它们的情况下更改内容</li>
<li>定义自己的帮助、用法等的灵活性。</li>
<li>可选的紧密集成的viper apps；</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Cobra建立在命令、参数和标志的结构之上</p>
<p>命令表示动作，arg表示对象，标志是这些动作的修饰符</p>
<p>最好的应用程序在使用时会读起来像句子。用户将知道如何使用应用程序，因为他们天生就知道如何使用它</p>
<p>接下来的模式是<code>APPNAME 动词 名词 形容词</code>或<code>APPNAME COMMAND ARG --FLAG</code></p>
<p>在下面的例子中，’server’是一个命令，’port’是一个标志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo server --port&#x3D;1313</span><br></pre></td></tr></table></figure>

<p>在这个命令中，我们告诉Git克隆bare url:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone URL --bare</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>命令是应用程序的中心点。应用程序支持的每个交互都包含在一个命令中。命令可以有子命令和可选参数来运行一个动作。</p>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志是一种修改命令行为的方式。Cobra支持完全兼容posix的标志以及Go标志包。Cobra命令可以定义持续到子命令的标志，以及仅对该命令可用的标志。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>获取Cobra最新版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com&#x2F;spf13&#x2F;cobra</span><br></pre></td></tr></table></figure>

<p>在项目中引用cobra</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;github.com&#x2F;spf13&#x2F;cobra</span><br></pre></td></tr></table></figure>

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>通常基于cobra的应用程序将遵循以下组织结构，当然你也可以采用自己的组织结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">▾ appName&#x2F;</span><br><span class="line">  ▾ cmd&#x2F;</span><br><span class="line">      add.go</span><br><span class="line">      your.go</span><br><span class="line">      commands.go</span><br><span class="line">      here.go</span><br><span class="line">    main.go</span><br></pre></td></tr></table></figure>

<p>在Cobra应用程序中，通常是主程序。去文件是非常光秃秃的。它有一个目的:初始化Cobra。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;&#123;pathToYourApp&#125;&#x2F;cmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Cobra生成器"><a href="#使用Cobra生成器" class="headerlink" title="使用Cobra生成器"></a>使用Cobra生成器</h2><p>Cobra提供了自己的程序，可以创建您的应用程序并添加您想要的任何命令。这是将Cobra合并到应用程序中最简单的方法。</p>
<h2 id="使用Cobra库"><a href="#使用Cobra库" class="headerlink" title="使用Cobra库"></a>使用Cobra库</h2><p>要手动实现Cobra，您需要创建一个main.go文件和rootCmd文件。您可以选择提供您认为合适的附加命令。</p>
<h3 id="创建rootCmd"><a href="#创建rootCmd" class="headerlink" title="创建rootCmd"></a>创建rootCmd</h3><p>Cobra不需要任何特殊的构造函数。只需创建您的命令。</p>
<p>理想情况下，你把它放在app/cmd/root.go:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rootCmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">  Use:   &quot;hugo&quot;,</span><br><span class="line">  Short: &quot;Hugo is a very fast static site generator&quot;,</span><br><span class="line">  Long: &#96;A Fast and Flexible Static Site Generator built with</span><br><span class="line">                love by spf13 and friends in Go.</span><br><span class="line">                Complete documentation is available at http:&#x2F;&#x2F;hugo.spf13.com&#96;,</span><br><span class="line">  Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">    &#x2F;&#x2F; Do Stuff Here</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Execute() &#123;</span><br><span class="line">  if err :&#x3D; rootCmd.Execute(); err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    os.Exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以在init()函数中定义标志并处理配置。</p>
<p>例如下面 cmd/root.go：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line"></span><br><span class="line">  homedir &quot;github.com&#x2F;mitchellh&#x2F;go-homedir&quot;</span><br><span class="line">  &quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">  &quot;github.com&#x2F;spf13&#x2F;viper&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">  cobra.OnInitialize(initConfig)</span><br><span class="line">  rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME&#x2F;.cobra.yaml)&quot;)</span><br><span class="line">  rootCmd.PersistentFlags().StringVarP(&amp;projectBase, &quot;projectbase&quot;, &quot;b&quot;, &quot;&quot;, &quot;base project directory eg. github.com&#x2F;spf13&#x2F;&quot;)</span><br><span class="line">  rootCmd.PersistentFlags().StringP(&quot;author&quot;, &quot;a&quot;, &quot;YOUR NAME&quot;, &quot;Author name for copyright attribution&quot;)</span><br><span class="line">  rootCmd.PersistentFlags().StringVarP(&amp;userLicense, &quot;license&quot;, &quot;l&quot;, &quot;&quot;, &quot;Name of license for the project (can provide &#96;licensetext&#96; in config)&quot;)</span><br><span class="line">  rootCmd.PersistentFlags().Bool(&quot;viper&quot;, true, &quot;Use Viper for configuration&quot;)</span><br><span class="line">  viper.BindPFlag(&quot;author&quot;, rootCmd.PersistentFlags().Lookup(&quot;author&quot;))</span><br><span class="line">  viper.BindPFlag(&quot;projectbase&quot;, rootCmd.PersistentFlags().Lookup(&quot;projectbase&quot;))</span><br><span class="line">  viper.BindPFlag(&quot;useViper&quot;, rootCmd.PersistentFlags().Lookup(&quot;viper&quot;))</span><br><span class="line">  viper.SetDefault(&quot;author&quot;, &quot;NAME HERE &lt;EMAIL ADDRESS&gt;&quot;)</span><br><span class="line">  viper.SetDefault(&quot;license&quot;, &quot;apache&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initConfig() &#123;</span><br><span class="line">  &#x2F;&#x2F; Don&#39;t forget to read config either from cfgFile or from home directory!</span><br><span class="line">  if cfgFile !&#x3D; &quot;&quot; &#123;</span><br><span class="line">    &#x2F;&#x2F; Use config file from the flag.</span><br><span class="line">    viper.SetConfigFile(cfgFile)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Find home directory.</span><br><span class="line">    home, err :&#x3D; homedir.Dir()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      os.Exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search config in home directory with name &quot;.cobra&quot; (without extension).</span><br><span class="line">    viper.AddConfigPath(home)</span><br><span class="line">    viper.SetConfigName(&quot;.cobra&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if err :&#x3D; viper.ReadInConfig(); err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Println(&quot;Can&#39;t read config:&quot;, err)</span><br><span class="line">    os.Exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建你的main-go"><a href="#创建你的main-go" class="headerlink" title="创建你的main.go"></a>创建你的main.go</h3><p>使用根命令，您需要让主函数执行它。为了清晰起见，Execute应该在根上运行，不过可以在任何命令上调用它。</p>
<p>在Cobra应用程序中，通常是主程序。去文件是非常光秃秃的。它的一个目的是初始化Cobra。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;&#123;pathToYourApp&#125;&#x2F;cmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建其他的命令"><a href="#创建其他的命令" class="headerlink" title="创建其他的命令"></a>创建其他的命令</h3><p>可以定义其他命令，通常每个命令在cmd/目录中都有自己的文件。</p>
<p>如果您想创建一个版本命令，您可以创建cmd/version。用下面的代码填充它:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cmd</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">  rootCmd.AddCommand(versionCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var versionCmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">  Use:   &quot;version&quot;,</span><br><span class="line">  Short: &quot;Print the version number of Hugo&quot;,</span><br><span class="line">  Long:  &#96;All software has versions. This is Hugo&#39;s&#96;,</span><br><span class="line">  Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">    fmt.Println(&quot;Hugo Static Site Generator v0.9 -- HEAD&quot;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用标志"><a href="#使用标志" class="headerlink" title="使用标志"></a>使用标志</h2><p>标志提供修饰符来控制操作命令的操作方式。</p>
<h3 id="为命令分配标志"><a href="#为命令分配标志" class="headerlink" title="为命令分配标志"></a>为命令分配标志</h3><p>由于这些标志是在不同的位置定义和使用的，所以我们需要在外部定义一个变量，该变量具有正确的范围，以便分配要使用的标志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Verbose bool</span><br><span class="line">var Source string</span><br></pre></td></tr></table></figure>
<p>有两种不同的方法来分配标志。</p>
<h3 id="持久化的标志"><a href="#持久化的标志" class="headerlink" title="持久化的标志"></a>持久化的标志</h3><p>一个标志可以是“持久的”，这意味着这个标志将对分配给它的命令以及该命令下的每个命令可用。对于全局标志，将标志指定为根上的持久标志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;verbose output&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="本地的标志"><a href="#本地的标志" class="headerlink" title="本地的标志"></a>本地的标志</h3><p>还可以在本地分配一个标志，该标志只适用于该特定命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootCmd.Flags().StringVarP(&amp;Source, &quot;source&quot;, &quot;s&quot;, &quot;&quot;, &quot;Source directory to read from&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="父命令上的本地标志"><a href="#父命令上的本地标志" class="headerlink" title="父命令上的本地标志"></a>父命令上的本地标志</h3><p>默认情况下Cobra只解析目标命令上的本地标志，父命令上的任何本地标志都将被忽略。</p>
<p>通过启用命令。在执行目标命令之前，TraverseChildren Cobra将在每个命令上解析父命令上的本地标志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command :&#x3D; cobra.Command&#123;</span><br><span class="line">  Use: &quot;print [OPTIONS] [COMMANDS]&quot;,</span><br><span class="line">  TraverseChildren: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用配置绑定标志"><a href="#使用配置绑定标志" class="headerlink" title="使用配置绑定标志"></a>使用配置绑定标志</h3><p>你也可以用viper绑定你的标志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var author string</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">  rootCmd.PersistentFlags().StringVar(&amp;author, &quot;author&quot;, &quot;YOUR NAME&quot;, &quot;Author name for copyright attribution&quot;)</span><br><span class="line">  viper.BindPFlag(&quot;author&quot;, rootCmd.PersistentFlags().Lookup(&quot;author&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中，持久性标志author与viper绑定。注意，当用户没有提供<code>--author</code>标志时，变量author不会被设置为config中的值。</p>
<h3 id="设置必须配置的标志"><a href="#设置必须配置的标志" class="headerlink" title="设置必须配置的标志"></a>设置必须配置的标志</h3><p>默认情况下标志是可选的。如果你希望你的命令报告一个错误时，没有设置一个标志，标记它按要求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootCmd.Flags().StringVarP(&amp;Region, &quot;region&quot;, &quot;r&quot;, &quot;&quot;, &quot;AWS region (required)&quot;)</span><br><span class="line">rootCmd.MarkFlagRequired(&quot;region&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="位置参数和自定义参数"><a href="#位置参数和自定义参数" class="headerlink" title="位置参数和自定义参数"></a>位置参数和自定义参数</h2><p>位置参数的验证可以使用命令的Args字段指定。</p>
<p>内置的验证器:</p>
<ul>
<li>NoArgs: 如果有任何位置参数，该命令将报告错误。</li>
<li>ArbitraryArgs: 命令将接受任何参数。</li>
<li>OnlyValidArgs： 如果有任何位置args不在命令的ValidArgs字段中，该命令将报告错误。</li>
<li>MinimumNArgs(int): 如果不存在至少N个位置参数，该命令将报告错误。</li>
<li>MaximumNArgs(int): 如果有超过N个位置参数，该命令将报告一个错误。</li>
<li>ExactArgs(int): 如果没有确切的N个位置参数，命令将报告错误。</li>
<li>ExactValidArgs(int): 如果没有确切的N个位置args，或者有任何位置args不在命令的ValidArgs字段中，该命令将报告一个错误.</li>
<li>RangeArgs(min, max): 如果arg的数量不在预期的最小和最大arg数量之间，则命令将报告错误。</li>
</ul>
<p>设置自定义验证器的一个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">  Short: &quot;hello&quot;,</span><br><span class="line">  Args: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">    if len(args) &lt; 1 &#123;</span><br><span class="line">      return errors.New(&quot;requires a color argument&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if myapp.IsValidColor(args[0]) &#123;</span><br><span class="line">      return nil</span><br><span class="line">    &#125;</span><br><span class="line">    return fmt.Errorf(&quot;invalid color specified: %s&quot;, args[0])</span><br><span class="line">  &#125;,</span><br><span class="line">  Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在下面的示例中，我们定义了三个命令。两个位于顶层，一个(cmdTimes)是顶层命令之一的子命令。在这种情况下，根不可执行，这意味着需要子命令。这是通过不为“rootCmd”提供“Run”来实现的。</p>
<p>我们仅为单个命令定义了一个标志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;strings&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var echoTimes int</span><br><span class="line"></span><br><span class="line">  var cmdPrint &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">    Use:   &quot;print [string to print]&quot;,</span><br><span class="line">    Short: &quot;Print anything to the screen&quot;,</span><br><span class="line">    Long: &#96;print is for printing anything back to the screen.</span><br><span class="line">For many years people have printed back to the screen.&#96;,</span><br><span class="line">    Args: cobra.MinimumNArgs(1),</span><br><span class="line">    Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Println(&quot;Print: &quot; + strings.Join(args, &quot; &quot;))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var cmdEcho &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">    Use:   &quot;echo [string to echo]&quot;,</span><br><span class="line">    Short: &quot;Echo anything to the screen&quot;,</span><br><span class="line">    Long: &#96;echo is for echoing anything back.</span><br><span class="line">Echo works a lot like print, except it has a child command.&#96;,</span><br><span class="line">    Args: cobra.MinimumNArgs(1),</span><br><span class="line">    Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Println(&quot;Print: &quot; + strings.Join(args, &quot; &quot;))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var cmdTimes &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">    Use:   &quot;times [string to echo]&quot;,</span><br><span class="line">    Short: &quot;Echo anything to the screen more times&quot;,</span><br><span class="line">    Long: &#96;echo things multiple times back to the user by providing</span><br><span class="line">a count and a string.&#96;,</span><br><span class="line">    Args: cobra.MinimumNArgs(1),</span><br><span class="line">    Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      for i :&#x3D; 0; i &lt; echoTimes; i++ &#123;</span><br><span class="line">        fmt.Println(&quot;Echo: &quot; + strings.Join(args, &quot; &quot;))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cmdTimes.Flags().IntVarP(&amp;echoTimes, &quot;times&quot;, &quot;t&quot;, 1, &quot;times to echo the input&quot;)</span><br><span class="line"></span><br><span class="line">  var rootCmd &#x3D; &amp;cobra.Command&#123;Use: &quot;app&quot;&#125;</span><br><span class="line">  rootCmd.AddCommand(cmdPrint, cmdEcho)</span><br><span class="line">  cmdEcho.AddCommand(cmdTimes)</span><br><span class="line">  rootCmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令格式：<br>app print<br>app echo<br>app echo times  –times=5</p>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>当您有子命令时，Cobra会自动向您的应用程序添加一个帮助命令。这将在用户运行“app help”时调用。此外，help还将支持所有其他命令作为输入。例如，您有一个名为“create”的命令，没有任何其他配置;Cobra将在“应用程序帮助创建”被调用时工作。每个命令都会自动添加<code>--help</code>标志。</p>
<h3 id="帮助例子"><a href="#帮助例子" class="headerlink" title="帮助例子"></a>帮助例子</h3><p>以下输出由Cobra自动生成。除了命令和标志定义之外，不需要任何东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cobra help</span><br><span class="line"></span><br><span class="line">Cobra is a CLI library for Go that empowers applications.</span><br><span class="line">This application is a tool to generate the needed files</span><br><span class="line">to quickly create a Cobra application.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cobra [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  add         Add a command to a Cobra Application</span><br><span class="line">  help        Help about any command</span><br><span class="line">  init        Initialize a Cobra Application</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -a, --author string    author name for copyright attribution (default &quot;YOUR NAME&quot;)</span><br><span class="line">      --config string    config file (default is $HOME&#x2F;.cobra.yaml)</span><br><span class="line">  -h, --help             help for cobra</span><br><span class="line">  -l, --license string   name of license for the project</span><br><span class="line">      --viper            use Viper for configuration (default true)</span><br><span class="line"></span><br><span class="line">Use &quot;cobra [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure>
<p>帮助只是像其他命令一样的命令。它没有特殊的逻辑或行为。事实上，如果您愿意，您可以自己提供。</p>
<h3 id="定义你自己的帮助"><a href="#定义你自己的帮助" class="headerlink" title="定义你自己的帮助"></a>定义你自己的帮助</h3><p>你可以提供你自己的帮助命令或你自己的模板默认命令使用以下功能:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.SetHelpCommand(cmd *Command)</span><br><span class="line">cmd.SetHelpFunc(f func(*Command, []string))</span><br><span class="line">cmd.SetHelpTemplate(s string)</span><br></pre></td></tr></table></figure>

<h2 id="用法信息"><a href="#用法信息" class="headerlink" title="用法信息"></a>用法信息</h2><p>当用户提供无效标志或无效命令时，Cobra会向用户显示“用法”</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cobra --invalid</span><br><span class="line">Error: unknown flag: --invalid</span><br><span class="line">Usage:</span><br><span class="line">  cobra [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  add         Add a command to a Cobra Application</span><br><span class="line">  help        Help about any command</span><br><span class="line">  init        Initialize a Cobra Application</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -a, --author string    author name for copyright attribution (default &quot;YOUR NAME&quot;)</span><br><span class="line">      --config string    config file (default is $HOME&#x2F;.cobra.yaml)</span><br><span class="line">  -h, --help             help for cobra</span><br><span class="line">  -l, --license string   name of license for the project</span><br><span class="line">      --viper            use Viper for configuration (default true)</span><br><span class="line"></span><br><span class="line">Use &quot;cobra [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<h3 id="定义你自己的用法"><a href="#定义你自己的用法" class="headerlink" title="定义你自己的用法"></a>定义你自己的用法</h3><p>您可以为Cobra提供自己的使用功能或模板。像help一样，函数和模板可以通过公共方法覆盖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.SetUsageFunc(f func(*Command) error)</span><br><span class="line">cmd.SetUsageTemplate(s string)</span><br></pre></td></tr></table></figure>

<h2 id="版本标志"><a href="#版本标志" class="headerlink" title="版本标志"></a>版本标志</h2><p>如果在根命令上设置了version字段，Cobra将添加一个顶级的“–version”标志。运行带有”–version”标志的应用程序时，将使用版本模板将版本打印到stdout。可以使用<code>cmd.SetVersionTemplate(string)</code>函数定制模板。</p>
<h2 id="运行前和运行后钩子"><a href="#运行前和运行后钩子" class="headerlink" title="运行前和运行后钩子"></a>运行前和运行后钩子</h2><p>可以在命令的主运行函数之前或之后运行其他函数。PersistentPreRun和PreRun函数将在运行之前执行。PersistentPostRun和PostRun将在运行后执行。如果在子命令中没有声明它们自己的Persistent*Run函数，那么它们将继承父命令的。</p>
<p>这几个函数的运行顺序：</p>
<ul>
<li>PersistentPreRun</li>
<li>PreRun</li>
<li>Run</li>
<li>PostRun</li>
<li>PersistentPostRun</li>
</ul>
<p>下面是使用所有这些特性的两个命令的示例。当执行子命令时，它将运行根命令的PersistentPreRun，而不是根命令的PersistentPostRun:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">  var rootCmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">    Use:   &quot;root [sub]&quot;,</span><br><span class="line">    Short: &quot;My root command&quot;,</span><br><span class="line">    PersistentPreRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside rootCmd PersistentPreRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PreRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside rootCmd PreRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside rootCmd Run with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PostRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside rootCmd PostRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PersistentPostRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside rootCmd PersistentPostRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var subCmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">    Use:   &quot;sub [no options!]&quot;,</span><br><span class="line">    Short: &quot;My subcommand&quot;,</span><br><span class="line">    PreRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside subCmd PreRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    Run: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside subCmd Run with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PostRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside subCmd PostRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PersistentPostRun: func(cmd *cobra.Command, args []string) &#123;</span><br><span class="line">      fmt.Printf(&quot;Inside subCmd PersistentPostRun with args: %v\n&quot;, args)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rootCmd.AddCommand(subCmd)</span><br><span class="line"></span><br><span class="line">  rootCmd.SetArgs([]string&#123;&quot;&quot;&#125;)</span><br><span class="line">  rootCmd.Execute()</span><br><span class="line">  fmt.Println()</span><br><span class="line">  rootCmd.SetArgs([]string&#123;&quot;sub&quot;, &quot;arg1&quot;, &quot;arg2&quot;&#125;)</span><br><span class="line">  rootCmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inside rootCmd PersistentPreRun with args: []</span><br><span class="line">Inside rootCmd PreRun with args: []</span><br><span class="line">Inside rootCmd Run with args: []</span><br><span class="line">Inside rootCmd PostRun with args: []</span><br><span class="line">Inside rootCmd PersistentPostRun with args: []</span><br><span class="line"></span><br><span class="line">Inside rootCmd PersistentPreRun with args: [arg1 arg2]</span><br><span class="line">Inside subCmd PreRun with args: [arg1 arg2]</span><br><span class="line">Inside subCmd Run with args: [arg1 arg2]</span><br><span class="line">Inside subCmd PostRun with args: [arg1 arg2]</span><br><span class="line">Inside subCmd PersistentPostRun with args: [arg1 arg2]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>cobra</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code!</title>
    <url>/2018/09/19/reading/2018-09-19-cleancode/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="一、整洁代码"><a href="#一、整洁代码" class="headerlink" title="一、整洁代码"></a>一、整洁代码</h1><h2 id="1-为什么阅读这本书？"><a href="#1-为什么阅读这本书？" class="headerlink" title="1 为什么阅读这本书？"></a>1 为什么阅读这本书？</h2><ul>
<li>你是个程序员</li>
<li>你想成为更好的程序员</li>
</ul>
<h2 id="2-读完本书，获得的技能？"><a href="#2-读完本书，获得的技能？" class="headerlink" title="2 读完本书，获得的技能？"></a>2 读完本书，获得的技能？</h2><ul>
<li>知道更多关于代码的事儿</li>
<li>辨别好代码和糟糕代码的差异</li>
<li>学会如何写出好代码</li>
<li>学会如何将糟糕代码改成好代码</li>
</ul>
<h2 id="3-写糟糕代码的理由与代价"><a href="#3-写糟糕代码的理由与代价" class="headerlink" title="3 写糟糕代码的理由与代价"></a>3 写糟糕代码的理由与代价</h2><ul>
<li>理由<ul>
<li>为了快点完成而赶时间；</li>
<li>只是单纯的为了实现结果，哪怕你的代码过程怎么样都不重要，当结果呈现出你想象中的样子，你便弃之而不顾，可能当你回头再看你写的代码时，你都忘记是怎样的思路;</li>
<li>随便先写点代码出来，结果出现后稍后再整理;</li>
</ul>
</li>
<li>代价<ul>
<li>久而久之，以你习惯写出的代码，在团队中，你可能会被嫌弃;</li>
<li>可能会因为你的原因拖延整个项目组的时间；</li>
<li>需求变了，你像重新来过一样再改，重复重复，这团乱麻越来越大，直到束手无策，团队生产力下降。</li>
</ul>
</li>
</ul>
<h2 id="4-怎么是整洁的代码？"><a href="#4-怎么是整洁的代码？" class="headerlink" title="4 怎么是整洁的代码？"></a>4 怎么是整洁的代码？</h2><ul>
<li><p>Bjarne Stroustrup（C++发明者）</p>
<ul>
<li>我喜欢优雅和高效的代码，代码逻辑应当直接了当，叫缺陷难以隐藏；</li>
<li>尽量减少依赖关系，使之便于维护；</li>
<li>依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没有必要的优化，搞出一堆混乱来，整洁的代码只做好一件事。</li>
</ul>
</li>
<li><p>Ron Jeffries</p>
<ul>
<li>能通过所有的测试；</li>
<li>没有重复代码；</li>
<li>体现系统中的全部设计理念；</li>
<li>包含尽量少的实体、比如类、方法、函数等。</li>
</ul>
</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><h3 id="5-1-整洁代码符合以下目标"><a href="#5-1-整洁代码符合以下目标" class="headerlink" title="5.1 整洁代码符合以下目标"></a>5.1 整洁代码符合以下目标</h3><ul>
<li>1.职责明确，没有多余；</li>
<li>2.减少依赖，便于维护；</li>
<li>3.高效。</li>
</ul>
<h3 id="5-2-整洁代码的建议"><a href="#5-2-整洁代码的建议" class="headerlink" title="5.2 整洁代码的建议"></a>5.2 整洁代码的建议</h3><ul>
<li>有意义的命名，代码应通过其字面表达含义；</li>
<li>没有重复代码；</li>
<li>全面覆盖的单元测试；</li>
<li>提供清晰、尽量少的API；</li>
<li>完美的错误处理代码，不要忽略细节；</li>
<li>性能调至最优，省得引诱别人做没规矩的优化；</li>
<li>尽量少的依赖关系，便于维护；</li>
<li>尽量少的实体，比如类、方法、函数等；</li>
<li>整洁的代码（类/函数/模块）只做好一件事；</li>
<li>整洁的代码看起来专为解决那个问题而存在；</li>
<li>整洁的代码简单直接，从不隐藏设计者的意图；</li>
<li>整洁的代码看起来像是某位特别在意她的人写的，没有改进的余地；</li>
<li>整洁的代码浅显易懂，绝不故作高深；</li>
</ul>
<h3 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h3><p>每一位程序员就像是位艺术家，把写代码当做自己在雕刻一件艺术品，一定要美观到最精致，呈现给人们一种赏心悦目的景象。</p>
<h1 id="二、有意义的命名"><a href="#二、有意义的命名" class="headerlink" title="二、有意义的命名"></a>二、有意义的命名</h1><p>变量、函数、参数、类、包、文件。很多地方都需要命名，怎么样命名才能简洁明了。</p>
<h2 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1. 名副其实"></a>1. 名副其实</h2><p>选个好名字要花时间，但省下来的时间比花掉的多。一旦有好的命名，就换掉旧的。</p>
<h3 id="1-1-如果名称需要注释来补充，那么说明名字没取好"><a href="#1-1-如果名称需要注释来补充，那么说明名字没取好" class="headerlink" title="1.1 如果名称需要注释来补充，那么说明名字没取好"></a>1.1 如果名称需要注释来补充，那么说明名字没取好</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差的命名</span></span><br><span class="line"><span class="keyword">int</span> d;          <span class="comment">// 消逝的时间，以日计算。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的命名</span></span><br><span class="line"><span class="keyword">int</span> elapsedTimeInDays;</span><br><span class="line"><span class="keyword">int</span> daysSinceCreation;</span><br><span class="line"><span class="keyword">int</span> daysSinceModification;</span><br><span class="line"><span class="keyword">int</span> fileAgeInDays;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-选择体现本意的名称能让人更容易理解和修改代码"><a href="#1-2-选择体现本意的名称能让人更容易理解和修改代码" class="headerlink" title="1.2 选择体现本意的名称能让人更容易理解和修改代码"></a>1.2 选择体现本意的名称能让人更容易理解和修改代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getThem() &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; list1 = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] x : theList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">0</span>] == <span class="number">4</span>) &#123;</span><br><span class="line">            list1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的问题：</p>
<ul>
<li>theList中是什么类型的东西</li>
<li>theList零下标条目的意义是什么</li>
<li>值4的意义是什么</li>
<li>我怎么使用返回的列表</li>
</ul>
<p>问题的答案没体现在代码段中，而这本就是它们应该在的地方。比如，我们正在开发一款扫雷游戏，我们发现盘面是名为theList的单元格列表，那就将其名称改为gameBoard。</p>
<p>盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态的值，而这种状态值为4表示为“已标记”。只要改为有意义的名称，代码就会得到相当程度的改进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getFlaggedCells() &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] cell : gameBoard) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cell[STAUS_VALUE] == FLAGGED) &#123;</span><br><span class="line">            flaggedCells.add(cell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以更进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为isFlagged），从而掩盖住那个魔术数（就是那个4）。于是得到函数的新版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cell&gt; <span class="title">getFlaggedCells</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Cell&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : gameBoard) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cell.isFlagged()) &#123;</span><br><span class="line">            flaggedCells.add(cell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2 避免误导"></a>2 避免误导</h2><p>程序员必须避免留下掩盖代码本意的错误线索。应当避免使用与本意相悖的词。</p>
<p>别用accountList来指称一组账号，除非它真的是List类型（即便容器就是一个List，最好也别在名称中写出容器类型名）。如果包含账号的容器并非真是个List，就会引起错误的判断。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。</p>
<h2 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3 做有意义的区分"></a>3 做有意义的区分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyChars</span><span class="params">(<span class="keyword">char</span> a1[],<span class="keyword">char</span> a2[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a1.length;i++)&#123;</span><br><span class="line">    a2[i]=a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数名称改为source和destination ，这个函数就会像样很多。</p>
<p>废话都是冗余的，Variable一词 永远不应当出现在变量名中;<br>Table一词永远不应当出现在表名中;<br>NameString 会比 Name好吗，难道Name 会是一个浮点数不成？<br>如有一个Customer的类，有又一个CustomerObject的类。是不是就凌乱了。  </p>
<h2 id="4-使用读的出来的名称"><a href="#4-使用读的出来的名称" class="headerlink" title="4 使用读的出来的名称"></a>4 使用读的出来的名称</h2><p>能读出来的名称更容易记忆。如果名称读不出来，讨论的时候就像个傻鸟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date genymdhms <span class="comment">// 生成日期，年、月、日、时、分、秒</span></span><br><span class="line"></span><br><span class="line">Date generationTimestamp;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5 使用可搜索的名称"></a>5 使用可搜索的名称</h2><p>找<code>MAX_CLASSES_PER_STUDENT</code>比找数字7要容易得多。同样字母e也不是个便于搜索的变量名。因为太常见了。</p>
<p>单字母名称仅用于短方法中的局部变量。名称长短应与其作用域大小相对应。如果变量或常量可能在代码中多处使用，则应赋予其以便于搜索的名字。</p>
<h2 id="6-避免将类型或作用域编进名称中"><a href="#6-避免将类型或作用域编进名称中" class="headerlink" title="6 避免将类型或作用域编进名称中"></a>6 避免将类型或作用域编进名称中</h2><ul>
<li>匈牙利语标记法（Hungarian Notation,HN）<br>早期编译器不做类型检查，程序员需要用匈牙利语标记法（Hungarian Notation,HN）来帮助自己记住类型</li>
</ul>
<p>例如szCmdLine的前缀sz代表string end of zero.以0 结尾的字符串。strPhone,代表Phone是字符串类型。</p>
<p>而今，大部分语言是<strong>强类型</strong>的，代码编辑环境都已经先进到在编译开始前就侦测到类型错误的程度！所以匈牙利语标记法和其他类似的格式编码都多余了。</p>
<p>匈牙利语标记法加了修改变量，函数，或类的名称或类型的难度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneNumber phoneString;</span><br><span class="line"><span class="comment">//类型变化时，名称并未变化。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>成员前缀<br>也不必用 m_ 前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。</p>
</li>
<li><p>接口和实现<br>接口前导字母I被滥用。</p>
</li>
</ul>
<h2 id="7-类名应该是名词或名词短语，方法名应该是动词或者动词短语"><a href="#7-类名应该是名词或名词短语，方法名应该是动词或者动词短语" class="headerlink" title="7 类名应该是名词或名词短语，方法名应该是动词或者动词短语"></a>7 类名应该是名词或名词短语，方法名应该是动词或者动词短语</h2><p>类名如Customer、WikiPage、Account。避免使用Manager、Processor、Data或Info这样的类名</p>
<p>方法名如postPayment、deletePage或save。属性访问器、修改器或断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。</p>
<h2 id="8-同一概念对应统一个词"><a href="#8-同一概念对应统一个词" class="headerlink" title="8 同一概念对应统一个词"></a>8 同一概念对应统一个词</h2><p>比如get、fetch、retrieve表达的含义差不多，尽量保持多个类使用同一种写法。</p>
<p>Controller、Manager、Driver含义相近，尽量保持一致。</p>
<h2 id="9-不用双关语"><a href="#9-不用双关语" class="headerlink" title="9 不用双关语"></a>9 不用双关语</h2><p>避免将同一个单词用于不同的目的。代码作者应该尽力写出易于理解的代码。</p>
<p>比如add、insert、append之间的区别要搞清楚，对于方法的命名要清晰。</p>
<h2 id="10-使用解决方案领域名称"><a href="#10-使用解决方案领域名称" class="headerlink" title="10 使用解决方案领域名称"></a>10 使用解决方案领域名称</h2><p>代码是给程序员读的，用计算机领域类的术语来命名是一个很好的做法。比如AccountVisitor、JobQueue这种。</p>
<p>如果不能用程序员熟悉的术语来命名，就采用所涉问题的领域名称命名。</p>
<h2 id="11-添加有意义的语境、不要添加没用的语境"><a href="#11-添加有意义的语境、不要添加没用的语境" class="headerlink" title="11 添加有意义的语境、不要添加没用的语境"></a>11 添加有意义的语境、不要添加没用的语境</h2><p>如果你有命名良好的类、函数或命名空间来放置名称，给读者提供语境是最好不过了。如果没有，就用最后一招———给名称添加前缀。</p>
<p>比如，你有名为firstName、lastName、street、hourseNumber、city、state变量，搁一块儿的时候，很明确是一个地址。如果只是在一个方法中单独的看到一个state变量呢，你会理所当然得推断是一个地址吗？</p>
<p>可以添加前缀addrFirstName、addrLastName、addrState来提供语境。</p>
<p>假设有一个名为“加油站豪华版”(Gas Station Deluxe)的应用，在其中给每个类添加GSD前缀就不是什么好点子了。</p>
<h1 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h1><h2 id="1-短小"><a href="#1-短小" class="headerlink" title="1 短小"></a>1 短小</h2><p>函数的第一个规则就是要短小。短小才精悍，浓缩的都是精华。函数短小的好处：</p>
<ul>
<li>对于大部分大脑不是特别发达的人，10个10行的函数可能比一个100行的函数理解起来更容易。</li>
<li>如果给每个“小函数”能起一个具有说明性的名字，那么整个流程读下来会更清晰，而且可以增加代码自解释的作用。</li>
<li>短小的函数便于在电脑屏中完整的显示出来，不需要上下去滚动屏幕。</li>
<li>函数二十行最佳。</li>
<li>函数的缩进层级不应该超过二层。</li>
</ul>
<h2 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2 只做一件事"></a>2 只做一件事</h2><p>函数应该做好一件事，做好这件事，只做这件事—单一职责原则</p>
<h2 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3 每个函数一个抽象层级"></a>3 每个函数一个抽象层级</h2><p>让代码拥有自顶向下的阅读顺序，函数中的语句都要在同一个抽象层级上。</p>
<p>函数中混杂不同抽象层级，让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。</p>
<h2 id="4-switch语句不可避免，使用多态隐藏到较低的抽象层"><a href="#4-switch语句不可避免，使用多态隐藏到较低的抽象层" class="headerlink" title="4 switch语句不可避免，使用多态隐藏到较低的抽象层"></a>4 switch语句不可避免，使用多态隐藏到较低的抽象层</h2><p>switch语句天生就是要做N件事，不幸地是我们总无法避开，不过还是能够确保每个switch语句都埋藏在较低的抽象层，而且永远不重复。</p>
<h2 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5 使用描述性的名称"></a>5 使用描述性的名称</h2><p>花时间给函数取个好的具有描述性的名字是很值得的，不要害怕长名字。函数功能越集中、越短小越容易取名字，如果你发现你对你的函数很难取名字的时候，是该考虑这个函数是否需要进行拆分了。</p>
<h2 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6 函数参数"></a>6 函数参数</h2><p>最理想的参数数量是零，其次是一，再次是二，应尽量避免三。有足够特殊的理由才能用三个以上参数——所以无论如何也不要这么做。</p>
<p>函数尽量不要有标识参数。向函数传入boolean值简直就是骇人听闻的做法。</p>
<p>如果函数看起来需要两个、三个或三个以上的参数，就说明其中一些参数应该封装为类了。例如，下面两个声明的差别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius)</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(Point center, <span class="keyword">double</span> radius)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-无副作用"><a href="#7-无副作用" class="headerlink" title="7 无副作用"></a>7 无副作用</h2><p>副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。</p>
<h2 id="8-使用异常代替返回错误码"><a href="#8-使用异常代替返回错误码" class="headerlink" title="8 使用异常代替返回错误码"></a>8 使用异常代替返回错误码</h2><p>返回错误码可能导致更深层次的嵌套结构。当返回错误码时就是在要求调用者立即处理错误。如果使用异常代替返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 嵌套结构层次深</span></span><br><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.deleteReference(page.name) == E_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configKeys.deleteKey(page.name.makeKey()) == E_OK) &#123;</span><br><span class="line">            logger.log(<span class="string">&quot;page deleted&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.log(configKey not deleted);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(<span class="string">&quot;deleteReference from registry failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.log(<span class="string">&quot;deleted failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> E_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用异常处理代替返回错误码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-错误处理就是一件事"><a href="#9-错误处理就是一件事" class="headerlink" title="9 错误处理就是一件事"></a>9 错误处理就是一件事</h2><p>函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不该做其他事。意味着如果关键字try在某个函数中存在，它就该是这个函数的第一个单词，而且在catch/finaly代码块后面也不该有其他内容。</p>
<h2 id="10-Error-java-依赖磁铁"><a href="#10-Error-java-依赖磁铁" class="headerlink" title="10 Error.java 依赖磁铁"></a>10 Error.java 依赖磁铁</h2><p>返回错误码通常意味着某处有个类或是枚举，定义了所有错误码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    OK,</span><br><span class="line">    INVALID,</span><br><span class="line">    NO_SUCH,</span><br><span class="line">    LOCKED,</span><br><span class="line">    OUT_OF_RESOURCES,</span><br><span class="line">    WAITING_FOR_EVENT,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的类就是一块依赖磁铁，其他许多类都得导入和使用它。当Error枚举修改时，所有这些其他类都需要重新编译和部署。</p>
<p>使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。</p>
<h2 id="11-别重复自己"><a href="#11-别重复自己" class="headerlink" title="11 别重复自己"></a>11 别重复自己</h2><p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为了控制与消除重复而创建的。</p>
<h2 id="12-结构化编程"><a href="#12-结构化编程" class="headerlink" title="12 结构化编程"></a>12 结构化编程</h2><p>Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，意味着在每个函数中只该有一个return语句，循环中不能有break或continue语句，而且永永远远不能有任何goto语句。</p>
<p>这个规范对于小函数帮助不大，只有在大函数中才有明显的好处。</p>
<h2 id="13-如何写出这样的函数"><a href="#13-如何写出这样的函数" class="headerlink" title="13 如何写出这样的函数"></a>13 如何写出这样的函数</h2><p>跟写文章一样，先想什么就写什么，然后不断打磨。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。</p>
<h1 id="四、注释"><a href="#四、注释" class="headerlink" title="四、注释"></a>四、注释</h1><p>若编程语言足够有表达力，或者我们擅长于用这些语言来表达意图，就不那么需要注释—也许根本不需要。</p>
<p>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。如果你发现自己需要写注释，再想想看是否有办法通过代码来表达。</p>
<h2 id="1-注释不能美化糟糕的代码"><a href="#1-注释不能美化糟糕的代码" class="headerlink" title="1 注释不能美化糟糕的代码"></a>1 注释不能美化糟糕的代码</h2><p>少量而准确是注释比大量而毫无意义的注释更有用。大量无用的注释会打乱阅读代码时的思路，也会增加滚动屏幕的成本。</p>
<h2 id="2-用代码来阐述"><a href="#2-用代码来阐述" class="headerlink" title="2 用代码来阐述"></a>2 用代码来阐述</h2><p>有时候，代码本身不足以解释其行为。幸运的是，很多时候我们都可以把代码写地能解释自己的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_DAY) &amp;&amp;  (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>
<p>改成这样怎么样？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>

<h2 id="3-好注释"><a href="#3-好注释" class="headerlink" title="3 好注释"></a>3 好注释</h2><p>有些注释是必须的，也是有利的。不过要记住，唯一真正的好注释是你想办法不去写的注释。</p>
<ul>
<li><p>法律信息<br>版本及著作权声明就是有理由在每个源文件开头注释处放置的内容</p>
</li>
<li><p>提供信息的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// format matched kk:mm:ss EEE, MMM dd, yyyy</span></span><br><span class="line">Pattern timeMatcher = Pattern.compile(<span class="string">&quot;\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注释说明，该正则表达式意在匹配一个经由SimpleDateFormat.format函数利用特定格式字符串格式化的时间和日期。</p>
<p>这类注释有时管用，但更好的方式是尽量利用函数名称表达信息。</p>
</li>
<li><p>对意图的解释。注释可以提供某个决定背后的故事。</p>
</li>
<li><p>阐释。注释可以解释某些难懂的参数或返回值的意义。</p>
</li>
<li><p>警示。有时，用于警示其他程序员会出现某种后果的注释也是有用的。</p>
</li>
<li><p>TODO注释。TODO大多都是程序员的自我安慰、自欺欺人。</p>
</li>
<li><p>放大。可以用来放大某种不合理之物的重要性。</p>
</li>
<li><p>公共API中的Javadoc</p>
</li>
</ul>
<h2 id="4-坏注释"><a href="#4-坏注释" class="headerlink" title="4 坏注释"></a>4 坏注释</h2><p>大多数注释都属此类。通常，坏注释都是糟糕代码的支撑或借口，或者对错误决策的修正，基本上等于程序员自说自话。</p>
<ul>
<li><p>喃喃自语<br>写一些只有作者自己知道含义的注释，就是喃喃自语。</p>
</li>
<li><p>多余的注释<br>相比代码本身无法提供更过的信息就是多余的注释。比如没有证明代码的意义，也没有给出代码的意图或逻辑。读这种注释还不如读代码。</p>
</li>
<li><p>误导性注释<br>注释不够精确，和代码本身表达的含义不一致，容易误导程序员。</p>
</li>
<li><p>循规式注释<br>谓每个函数都要有Javadoc或每个变量都要有注释的规矩全然是愚蠢可笑的。这类注释突然让代码变得散乱，满口胡言，令人迷惑不解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> title The title of the CD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author The author of the CD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tracks The number of tracks on the CD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> durationInMinutes The duration of the CD in minutes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCD</span><span class="params">(String title, String author, <span class="keyword">int</span> tracks, <span class="keyword">int</span> rationInMinutes)</span> </span>&#123;</span><br><span class="line">   CD cd = <span class="keyword">new</span> CD();</span><br><span class="line">   cd.title = title;</span><br><span class="line">   cd.author = author;</span><br><span class="line">   d.tracks = tracks;</span><br><span class="line">   cd.duration = durationInMinutes;</span><br><span class="line">   cdList.add(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志式注释<br>有人会在每次编辑代码时，在模块开始处添加一条注释。这类注释就像是一种记录每次修改的日志。</p>
<p>很久以前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。  </p>
</li>
<li><p>废话注释<br>对显然之事喋喋不休，毫无新意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">AnnualDateRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The day of the month. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> dayOfMonth;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the day of the month</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the day of the month</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDayOfMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfMonth;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可怕的废话<br>Javadoc也可能是废话。下列Javadoc(摘自某知名开源库)的目的是什么？ 答案：无。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The name. */</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The version */</span></span><br><span class="line"><span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The licenseName */</span></span><br><span class="line"><span class="keyword">private</span> String licenseName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The version. */</span></span><br><span class="line"><span class="keyword">private</span> String info;</span><br></pre></td></tr></table></figure></li>
<li><p>能用函数或变量时就别用注释。体现了要使名称更具表达性，能表达它自身的意图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// does the module from the global list &lt;mod&gt; depend on the</span></span><br><span class="line"><span class="comment">// subsystem we are part of ?</span></span><br><span class="line"><span class="keyword">if</span> (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()))</span><br></pre></td></tr></table></figure>
<p>可以改成以下没有注释的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList moduleDependees = smodule.getDependSubsystems();</span><br><span class="line">String ourSubSystem = subSysMod.getSubSystem();</span><br><span class="line"><span class="keyword">if</span> (moduleDependees.contains(ourSubSystem))</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置标记。#######################################之类的。<br>有时，程序员喜欢在源代码中标记某个特别位置。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Actions &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>括号后面的注释。通过注释来表明这个括号与哪个括号是一对的。<br>有时，程序员会在括号后面放置特殊的注释，尽管这对于含有深度嵌套结构的长函数可能有意义，但只会给我们更愿意编写的短小、封装的函数带来混乱。如果你发现自己想标记右括号，其实应该做的是缩短函数。</p>
</li>
<li><p>归属与署名。同样应该是代码控制系统应该做的事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Added by Rick *&#x2F;</span><br></pre></td></tr></table></figure>
<p>版本控制系统非常善于记住是谁在何时添加了什么。没必要用小小的签名搞脏代码。</p>
</li>
<li><p>注释掉的代码。<br>直接把代码注释掉是讨厌的做法。别这么干！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamResponse response = <span class="keyword">new</span> InputStreamResponse();</span><br><span class="line">resonpse.setBody(formatter.getResultStream(), formatter.getByteCount());</span><br><span class="line"><span class="comment">// InputStream resultsStream = formatter.getResultStream();</span></span><br><span class="line"><span class="comment">// StreamReader reader = new StreamReader(resultStream);</span></span><br><span class="line"><span class="comment">// response.setContent(reader.read(formatter.getByteCount()));</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML注释<br>源码中包含HTML注释让人讨厌，难以阅读。</p>
</li>
<li><p>非本地信息。<br>假如你一定要写注释，请确保它描述了离它最近的代码。别在本地注释的上下文环境中包含出系统级的信息。<br>下面的例子，除了可怕的冗余之外，还包含了系统级的默认端口信息。但是这个函数完全没控制那个所谓的默认值。假如那个值更改了，无法担保这个注释也会跟着修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * port on which fitnesse would run. Default to &lt;b&gt;8082&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fitnessePort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFitnessePort</span><span class="params">(<span class="keyword">int</span> fitnessPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fitnessePort = fitnessePort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息过多<br>别在注释中添加有趣的历史性话题或者无关的细节描述。</p>
</li>
</ul>
<ul>
<li>不明显的联系<br>注释及其描述的代码之间的联系应该是显而易见。如果你不嫌麻烦要写注释，至少让读者能看着注释和代码，并且理解注释所谈何物。</li>
</ul>
<p>注释应该起着辅助的作用，而不应该“喧宾夺主”。好的注释在于提供有用信息、或者方便程序员获取有用信息。而坏的信息在于冗余，甚至是错误，一般它们对提高对系统的认识不会提供任何帮助，反而会分散注意力。</p>
<h1 id="五、格式"><a href="#五、格式" class="headerlink" title="五、格式"></a>五、格式</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><ul>
<li>代码格式关乎沟通，而沟通是开发者的头等大事。</li>
<li>代码风格&amp;可读性影响到可维护性&amp;扩展性。</li>
</ul>
<h2 id="2-垂直格式"><a href="#2-垂直格式" class="headerlink" title="2.垂直格式"></a>2.垂直格式</h2><h3 id="2-1-Java源代码文件有多大？（以如下代码为例，多数为200行，不超过500行）"><a href="#2-1-Java源代码文件有多大？（以如下代码为例，多数为200行，不超过500行）" class="headerlink" title="2.1 Java源代码文件有多大？（以如下代码为例，多数为200行，不超过500行）"></a>2.1 Java源代码文件有多大？（以如下代码为例，多数为200行，不超过500行）</h3><ul>
<li>短文件通常比长文件更容易理解。</li>
</ul>
<h3 id="2-2-垂直方向的区隔（空白行）"><a href="#2-2-垂直方向的区隔（空白行）" class="headerlink" title="2.2 垂直方向的区隔（空白行）"></a>2.2 垂直方向的区隔（空白行）</h3><p>以如下代码为例，每个协程之间，都有空白行隔开。每个空白行都是一条线索，标识出新的独立概念。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;GBASEUP results</span><br><span class="line">go func() &#123;</span><br><span class="line">   res, err :&#x3D; ReqProForResults(fmt.Sprintf(ProUrl, PaasProAddress, GBASE_INDEX_UP))</span><br><span class="line">   upResults &lt;- Ack&#123;Result: res, Error: err&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;GBASEUP results</span><br><span class="line">go func() &#123;</span><br><span class="line">   res, err :&#x3D; ReqProForResults(fmt.Sprintf(ProUrl, PaasProAddress, GBASE_INDEX_NODE_STATUS))</span><br><span class="line">   statusResults &lt;- Ack&#123;Result: res, Error: err&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cluster results</span><br><span class="line">go func() &#123;</span><br><span class="line">   res, err :&#x3D; ReqProForResults(fmt.Sprintf(ProUrl, PaasProAddress, GBASE_INDEX_CLUSTER))</span><br><span class="line">   ClusterResults &lt;- Ack&#123;Result: res, Error: err&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="2-3-垂直方向的靠近"><a href="#2-3-垂直方向的靠近" class="headerlink" title="2.3 垂直方向的靠近"></a>2.3 垂直方向的靠近</h3><p>关系密切的概念应该相互靠近（除非有很好的理由，否则不要把关系密切的概念放到不同的文件中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upResults :&#x3D; make(chan Ack)</span><br><span class="line">statusResults :&#x3D; make(chan Ack)</span><br><span class="line"></span><br><span class="line">ClusterResults :&#x3D; make(chan Ack)</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></table></figure>
<h3 id="2-4-垂直距离"><a href="#2-4-垂直距离" class="headerlink" title="2.4 垂直距离"></a>2.4 垂直距离</h3><ul>
<li>局部变量声明应尽可能靠近其使用位置</li>
<li>实例变量(Java)应在类的顶部声明（设计良好的类中，实例变量至少是被大多数方法使用）</li>
<li>相关函数，存在调用关系或相似操作应放在一起，相关性越强，彼此距离越短</li>
</ul>
<h3 id="2-5-垂直顺序"><a href="#2-5-垂直顺序" class="headerlink" title="2.5 垂直顺序"></a>2.5 垂直顺序</h3><p>自上向下展示函数调用依赖顺序，且调用者尽可能放在被调用者上方。</p>
<h2 id="3-横向格式"><a href="#3-横向格式" class="headerlink" title="3. 横向格式"></a>3. 横向格式</h2><ul>
<li>一行代码应该有多宽？（60个字符以下占70%以上）</li>
<li>尽力保持代码行短小；</li>
<li>遵循无需拖动滚动条到右边的原则。（考虑到显示器越来越宽，推荐上限120个字符）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Map deleteJobs(@PathParam(&quot;jobName&quot;) String jobName,</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-1-水平方向的区隔与靠近"><a href="#3-1-水平方向的区隔与靠近" class="headerlink" title="3.1 水平方向的区隔与靠近"></a>3.1 水平方向的区隔与靠近</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p>乘法因子之间不加空格，加减法用空格隔开，因为加减法优先级较低。（但多数格式化工具都会漠视运算符优先级）</p>
<h3 id="3-2-水平对齐"><a href="#3-2-水平对齐" class="headerlink" title="3.2 水平对齐"></a>3.2 水平对齐</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Resource struct &#123;</span><br><span class="line">   GClusterMem         string  &#96;json:&quot;gclustermem&quot;&#96;</span><br><span class="line">   GNodeMem            string  &#96;json:&quot;gnodemem&quot;&#96;</span><br><span class="line">   SyncServerMem       float64 &#96;json:&quot;syncservermem&quot;&#96;</span><br><span class="line">   NodeCpuPercent      float64 &#96;json:&quot;nodecpupercent&quot;&#96;</span><br><span class="line">   NodeMemPercent      float64 &#96;json:&quot;nodemempercent&quot;&#96;</span><br><span class="line">   NodeDiskUsed        float64 &#96;json:&quot;nodediskused&quot;&#96;</span><br><span class="line">   NodeDiskTotal       float64 &#96;json:&quot;nodedisktotal&quot;&#96;</span><br><span class="line">   NodeDiskUsedPercent float64 &#96;json:&quot;nodediskusedpercent&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-缩进"><a href="#3-3-缩进" class="headerlink" title="3.3 缩进"></a>3.3 缩进</h3><ul>
<li>大多数的类声明不缩进；</li>
<li>类中的方法相对类缩进一个层级；</li>
<li>方法的实现相对方法声明缩进一个层级……</li>
</ul>
<p>//违反缩进规则示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String render() throws Exception &#123;return &quot;&quot;; &#125;</span><br></pre></td></tr></table></figure>
<p>//作者的建议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String render() throws Exception &#123;</span><br><span class="line">	return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-团队规则"><a href="#3-4-团队规则" class="headerlink" title="3.4 团队规则"></a>3.4 团队规则</h3><p>一组开发者应当认同一种格式风格（团队说了算）</p>
<h1 id="六、对象与数据结构"><a href="#六、对象与数据结构" class="headerlink" title="六、对象与数据结构"></a>六、对象与数据结构</h1><p>##　1. 数据抽象<br>当我们构建一个实体类时,会为变量设置为private,再为变量提供set/get方法,想一想为什么要这么做?实际上,即使变量都是私有,我们通过变量的set/get方法操作变量时,实现仍然被曝光了,那为何不直接将变量设置为public,然后直接操作变量呢?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">	double getFuelTankCapacityInGallons();</span><br><span class="line">	double getGallonsOfGasoline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface Vehicle &#123;</span><br><span class="line">	double getPercentFuelRemaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐藏实现关乎抽象！类并不简单地用getter/setter将变量推向外部，而是曝露抽象接口，以便用户无需了解数据的实现就能操作数据本体。傻乐着乱加getter/setter，是最坏的选择。</p>
<h2 id="2-数据、对象的反对称性"><a href="#2-数据、对象的反对称性" class="headerlink" title="2. 数据、对象的反对称性"></a>2. 数据、对象的反对称性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Square &#123;</span><br><span class="line">    public Point topLeft;</span><br><span class="line">    public double side;</span><br><span class="line">&#125;</span><br><span class="line">public class Rectangle &#123;</span><br><span class="line">    public Point topLeft;</span><br><span class="line">    public double height;</span><br><span class="line">    public double width;</span><br><span class="line">&#125;</span><br><span class="line">public class Circle &#123;</span><br><span class="line">    public Point topLeft;</span><br><span class="line">    public double radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Geometry &#123;</span><br><span class="line">    public double PI &#x3D; 3.1415926;</span><br><span class="line">    public double area(Object shape) throws NoSuchShapeException</span><br><span class="line">    &#123;   if(shape instanceof Square) &#123;</span><br><span class="line">            Square s &#x3D; (Square)shape;</span><br><span class="line">            return s.side * s.side;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(shape instanceof Rectangle) &#123;</span><br><span class="line">            Rectangle r &#x3D; (Rectangle)shape;</span><br><span class="line">            return r.width * r.height;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(shape instanceof Circle) &#123;</span><br><span class="line">            Circle c &#x3D; (Circle)shape;</span><br><span class="line">            return PI * c.radius * c.radius;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new NoSuchShapeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑：</p>
<ul>
<li>1.如果给Geometry类添加一个primeter()函数会怎样？（形状类根本不受影响）</li>
<li>2.如果添加一个新形状会怎样？（修改Geometry类中的所有函数）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line">    private Point topLeft;</span><br><span class="line">    private double side;</span><br><span class="line"></span><br><span class="line">    public double area() &#123;</span><br><span class="line">        return side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line">    private Point topLeft;</span><br><span class="line">    private double height;</span><br><span class="line">    private double width;</span><br><span class="line"></span><br><span class="line">    public double area() &#123;</span><br><span class="line">        return height * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    private Point topLeft;</span><br><span class="line">    private double radius;</span><br><span class="line">    public double PI &#x3D; 3.1415926;</span><br><span class="line"></span><br><span class="line">    public double area() &#123;</span><br><span class="line">        return PI * radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>考虑：</p>
<ul>
<li>1.如果添加一个primeter()函数会怎样？（所有形状的类都要做修改）</li>
<li>2.如果添加一个新形状会怎样？（现有的函数不会受到影响）</li>
</ul>
<p><code>总结： 过程式代码难以添加数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。所以需要根据系统不同的需求采取不同的编程策略。</code></p>
<h2 id="3-The-Law-of-Demeter-得墨忒耳定律-迪米特法则"><a href="#3-The-Law-of-Demeter-得墨忒耳定律-迪米特法则" class="headerlink" title="3. The Law of Demeter (得墨忒耳定律/迪米特法则)"></a>3. The Law of Demeter (得墨忒耳定律/迪米特法则)</h2><p>也叫做“最少知识原则”，是一种开发软件的设计原理。指一个对象应当对其他的对象有尽可能少的了解，方法不应调用由任何函数返回的对象的方法。</p>
<p>一个简单例子是，人可以命令一条狗叫，但是不应该直接指挥狗的嘴来叫。应该由狗去指挥控制它的嘴如何叫。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mouth &#123;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(&quot;wang wang!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private Mouth mouth;</span><br><span class="line"></span><br><span class="line">    public Mouth getMouth() &#123;</span><br><span class="line">        return mouth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Human &#123;</span><br><span class="line">    public void command(Dog dog) &#123;</span><br><span class="line">        dog.getMouth().bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Mouth &#123;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(&quot;wang wang!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private Mouth mouth;</span><br><span class="line"></span><br><span class="line">    private Mouth getMouth() &#123;</span><br><span class="line">        return mouth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public void bark() &#123;</span><br><span class="line">		mouth.bark();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Human &#123;</span><br><span class="line">    public void command(Dog dog) &#123;</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p>
<h1 id="七、错误处理"><a href="#七、错误处理" class="headerlink" title="七、错误处理"></a>七、错误处理</h1><p>why：</p>
<blockquote>
<p>简言之，可能会出错，当错误发生时，程序员就有责任确保代码正常工作。</p>
</blockquote>
<hr>
<p>how：</p>
<h2 id="7-1-使用异常而非返回码"><a href="#7-1-使用异常而非返回码" class="headerlink" title="7.1 使用异常而非返回码"></a>7.1 使用异常而非返回码</h2><p>通过返回码指示错误，必需在调用函数或者方法后立即检查错误。而错误检查常常会被遗漏，而导致更严重的错误，如空指针异常等。</p>
<p>正确的做法是遇到错误时抛出异常，然后在调用代码是决定捕获异常。</p>
<p>举个反例，这个代码真心搞不懂在干嘛：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SecHandle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">		log.WithField(<span class="string">&quot;security&quot;</span>, <span class="string">&quot;os auth deliver&quot;</span>).Errorf(<span class="string">&quot;method not allowed : %s&quot;</span>, r.Method)</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">&quot;&#123;\&quot;result\&quot;:\&quot;unknown method : %s\&quot;&#125;&quot;</span>, r.Method)))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buf, err := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.WithField(<span class="string">&quot;security&quot;</span>, <span class="string">&quot;os auth deliver&quot;</span>).Error(<span class="string">&quot;read request body failed, errors: %v&quot;</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;&#123;\&quot;result\&quot;:\&quot;read request body failed\&quot;&#125;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sec Security</span><br><span class="line">	jsonErr := json.Unmarshal(buf, &amp;sec)</span><br><span class="line">	<span class="keyword">if</span> jsonErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.WithField(<span class="string">&quot;security&quot;</span>, <span class="string">&quot;os auth deliver&quot;</span>).Error(<span class="string">&quot;parse request body failed, errors: %v&quot;</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;&#123;\&quot;result\&quot;:\&quot;parse request body failed\&quot;&#125;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	clearPassword, err := base64.StdEncoding.DecodeString(sec.Password)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.WithField(<span class="string">&quot;security&quot;</span>, <span class="string">&quot;os password deliver&quot;</span>).Error(<span class="string">&quot;decode password failed: %v&quot;</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;&#123;\&quot;result\&quot;:\&quot;decode password failed\&quot;&#125;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conf := ssh.ClientConfig&#123;</span><br><span class="line">		User: sec.Username,</span><br><span class="line">		Auth: []ssh.AuthMethod&#123;ssh.Password(<span class="keyword">string</span>(clearPassword))&#125;,</span><br><span class="line">		HostKeyCallback: <span class="function"><span class="keyword">func</span><span class="params">(hostname <span class="keyword">string</span>, remote net.Addr, key ssh.PublicKey)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">		Timeout: time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client, err := ssh.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, sec.IP, <span class="string">&quot;22&quot;</span>), &amp;conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="string">&quot;unable to authenticate&quot;</span>) &#123;</span><br><span class="line">		log.WithField(<span class="string">&quot;security&quot;</span>, <span class="string">&quot;os auth deliver&quot;</span>).</span><br><span class="line">			Errorf(<span class="string">&quot;invalid password or username(%s) for host:%s, error : %v&quot;</span>, sec.Username, sec.IP, err)</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;&#123;\&quot;result\&quot;:\&quot;invalid password/username\&quot;&#125;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">	nodeSecMap.Store(sec.IP, sec)</span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;&#123;\&quot;result\&quot;:\&quot;ok\&quot;&#125;&quot;</span>))</span><br><span class="line">	log.WithField(<span class="string">&quot;security&quot;</span>, <span class="string">&quot;os password deliver&quot;</span>).Warnf(<span class="string">&quot;deliver auth of host:%s successfully&quot;</span>, sec.IP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="7-2-先写try-catch-finally语句"><a href="#7-2-先写try-catch-finally语句" class="headerlink" title="7.2 先写try-catch-finally语句"></a>7.2 先写try-catch-finally语句</h2><p>try-catch-finally语句中的try部分代码是一个随时可以取消的过程，就像是一个事务，通过catch部分接住，将程序维持在一个可以持续运行的状态。</p>
<p><strong><code>try-catch-finally</code>能够帮你定义代码的用户期望什么，无论try代码执行过程如何都一样</strong></p>
<p>如下面的示例, 无论<code>collect(register)</code>方法发生什么，prometheus都能够看到正确的metrics格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CollectorRegistry registry = <span class="keyword">new</span> CollectorRegistry(<span class="keyword">true</span>);</span><br><span class="line">    resp.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">    resp.setContentType(TextFormat.CONTENT_TYPE_004);</span><br><span class="line"></span><br><span class="line">    increaseAndRegisterCounter(registry, totalScraped);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Collector.getCollector().collect(registry);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        increaseAndRegisterCounter(registry, errors);</span><br><span class="line">        logger.error(<span class="string">&quot;scrape gbase metrics failed, cause : &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    setAndRegisterGauge(registry, duration, System.currentTimeMillis() - start);</span><br><span class="line">    logger.warn(<span class="string">&quot;@@@prometheus scrape at &quot;</span> + fullDataStr(start));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-使用不可控异常-unchecked-exception"><a href="#7-3-使用不可控异常-unchecked-exception" class="headerlink" title="7.3 使用不可控异常(unchecked exception)"></a>7.3 使用不可控异常(unchecked exception)</h2><p>可控异常(checked exception)的问题：</p>
<p>使用可控异常违反了开放/闭合原则，如果你在方法中抛出可控异常，而catch语句在多个层级以上，则在catch语句和抛出异常的方法之间每个方法签名上都要声明该可控异常。也就意味着对较低层级的业务逻辑的修改将会波及到高层级的代码。</p>
<h2 id="7-4-给出异常发生的环境说明"><a href="#7-4-给出异常发生的环境说明" class="headerlink" title="7.4 给出异常发生的环境说明"></a>7.4 给出异常发生的环境说明</h2><p>每一个抛出的异常都应该有环境说明，以便判断错误的业务环境。</p>
<p>需要注意的是java的错误栈一般只能够得到堆栈跟踪，以定位到代码，故障定位也需要明确的业务环境。</p>
<h2 id="7-5-依调用者需要定义异常"><a href="#7-5-依调用者需要定义异常" class="headerlink" title="7.5 依调用者需要定义异常"></a>7.5 依调用者需要定义异常</h2><p>异常是用来被捕获的，所以定义异常最需要考虑的是它们如何被捕获，而不应该按照错误来源或者错误类型等来定义异常。</p>
<p>反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ACMEPort port = <span class="keyword">new</span> ACMEPort(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    port.open();</span><br><span class="line">&#125; <span class="keyword">catch</span> (DeviceResponseException e) &#123;</span><br><span class="line">    reportPortError(e);</span><br><span class="line">    logger.log(<span class="string">&quot;Device response exception&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ATM1212UnlockedException e) &#123;</span><br><span class="line">    reportPortError(e);</span><br><span class="line">    logger.log(<span class="string">&quot;Unlocked exception&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (GMXError e) &#123;</span><br><span class="line">    reportPortError(e);</span><br><span class="line">    logger.log(<span class="string">&quot;Device response exception&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalPort port = <span class="keyword">new</span> LocalPort(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    port.open();</span><br><span class="line">&#125; <span class="keyword">catch</span> (PortDeviceFailure e) &#123;</span><br><span class="line">    reportPortError(e);</span><br><span class="line">    logger.log(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalPort</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ACMEPort innerPort;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalPort</span><span class="params">(<span class="keyword">int</span> portNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.innerPort = <span class="keyword">new</span> ACMEPort(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	    innerPort.open();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (DeviceResponseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ATM1212UnlockedException e) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GMXError e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-定义常规流程"><a href="#7-6-定义常规流程" class="headerlink" title="7.6 定义常规流程"></a>7.6 定义常规流程</h2><p>特例模式：</p>
<blockquote>
<p>即创建一个类或者配置一个对象，用来处理特例。</p>
</blockquote>
<p>即通过特例模式处理边界问题，将边缘地带的算法与核心算法分离开来，核心算法不负责异常和边缘检测。</p>
<p>反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MealExpences expences = expencesReportDao.getMaels(employee.getID());</span><br><span class="line">    total += expences.getTotal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MealExpencesNotFoundException e) &#123;</span><br><span class="line">    total += getMaelPerDiem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正例：java 8的Optional。</p>
<h2 id="7-7-别返回null值"><a href="#7-7-别返回null值" class="headerlink" title="7.7 别返回null值"></a>7.7 别返回null值</h2><p>反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Span nodeRoot = findNodeRoot(entry.getValue());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == nodeRoot) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConvertingZipkinSpanException(<span class="string">&quot;root span of endpoint [&quot;</span> + entry.getKey() + <span class="string">&quot;] not found&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以采用Optional.of(‘default_value’)，Collections.emptyList()等方法提到null值。</p>
<h2 id="7-8-别传递null值"><a href="#7-8-别传递null值" class="headerlink" title="7.8 别传递null值"></a>7.8 别传递null值</h2><p>这个比返回null值更糟糕，后果也跟严重。</p>
<p>如果传递了null值，可以使用PreCondition。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SpanBo&gt; <span class="title">getSpans</span><span class="params">(TransactionEventKey key, List&lt;<span class="keyword">byte</span>[]&gt; hBaseFamilyList)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(hBaseFamilyList != <span class="keyword">null</span>, <span class="string">&quot;hbase Family List may not be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Get get = <span class="keyword">new</span> Get(rowKeyDistributor.getDistributedKey(key.getBytes()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hbaseTemplate.get(HBaseTables.TRACES, get, spanMapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-9-小节"><a href="#7-9-小节" class="headerlink" title="7.9 小节"></a>7.9 小节</h2><p>将错误处理独立在主逻辑之外，独立看待。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="java的异常分类"><a href="#java的异常分类" class="headerlink" title="java的异常分类"></a><a href="http://www.importnew.com/26613.html">java的异常分类</a></h3><p><img src="../pics/994bd262fec543853cd99fe680e857cc.png" alt="java Throwable"></p>
<p>checked exception: <code>Error</code>和<code>RuntimeException</code>，编译期间不会提示和发现。</p>
<p>unchecked exception: 除checked exception之外所有Throwable子类，编译期间就能够发现。</p>
<h3 id="java异常的最佳实践"><a href="#java异常的最佳实践" class="headerlink" title="java异常的最佳实践"></a><a href="http://www.importnew.com/26775.html">java异常的最佳实践</a></h3><ul>
<li>在Finally块中清理资源或者使用try-with-resource语句</li>
<li>抛出异常是指定具体的异常，不要抛出Exception，RuntimeException等抽象异常</li>
<li>抛出异常是尽量包含能够定位到较为详细的业务点的描述信息</li>
<li>首先捕获最具体的异常，当有多个catch块中，按照捕获顺序只有第一个匹配到的catch块才能执行</li>
<li>不要捕获Throwable</li>
<li>不要生吞异常，即捕获异常后do nothing</li>
<li>不要记录并抛出异常，会导致记录多次日志</li>
<li>包装异常时不要抛弃原始的异常，定要把原始的异常设置为传入自定义异常，否则，丢失了原始的异常信息会让错误的分析变得困难。</li>
</ul>
<h1 id="八、Boundaries"><a href="#八、Boundaries" class="headerlink" title="八、Boundaries"></a>八、Boundaries</h1><p>Somehow we must integrate foreign code (third-party package or open source code, e.g.) with our own, this chapter we look at practice and tech to keep the boundaries of our software clean.</p>
<h2 id="8-1-Using-Third-Party-Code"><a href="#8-1-Using-Third-Party-Code" class="headerlink" title="8.1 Using Third-Party Code"></a>8.1 Using Third-Party Code</h2><p>Providers strive for broad applicability for wide users, but users always focus on their own needs.</p>
<p>For example, if our application build a <code>java.util.Map</code> object and pass it around, and want none receivers would delete elements of it, but <code>java.util.Map</code> has a <code>clear()</code> method. </p>
<p>We are not suggesting that every use of <code>java.util.Map</code> be encapsulated to passing between third-party code and your own, and also suggesting not to pass <code>java.util.Map</code> instance around your system. If you use a boundary interface like <code>Map</code>, keep it inside the class and ensure it be encapsulated.  Avoid returning it from, or accepting it as an argument to public APIs.</p>
<h2 id="8-2-Exploring-and-Learning-Boundaries"><a href="#8-2-Exploring-and-Learning-Boundaries" class="headerlink" title="8.2 Exploring and Learning Boundaries"></a>8.2 Exploring and Learning Boundaries</h2><p>It may be clear job to write tests for the third-party code we use.we could write some tests to explore our understanding of the third-party code, so called <em>learning tests</em>.</p>
<h2 id="8-3-Learning-log4j"><a href="#8-3-Learning-log4j" class="headerlink" title="8.3 Learning log4j"></a>8.3 Learning <code>log4j</code></h2><blockquote>
<p>coding-&gt; debug -&gt; error -&gt; learning -&gt; coding -&gt; … -&gt; debug -&gt; correct</p>
</blockquote>
<h2 id="8-4-Learning-Tests-Are-Better-Than-Free"><a href="#8-4-Learning-Tests-Are-Better-Than-Free" class="headerlink" title="8.4 Learning Tests Are Better Than Free"></a>8.4 Learning Tests Are Better Than Free</h2><p>The learning tests were precise experiments that helped increase our understanding:</p>
<ul>
<li>The learning tests were precise experiments that helped increase our understanding.</li>
<li>Learning tests verify that the third-party packages we are using work the way we expect them to.</li>
<li>A clean boundary should be supported by a set of outbound tests that exercise the interface the same way the production code does. </li>
</ul>
<h2 id="8-5-Using-Code-That-Does-Not-Yet-Exist"><a href="#8-5-Using-Code-That-Does-Not-Yet-Exist" class="headerlink" title="8.5 Using Code That Does Not Yet Exist"></a>8.5 Using Code That Does Not Yet Exist</h2><p>Why we use code does not exsists?</p>
<ul>
<li>There are often places in the code beyond our knowledge</li>
<li>The other side of the boundary is unknowable</li>
<li>We choose to look no farther than the boundary</li>
</ul>
<p>To keep from being blocked, we defined our own interface we wished. So that the interace is under our control, and  helps keep our own code more readable and focused on what it is trying to accomplish. </p>
<p>If nessary, an adapter should be introduced to interact with API beyond the boundary.</p>
<h2 id="8-6-Clean-Boundaries"><a href="#8-6-Clean-Boundaries" class="headerlink" title="8.6 Clean Boundaries"></a>8.6 Clean Boundaries</h2><p>Boundaries means change is out of control. </p>
<p>When facing boundaries, special care must be taken to protect and make sure future change is not too costly. </p>
<p>So we should avoid letting too much of our code know about the third-party particulars, and make sure our own system depend on our own code. </p>
<p>In order to approch this, manage third-party boundaries by having very few places, wrap them or use an adapter to convert from perfact interface.</p>
<h1 id="九、Unit-Tests"><a href="#九、Unit-Tests" class="headerlink" title="九、Unit Tests"></a>九、Unit Tests</h1><h2 id="9-1-The-Three-Laws-of-TDD"><a href="#9-1-The-Three-Laws-of-TDD" class="headerlink" title="9.1 The Three Laws of TDD"></a>9.1 The Three Laws of TDD</h2><ul>
<li>You may not write production code until you have written a failing unit test.<br>(测试先行，除非写到无法通过的测试，否则不要写生产代码)</li>
<li>You may not write more of a unit test than is sufficient to fail, and not compiling is failing<br>(一旦测试代码失败，就需要停止测试代码的编写，即使是单元测试代码的编译失败)</li>
<li>You may not write more production code than is sufficient to pass the currently failing test.<br>(一旦一个失败的单元测试运行通过，就需要返回测试代码的编写)</li>
</ul>
<h2 id="9-2-Keeping-Tests-Clean"><a href="#9-2-Keeping-Tests-Clean" class="headerlink" title="9.2 Keeping Tests Clean"></a>9.2 Keeping Tests Clean</h2><p>Having dirty tests is equivalent to, if not worse than, having no tests. </p>
<ul>
<li>Where does the problem come from: </li>
</ul>
<p>Tests must change as the production code evolves. From release to release the cost of maintaining team’s test suite rose. In the end they were forced to discard the test suite entirely.</p>
<p>Without a test suite they could not ensure that changes to one part of their system did not break other parts of their system, then the production code begin to rot. It was their decision to allow the tests to be messy that was the seed of that failure.</p>
<p>The condlusion is: test code is just as important as production code. It requires thought, design, and care. It must be kept as clean as production code. </p>
<ul>
<li>The benefits of test code：</li>
</ul>
<p>It is unit tests that keep production code flexible, maintainable, and reusable. If you have tests, you do not fear making changes to the code! The higher your test coverage, the less your fear. Tests enable all the -ilities, because tests enable change.</p>
<h2 id="9-3-Clean-Tests"><a href="#9-3-Clean-Tests" class="headerlink" title="9.3 Clean Tests"></a>9.3 Clean Tests</h2><p>What makes a clean test? Three things. Readability, readability, and readability.<br>What makes tests readable? The same thing that makes all code readable: <strong>clarity, simplicity, and density of expression.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// USER --- A --- v1</span></span><br><span class="line"><span class="comment">//           \</span></span><br><span class="line"><span class="comment">//            \</span></span><br><span class="line"><span class="comment">//             v2</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build_topology_with_one_span_of_two_virtual_node</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    List&lt;SpanBo&gt; spanBos = build_fake_SpanBo_with_two_virtual_node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    Mockito.when(serviceTypeRegistryService.findServiceType((<span class="keyword">short</span>) <span class="number">1002</span>)).thenReturn(<span class="keyword">new</span> MockServiceType(<span class="keyword">true</span>));</span><br><span class="line">    Mockito.when(serviceTypeRegistryService.findServiceType((<span class="keyword">short</span>) <span class="number">1003</span>)).thenReturn(<span class="keyword">new</span> MockServiceType(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    Topology topology = useCase.createTopology(spanBos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    checkNodes(topology.getNodes, <span class="number">4</span>);</span><br><span class="line">    checkLinks(topology.getLinks, <span class="number">3</span>);</span><br><span class="line">    checkDetail(topology);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The BUILD-OPERATE-CHECK pattern is made obvious by the structure of these tests. Every unit test should clearly split into these tree parts:</p>
<ul>
<li>the first part builds up the test data</li>
<li>the second part operates on that test data</li>
<li>the third part checks that the operation yielded the expected results.</li>
</ul>
<h3 id="9-3-1-Domain-Specific-Testing-Language"><a href="#9-3-1-Domain-Specific-Testing-Language" class="headerlink" title="9.3.1 Domain-Specific Testing Language"></a>9.3.1 Domain-Specific Testing Language</h3><p>Rather than using the APIs that programmers use to manipulate the system, we build up a set of functions and utilities that make use of those APIs and that make the tests more convenient to write and easier to read. These functions and utilities become a specialized API used by the tests. They are a testing language that programmers use to help themselves to write their tests and to help those who must read those tests later. Such as <code>checkNodes()</code> and <code>checkLinks()</code>.</p>
<h3 id="9-3-2-A-Dual-Standard"><a href="#9-3-2-A-Dual-Standard" class="headerlink" title="9.3.2 A Dual Standard"></a>9.3.2 A Dual Standard</h3><p>The code within the testing API does have a different standard than production code. It must still be <strong>simple, succinct(简洁), and expressive(富有表达力), but it need not be as efficient as production code</strong>.</p>
<p>There are things that you might never do in a production environment that are perfectly fine in a test environment.</p>
<h2 id="9-4-One-Assert-per-Test"><a href="#9-4-One-Assert-per-Test" class="headerlink" title="9.4 One Assert per Test"></a>9.4 One Assert per Test</h2><p>There is a school(流派) of thought that says every test function in a JUnit test should have one and only one assert statement.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPageHierarchyAsXml</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    givenPages(<span class="string">&quot;PageOne&quot;</span>, <span class="string">&quot;PageOne.ChildOne&quot;</span>, <span class="string">&quot;PageTwo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    whenRequestIsIssued(<span class="string">&quot;root&quot;</span>, <span class="string">&quot;type:pages&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thenResponseShouldBeXML();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPageHierarchyHasRightTags</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    givenPages(<span class="string">&quot;PageOne&quot;</span>, <span class="string">&quot;PageOne.ChildOne&quot;</span>, <span class="string">&quot;PageTwo&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    whenRequestIsIssued(<span class="string">&quot;root&quot;</span>, <span class="string">&quot;type:pages&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    thenResponseShouldContain(</span><br><span class="line">        <span class="string">&quot;&lt;name&gt;PageOne&lt;/name&gt;&quot;</span>, <span class="string">&quot;&lt;name&gt;PageTwo&lt;/name&gt;&quot;</span>, <span class="string">&quot;&lt;name&gt;ChildOne&lt;/name&gt;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can use the TEMPLATE METHOD pattern and putting the given/when parts in the base class, and the then parts in different derivatives. Or we could create a completely separate test class and put the given and when parts in the <code>@Before</code> function. </p>
<p>The auther thinks that single assert rule is a good guideline, the best thing we can say is that the number of asserts in a test ought to be minimized.</p>
<h3 id="9-4-1-Single-Concept-per-Test"><a href="#9-4-1-Single-Concept-per-Test" class="headerlink" title="9.4.1 Single Concept per Test"></a>9.4.1 Single Concept per Test</h3><p>A better rule is that we want to test a single concept in each test function. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Miscellaneous tests for the addMonths() method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddMonths</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SerialDate d1 = SerialDate.createInstance(<span class="number">31</span>, <span class="number">5</span>, <span class="number">2004</span>);</span><br><span class="line">    </span><br><span class="line">    SerialDate d2 = SerialDate.addMonths(<span class="number">1</span>, d1);</span><br><span class="line">    assertEquals(<span class="number">30</span>, d2.getDayOfMonth());</span><br><span class="line">    assertEquals(<span class="number">6</span>, d2.getMonth());</span><br><span class="line">    assertEquals(<span class="number">2004</span>, d2.getYYYY());</span><br><span class="line">    </span><br><span class="line">    SerialDate d3 = SerialDate.addMonths(<span class="number">2</span>, d1);</span><br><span class="line">    assertEquals(<span class="number">31</span>, d3.getDayOfMonth());</span><br><span class="line">    assertEquals(<span class="number">7</span>, d3.getMonth());</span><br><span class="line">    assertEquals(<span class="number">2004</span>, d3.getYYYY());</span><br><span class="line">    </span><br><span class="line">    SerialDate d4 = SerialDate.addMonths(<span class="number">1</span>, SerialDate.addMonths(<span class="number">1</span>, d1));</span><br><span class="line">    assertEquals(<span class="number">30</span>, d4.getDayOfMonth());</span><br><span class="line">    assertEquals(<span class="number">7</span>, d4.getMonth());</span><br><span class="line">    assertEquals(<span class="number">2004</span>, d4.getYYYY());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So probably the best rule is that one should minimize the number of asserts per concept and test just one concept per test function.</p>
<h2 id="9-5-F-I-R-S-T"><a href="#9-5-F-I-R-S-T" class="headerlink" title="9.5 F.I.R.S.T."></a>9.5 F.I.R.S.T.</h2><ul>
<li><strong>Fast</strong> Tests should be fast. </li>
<li><strong>Independent</strong> Tests should not depend on each other. </li>
<li><strong>Repeatable</strong> Tests should be repeatable in any environment.</li>
<li><strong>Self-Validating</strong> The tests should have a boolean output.</li>
<li><strong>Timely</strong> The tests need to be written in a timely fashion.</li>
</ul>
<h2 id="9-6-Conclusion"><a href="#9-6-Conclusion" class="headerlink" title="9.6 Conclusion"></a>9.6 Conclusion</h2><p>Tests are as important to the health of a project as the production code is. Perhaps they are even more important, because tests preserve and enhance the flexibility, maintainability, and reusability of the production code. </p>
<p>Keep your tests clean.</p>
<h1 id="十、Classes"><a href="#十、Classes" class="headerlink" title="十、Classes"></a>十、Classes</h1><h2 id="10-1-类的组织"><a href="#10-1-类的组织" class="headerlink" title="10.1 类的组织"></a>10.1 类的组织</h2><ul>
<li>类应该从一组变量的列表开始</li>
<li>公有静态变量应该放在前面，然后是私有静态变量，以及私有实例变量，很少有公有实例变量</li>
<li>公有方法应该在变量列表之后</li>
<li>私有工具方法放在其调用者之后</li>
<li>尽量保证变量和方法的私有性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipkinSpanAsyncConsumer</span> <span class="keyword">implements</span> <span class="title">StorageAdapters</span>.<span class="title">SpanConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> WAIT_TIME = <span class="number">30L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ZIPKIN_AGENT = <span class="string">&quot;zipkin_agent&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ZipkinSpanAsyncConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;collector.zipkin.aysncWorker.queue.size:10240&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> zipkinWorkerQueueSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ZipkinTraceDao zipkinTraceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;zipkinTraceEventConsumer&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> EventConsumer consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransactionEventCache&lt;TransactionEventKey, TransactionEventValue&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor workers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="keyword">this</span>.zipkinWorkerQueueSize);</span><br><span class="line">        <span class="keyword">this</span>.workers = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">this</span>.blockingQueue,</span><br><span class="line">                <span class="keyword">new</span> PinpointThreadFactory(<span class="string">&quot;zipkin async worker&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Executors.newSingleThreadScheduledExecutor()</span><br><span class="line">                .scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;zipkin async workers queue size: [&#123;&#125;]&quot;</span>, <span class="keyword">this</span>.blockingQueue.size());</span><br><span class="line">                &#125;, ONE_MINUTE_MS, ONE_MINUTE_MS, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(List&lt;Span&gt; spans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Span span : spans) &#123;</span><br><span class="line">            workers.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 1), insert zipkin span to temporary table</span></span><br><span class="line">                zipkinTraceDao.insert(span);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2), put root span into eventBus</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == span.parentId) &#123;</span><br><span class="line">                    putToEventBus(span);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putToEventBus</span><span class="params">(Span span)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == cache) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> TransactionEventCache&lt;&gt;(consumer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Optional&lt;Long&gt; acceptTime = Optional.ofNullable(span.timestamp);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        TransactionEventKey key = <span class="keyword">new</span> TransactionEventKey(ZIPKIN_AGENT, acceptTime.orElse(localTime), span.traceId);</span><br><span class="line">        TransactionEventValue value = <span class="keyword">new</span> TransactionEventValue(key, ZIPKIN_AGENT, acceptTime.orElse(localTime));</span><br><span class="line">        cache.put(key, value, WAIT_TIME, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2-类应该短小"><a href="#10-2-类应该短小" class="headerlink" title="10.2 类应该短小"></a>10.2 类应该短小</h2><p>关于类的第一条规则应该是短小。</p>
<p>类名应当描述其权责，如<code>ZipkinSpanAsyncConsumer</code>。如果您感到无法为某个类命名，说明它还是太大。此外类名越含糊，说明其职责越不明确，如带有processor，manager等的类。</p>
<h3 id="10-2-1-单一权责原则"><a href="#10-2-1-单一权责原则" class="headerlink" title="10.2.1 单一权责原则"></a>10.2.1 单一权责原则</h3><p>内容： 类或者模块应该有且只有一条被修改的理由。</p>
<p>单一职责原则是OO设计中最为重要的概念之一，但是也是最容易被破坏的类的设计原则。下面的示例就是一个职责过多的类：</p>
<p><img src="../pics/2018-10-26_085430.png" alt="一个权责过多的类"></p>
<p>OO的目标之一：系统应该由很多短小的类而不是少量巨大的类组成，每个类都封装者一个权责，并且只有一个被修改的原因，并与少数其他类一起协作达成期望的系统行为。</p>
<h3 id="10-2-2-内聚"><a href="#10-2-2-内聚" class="headerlink" title="10.2.2 内聚"></a>10.2.2 内聚</h3><p>类应该只有少量的实例变量。类中的每一个方法都应该操作一个或者多个实例变量。如果类中的每一个变量都被每一个方法所使用，这个类就拥有最大的内聚性。内聚性高意味着类中的方法和变量。</p>
<p>内聚性高意味着类中的方法和变量相互依、相互结合成的一个逻辑整体。如果有时候需要为一组子集方法而增加实例变量的时候，就可以将这些实例和变量拆分到新的类里，以便让类更加聚合。</p>
<h3 id="10-2-3-保存内聚性就会得到许多短小的类"><a href="#10-2-3-保存内聚性就会得到许多短小的类" class="headerlink" title="10.2.3 保存内聚性就会得到许多短小的类"></a>10.2.3 保存内聚性就会得到许多短小的类</h3><h2 id="10-3-为了修改而组织"><a href="#10-3-为了修改而组织" class="headerlink" title="10.3 为了修改而组织"></a>10.3 为了修改而组织</h2><p>对于多数系统，修改将一直持续。</p>
<p>如果类中出现了只与一小部分功能有关的私有方法，意味着存在改进的空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sql</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sql</span><span class="params">(String table, Column[] columns)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">insert</span><span class="params">(Object[] fields)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">selectAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">findByKey</span><span class="params">(String keyColumn, String keyValue)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">select</span><span class="params">(Column column, String pattern)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">select</span><span class="params">(Criteria criteria)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">preparedInsert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> String <span class="title">columnList</span><span class="params">(Column[] columns)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> String <span class="title">valuesList</span><span class="params">(Object[] fields, <span class="keyword">final</span> Column[] columns)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> String <span class="title">selectWithCriteria</span><span class="params">(String criteria)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> String <span class="title">placeholderList</span><span class="params">(Column[] columns)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重构后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sql</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sql</span><span class="params">(String table, Column[] columns)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateSql</span> <span class="keyword">extends</span> <span class="title">Sql</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateSql</span><span class="params">(String table, Column[] columns)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class SelectSql extends Sql </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectSql</span><span class="params">(String table, Column[] columns)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class InsertSql extends Sql </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsertSql</span><span class="params">(String table, Column[] columns, Object[] fields)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> String <span class="title">valuesList</span><span class="params">(Object[] fields, <span class="keyword">final</span> Column[] columns)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class SelectWithCriteriaSql extends Sql </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectWithCriteriaSql</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String table, Column[] columns, Criteria criteria)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class SelectWithMatchSql extends Sql </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectWithMatchSql</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String table, Column[] columns, Column column, String pattern)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FindByKeySql extends Sql</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">FindByKeySql</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String table, Column[] columns, String keyColumn, String keyValue)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class PreparedInsertSql extends Sql </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PreparedInsertSql</span><span class="params">(String table, Column[] columns)</span></span></span><br><span class="line"><span class="function">    @Override </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">placeholderList</span><span class="params">(Column[] columns)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Where </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Where</span><span class="params">(String criteria)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class ColumnList </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColumnList</span><span class="params">(Column[] columns)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的示例，通过子类化的手段，是的重构后的Sql类对于新功能开放，而不是修改原来繁杂的Sql类。<br>重构后的Sql支持了面向对象的开放-闭合原则：<strong>类应该对扩展开放，对修改闭合</strong>。</p>
<hr>
<h1 id="十一、系统"><a href="#十一、系统" class="headerlink" title="十一、系统"></a>十一、系统</h1><h2 id="待补充"><a href="#待补充" class="headerlink" title="* 待补充 *"></a><strong>* 待补充 *</strong></h2><h1 id="十二、迭进"><a href="#十二、迭进" class="headerlink" title="十二、迭进"></a>十二、迭进</h1><p>通过迭进设计达到整洁目的<br>简单设计的四条规则：</p>
<h2 id="12-1-运行所有测试"><a href="#12-1-运行所有测试" class="headerlink" title="12.1  运行所有测试"></a>12.1  运行所有测试</h2><ul>
<li> 只要系统可测试，就会导向保持类短小而且目的单一的设计方案。</li>
<li> 遵循SRP(单一职责原则）的类，测试起来较为简单。</li>
<li> 测试编写的越多，就越能持续走向编写较易测试的业务代码。</li>
<li> 确保系统完全可测试能帮助我们创建更好的设计。</li>
<li> 紧耦合的代码难以编写测试，编写测试越多，就越会遵循DIP（依赖倒置原则）之类规则，使用依赖注入，接口和抽象等工具尽可能减少耦合，系统就会更贴近OO低耦合度，高内聚度的目标。</li>
<li> 编写测试导致更好的设计。</li>
</ul>
<h2 id="12-2-不可重复"><a href="#12-2-不可重复" class="headerlink" title="12.2 不可重复"></a>12.2 不可重复</h2><ul>
<li>重复是拥有良好设计系统的大敌。</li>
<li>要想创建整洁的系统，需要有消除重复的意愿。</li>
<li>模板方法模式一种移除高层级重复的通用技巧。</li>
</ul>
<h2 id="12-3-表达了程序员的意图"><a href="#12-3-表达了程序员的意图" class="headerlink" title="12.3 表达了程序员的意图"></a>12.3 表达了程序员的意图</h2><ul>
<li><p>软件项目的主要成本在于长期维护。</p>
</li>
<li><p>提高表达力的方法：</p>
<ul>
<li>选用好类名和好函数名  保存类和函数的尺寸短小    </li>
<li>采用标准命名法来表达（COMMAND / VISITOR）  </li>
<li>编写良好的单元测试（测试的主要目的之一就是通过实例起到文档的作用，读到测试的人应该能很快理解某个类是做什么的）</li>
</ul>
</li>
<li><p>尊重自己的手艺，用心是最珍贵的资源。</p>
</li>
<li><p>个人理解：对代码要有敬畏心。</p>
</li>
</ul>
<h2 id="12-4-尽可能减少类和方法的数量"><a href="#12-4-尽可能减少类和方法的数量" class="headerlink" title="12.4 尽可能减少类和方法的数量"></a>12.4 尽可能减少类和方法的数量</h2><ul>
<li>为了保持类和函数短小，我们可能会创造出太多的细小类和方法。</li>
<li>类和方法的数量太多，有时是由毫无意义的教条主义导致的。</li>
<li>我们的目标是在保持函数和类短小的同时，保持整个系统的短小精悍。</li>
</ul>
]]></content>
      <tags>
        <tag>refactor</tag>
        <tag>clean_code</tag>
      </tags>
  </entry>
  <entry>
    <title>Go patterns!</title>
    <url>/2019/07/13/golang/2019-07-13-patterns/</url>
    <content><![CDATA[<a id="more"></a>

<p>The Design pattern represents the best practice and is typically adopted by experienced object-oriented software developers. Design patterns are solutions to the general problems that software developers face during software development. These solutions are summarized by many software developers after a long period of trial and error.</p>
<table border="0">
 <tr>
   <th>类别</th>
   <th>名称</th>
   <th>描述</th>
 </tr>
 <tr>
   <th rowspan="6">创建型</th>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/00_simple-factory">简单工厂模式</a></td>
   <td>非23种GoF设计模式</br>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/01_factory-method">工厂方法模式</a></td>
   <td>工厂方法模式定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/02_abstract-factory">抽象工厂模式</a></td>
   <td>抽象工厂模式是围绕一个超级工厂创建其他工厂.该超级工厂又称为其他工厂的工厂,它提供了一种创建对象的最佳方式</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/03_builder">建造者模式</a></td>
   <td>建造者模式用于封装对象的构造逻辑,它通常在物体的构造过程复杂时使用,这些模式非常适合构建同一类的不同表示</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/04_prototype">原型模式</a></td>
   <td>原型模式用于创建重复的对象，同时又能保证性能，它提供了一种创建对象的最佳方式</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/05_singleton">单例模式</a></td>
   <td>单例模式是最简单的设计模式之一,这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式</td>
 </tr>

 <tr>
  <th rowspan="7">结构型</th>
  <td><a href="https://github.com/qianguodong/go-patterns/tree/master/06_adapter">适配器模式</a></td>
  <td>适配器模式是作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能，就像读卡器作为适配器连接内存卡和笔记本</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/07_bridge">桥接模式</a></td>
   <td>桥接用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/08_composite">组合模式</a></td>
   <td>将对象组合成树形结构以表示“部分整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/09_decorator">装饰器模式</a></td>
   <td>装饰器模式，顾名思义，就是对已经存在的某些类进行装饰，以此来扩展一些功能</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/10_facade">外观模式</a></td>
   <td>外观模式它通过引入一个外观角色来简化客户端与子系统之间的交互<br>
   为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/11_flyweight">享元模式</a></td>
   <td>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/12_proxy">代理模式</a></td>
   <td>代理模式就是多一个代理类出来，替原对象进行一些操作</td>
 </tr>


  <tr>
  <th rowspan="11">行为型</th>
  <td><a href="https://github.com/qianguodong/go-patterns/tree/master/13_chain-of-responsibility">责任链模式</a></td>
  <td>责任链模式是对象的行为模式。使多个对象都有机会处理请求，从而避免请求的发送者和接受者直接的耦合关系</td>
 </tr>
 <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/14_command">命令模式</a></td>
   <td>命令模式是将一个请求封装为一个对象,从而使我们可用不同的请求对客户进行参数化;<br>
   对请求排队或者记录请求日志,以及支持可撤销的操作.命令模式是一种对象行为型模式,其别名为动作模式或事务模式</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/15_interpreter">解释器模式</a></td>
   <td>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/16_iterator">迭代器模式</a></td>
   <td>用于顺序访问集合对象的元素，不需要知道集合对象的底层表示</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/17_mediator">中介者模式</a></td>
   <td>用一个中介对象来封装一系列的对象交互。中介者使得各个对象之间不需要显式地相互引用，从而使其耦合松散，<br>
   而且可以独立的改变他们之间的交互</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/18_memento">备忘录模式</a></td>
   <td>备忘录模式也称之为 备份-恢复 模式，在不破环封装行性的前提下，捕获一个对象的内部状态，<br>
   并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/19_observer">观察者模式</a></td>
   <td>在生活实际中，我们经常会遇到关注一个事物数据变化的情况，例如生活中的温度记录仪，<br>
   当温度变化时，我们观察它温度变化的曲线，温度记录日志等。对于这一类问题，很接近java设计模式里面的“观察者模式”，<br>
   它适合解决多种对象跟踪一个对象数据变化的程序结构问题</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/20_state">状态模式</a></td>
   <td>状态模式是对象的行为模式。状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/21_strategy">策略模式</a></td>
   <td>策略模式定义了一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/22_template-method">模版方法模式</a></td>
   <td>定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤</td>
 </tr>
  <tr>
   <td><a href="https://github.com/qianguodong/go-patterns/tree/master/23_visitor">访问者模式</a></td>
   <td>访问者模式是指封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</td>
 </tr>
</table>

<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>工厂方法模式是Golang中最常用的设计模式之一，属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个用于创建对象的工厂，根据不同的接收条件具体实例化相应的工作类。</p>
<h3 id="工厂方法模式三要素"><a href="#工厂方法模式三要素" class="headerlink" title="工厂方法模式三要素"></a>工厂方法模式三要素</h3><ul>
<li><strong>产品接口(Arithmetic)</strong> 定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Arithmetic <span class="keyword">interface</span> &#123;</span><br><span class="line">	Calculate(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>产品实现(Add/Sub/Mul/Div)</strong> 产品接口的具体实现类，不同的产品也需要不同的产品实现类，产品实现类与功能创建类相对应<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Add <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Add)</span> <span class="title">Calculate</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> left + right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>工厂实现(Factory)</strong> 决定如何实例化产品，是实现扩展的途径，与调用者直接交互用来提供产品的创建。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factory</span><span class="params">(operation <span class="keyword">string</span>)</span> <span class="title">Arithmetic</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span>  operation &#123;</span><br><span class="line">	<span class="keyword">case</span> add:</span><br><span class="line">		<span class="keyword">return</span> &amp;Add&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> sub:</span><br><span class="line">		<span class="keyword">return</span> &amp;Sub&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> mul:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(Mul)</span><br><span class="line">	<span class="keyword">case</span> div:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(Div)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;invalid operation&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂。</li>
<li>使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li>
</ol>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
<h3 id="抽象工厂模式四要素"><a href="#抽象工厂模式四要素" class="headerlink" title="抽象工厂模式四要素"></a>抽象工厂模式四要素</h3><ul>
<li><strong>产品接口(Driver)</strong> 定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mysql  = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">	oracle = <span class="string">&quot;oracle&quot;</span></span><br><span class="line">	sqlite = <span class="string">&quot;sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">	Registry(name <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>产品实现(Mysql/Oracle/Sqlite)</strong> 产品接口的具体实现类，不同的产品也需要不同的产品实现类，产品实现类与功能创建类相对应。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mysql <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mysql)</span> <span class="title">Registry</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;registry %s driver with: %s&quot;</span>, mysql, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Oracle <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Oracle)</span> <span class="title">Registry</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;registry %s driver with: %s&quot;</span>, oracle, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sqlite <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sqlite)</span> <span class="title">Registry</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;registry %s driver with: %s&quot;</span>, sqlite, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>工厂接口(AbstractFactory)</strong> 工厂方法模式的核心，与调用者直接交互用来提供产品的创建。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	Create() Driver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工厂实现(MysqlFactory/OracleFactory/SqliteFactory)</strong> 决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就有多少个具体的工厂实现类，每个工厂实现类负责创建一种产品。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MysqlFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MysqlFactory)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">Driver</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(Mysql)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OracleFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *OracleFactory)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">Driver</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(Oracle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SqliteFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SqliteFactory)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">Driver</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(Sqlite)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>每增加一个产品就增加一个对应的工厂来创建它，这样整个工厂和产品体系都没有什么变化，而只是扩展的变化，这就完全符合开放-封闭的原则了</li>
<li>严格遵循面向对象类的设计原则，比如单一职能原则、开-闭原则、依赖倒置原则、迪米特原则。</li>
<li>业务实现解耦: 抽象工厂是静态工厂方法的进一步抽象与推广，由于使用了多态性，抽象工厂模式保持了静态工厂方法的优点同时又克服了它的缺点，不过抽象工厂模式自己的缺点是每加一个产品都需要增加一个工厂类，增加了大量的开发工作量。</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</li>
</ol>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>建造者模式是一种创建设计模式，用于封装对象的构造逻辑。 它通常在物体的构造过程复杂时使用。 这些模式非常适合构建同一类的不同表示。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>将复杂对象的构造与其表示分开，以便相同的构造过程可以创建不同的表示。</li>
<li>一种常见的软件创建设计模式，用于封装对象的构造逻辑。</li>
</ul>
<h3 id="涉及角色"><a href="#涉及角色" class="headerlink" title="涉及角色"></a>涉及角色</h3><ul>
<li>Builder（抽象建造者):给出一个抽象结论，以规范产品对象的各个组成成分的建造这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建。</li>
<li>ConcreteBuilder（具体建造者）：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。在构造过程完成后，提供产品的实例。</li>
<li>Director（指导者）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li>
<li>Product（产品类）：要创建的复杂对象。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="1-优点："><a href="#1-优点：" class="headerlink" title="1.优点："></a>1.优点：</h4><ul>
<li>建造者独立，易于扩展</li>
<li>便于控制细节风险</li>
</ul>
<h4 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2.缺点："></a>2.缺点：</h4><ul>
<li>产品必须有共同点，范围有限制</li>
<li>如果内部变化复杂，将会有很多的建造类</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>需要生成的对象具有复杂的内部结构</li>
<li>需要生成的对象内部属性本身相互依赖</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="1-产品类：Person"><a href="#1-产品类：Person" class="headerlink" title="1. 产品类：Person"></a>1. 产品类：Person</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  p.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  p.Age = age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-建造者接口：-Builder"><a href="#2-建造者接口：-Builder" class="headerlink" title="2. 建造者接口： Builder"></a>2. 建造者接口： Builder</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span>&#123;</span><br><span class="line">  BuilderName(<span class="keyword">string</span>) Builder</span><br><span class="line">  BuilderAge(<span class="keyword">int</span>) Builder</span><br><span class="line">  Build() *Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-具体建造者：-PersonBuilder"><a href="#3-具体建造者：-PersonBuilder" class="headerlink" title="3. 具体建造者： PersonBuilder"></a>3. 具体建造者： PersonBuilder</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonBuilder <span class="keyword">struct</span>&#123;</span><br><span class="line">  person *Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonBuilder)</span> <span class="title">BuilderName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> p.person == <span class="literal">nil</span>&#123;</span><br><span class="line">    p.person = &amp;Person&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p.person.SetName(name)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonBuilder)</span> <span class="title">BuilderAge</span><span class="params">(age <span class="keyword">int</span>)</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> p.person == <span class="literal">nil</span>&#123;</span><br><span class="line">    p.person = &amp;Person&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p.person.SetAge(age)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonBuilder)</span> <span class="title">Build</span><span class="params">()</span> *<span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-指导者：Director"><a href="#4-指导者：Director" class="headerlink" title="4. 指导者：Director"></a>4. 指导者：Director</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span>&#123;</span><br><span class="line">  builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.Builder.BuilderName(name).BuilderAge(age).Build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> builder Builder = &amp;PersonBuilder&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> director *Director = &amp;Director&#123;builder: builder&#125;</span><br><span class="line">  <span class="keyword">var</span> person *Person = director.Create(<span class="string">&quot;jack&quot;</span>,<span class="number">60</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;builder person:&quot;</span>,person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单例对象的类必须保证只有一个实例存在，并且全局有唯一的接口访问。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>懒汉方式：指全局的单例实例在第一次被使用时构建。</li>
<li>饿汉方式：指全局的单例实例在类装载时构建。</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="1-懒汉方式"><a href="#1-懒汉方式" class="headerlink" title="1. 懒汉方式"></a>1. 懒汉方式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ins *singleton</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIns</span><span class="params">()</span> *<span class="title">singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ins == <span class="literal">nil</span>&#123;</span><br><span class="line">      ins = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：非线程安全，当正在创建时，有线程来访问此时ins==nil就会再创建，单例类就会有多个实例了。</p>
<h4 id="2-饿汉方式"><a href="#2-饿汉方式" class="headerlink" title="2. 饿汉方式"></a>2. 饿汉方式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ins *singleton = &amp;singleton&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIns</span><span class="params">()</span> *<span class="title">singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：如果singleton创建初始化比较复杂耗时时，加载时间会延长。</p>
<h4 id="3-懒汉加锁"><a href="#3-懒汉加锁" class="headerlink" title="3. 懒汉加锁"></a>3. 懒汉加锁</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ins *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIns</span><span class="params">()</span> *<span class="title">singleton</span></span>&#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">if</span> ins == <span class="literal">nil</span> &#123;</span><br><span class="line">      ins = &amp;singleton&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：虽然解决并发的问题，但每次加锁是要付出代价的</p>
<h4 id="4-双重锁"><a href="#4-双重锁" class="headerlink" title="4. 双重锁"></a>4. 双重锁</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ins *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIns</span><span class="params">()</span> *<span class="title">singleton</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ins == <span class="literal">nil</span> &#123;</span><br><span class="line">      mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">      <span class="keyword">if</span> ins == <span class="literal">nil</span> &#123;</span><br><span class="line">         ins = &amp;singleton&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>避免了每次加锁，提高代码效率</p>
<h4 id="5-sync-Once实现"><a href="#5-sync-Once实现" class="headerlink" title="5. sync.Once实现"></a>5. sync.Once实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ins *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIns</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">  once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ins = &amp;singleton&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>原型模式用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。当直接创建对象的代价比较大时，则采用这种模式。<br>例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol>
<li>性能提高。</li>
<li>逃避构造函数的约束。</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li>
<li>必须实现 Cloneable 接口。</li>
<li>逃避构造函数的约束。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>资源优化场景。</li>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景。</li>
<li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景。</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。</li>
</ol>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span> <span class="title">Clone</span><span class="params">()</span> *<span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Person&#123;Name:p.Name, Age:p.Age&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口转换为客户希望的另一个接口，适配器模式使得由于接口不兼容不能一起工作的类可以一起工作</p>
<h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>适配器模式是作为两个不兼容的接口之间的桥梁，这种设计模式属于结构型模式，他结合了两个独立接口的功能。就像读卡器作为适配器连接内存卡和笔记本。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>主要解决软件系统中，将“现存的对象”放到新的环境中，而新环境要求的接口是现阶段不能满足的。<br>适配器继承或依赖已有的对象，实现想要的目标接口，在我们有动机的修改一个正常运行的系统接口时，这时候考虑使用适配器模式，它不是在详细设计时添加的，而是解决正在服役的项目。</p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>UserInterface：目标角色——目标接口，系统所期待实现的目标。</li>
<li>UserInfo：源角色——当前已经存在的原有的实现类，即将被适配的类。</li>
<li>UserAdapter：适配器角色——将原有实现装换为目标接口的实现。   </li>
</ul>
<p>简单点说，适配器模式是指：定义一个类，将一个已经存在的类，转换成目标接口所期望的行为形式。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>如果它走起来像只鸭子，叫起来像只鸭子，那么它可能是一只包装了鸭子适配器的火鸡<br>假设缺少鸭子对象，想用一些火鸡对象来冒充，显而易见火鸡的接口不同，需要写个适配器</p>
<h4 id="1-鸭子接口-目标接口"><a href="#1-鸭子接口-目标接口" class="headerlink" title="1. 鸭子接口 (目标接口)"></a>1. 鸭子接口 (目标接口)</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//鸭子Duck接口，具备呱呱叫和飞行的能力</span></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">    quack() <span class="comment">//呱呱叫</span></span><br><span class="line">    fly()   <span class="comment">//飞行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-火鸡接口-源角色接口"><a href="#2-火鸡接口-源角色接口" class="headerlink" title="2. 火鸡接口 (源角色接口)"></a>2. 火鸡接口 (源角色接口)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Turkey <span class="keyword">interface</span> &#123;</span><br><span class="line">    gobble() <span class="comment">//火鸡不会呱呱叫，只会咯咯叫（gobble）</span></span><br><span class="line">    fly()    <span class="comment">//火鸡也会飞，虽然飞不远</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-火鸡实现类-（源角色实现类）"><a href="#3-火鸡实现类-（源角色实现类）" class="headerlink" title="3. 火鸡实现类 （源角色实现类）"></a>3. 火鸡实现类 （源角色实现类）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WildTurkey <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*WildTurkey)</span> <span class="title">gobble</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Gobble...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*WildTurkey)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I&#x27;m flying a short distance&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-适配器-（适配器角色：）"><a href="#4-适配器-（适配器角色：）" class="headerlink" title="4. 适配器 （适配器角色：）"></a>4. 适配器 （适配器角色：）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义火鸡适配器，用来适配火鸡到鸭子的转换功能，里面需要持有火鸡的句柄</span></span><br><span class="line"><span class="keyword">type</span> TurkeyAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    turkey  Turkey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接着，需要取得适配的对象引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTurkeyAdapter</span><span class="params">(turkey Turkey)</span> *<span class="title">TurkeyAdapter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;TurkeyAdapter&#123; turkey &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要将火鸡的gobble()方法，适配转化成鸭子的quack()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TurkeyAdapter)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.turkey.gobble()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-调用"><a href="#5-调用" class="headerlink" title="5. 调用"></a>5. 调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目前只有火鸡，没有鸭子，通过适配器转化，用火鸡代替鸭子的功能</span></span><br><span class="line">turkey := &amp;WildTurkey&#123;&#125;</span><br><span class="line">turkeyAdapter := NewTurkeyAdapter(turkey)</span><br><span class="line"><span class="comment">//原来火鸡的功能</span></span><br><span class="line">turkey.gobble()</span><br><span class="line">turkey.fly()</span><br><span class="line"><span class="comment">//通过适配器转化之后，火鸡有了鸭子的quack()功能</span></span><br><span class="line">turkeyAdapter.quack()</span><br></pre></td></tr></table></figure>


<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>装饰器模式，顾名思义，就是对已经存在的某些类进行装饰，以此来扩展一些功能。</p>
<h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul>
<li>抽象组件（Component）：需要装饰的抽象对象。</li>
<li>具体组件（ConcreteComponent）：是我们需要装饰的对象</li>
<li>抽象装饰类（Decorator）：内含指向抽象组件的引用及装饰者共有的方法。</li>
<li>具体装饰类（ConcreteDecorator）：被装饰的对象。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要扩展一个类的功能。</li>
<li>动态的为一个对象增加功能，而且还能动态撤销(继承不能做到这一点，继承的功能是静态的，不能动态增删)</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>产生过多相似的对象，不易排错！</li>
</ul>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>给房屋的每一处装修无非是为了给房子添加一个功能,或者为了好看,或者为了实用,而装饰器模式也是为了给程序完成类似的效果.</p>
<h4 id="1，-抽象组件-Room"><a href="#1，-抽象组件-Room" class="headerlink" title="1， 抽象组件 Room"></a>1， 抽象组件 Room</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Room <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="comment">//房子提供展示的功能</span></span><br><span class="line">  Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，具体组件-MyRoom"><a href="#2，具体组件-MyRoom" class="headerlink" title="2，具体组件 MyRoom"></a>2，具体组件 MyRoom</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRoom <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyRoom)</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;一个简单的房子&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-装饰类-Decorator"><a href="#3，-装饰类-Decorator" class="headerlink" title="3， 装饰类 Decorator"></a>3， 装饰类 Decorator</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Decorator <span class="keyword">interface</span>&#123;</span><br><span class="line">  Decorate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-具体装饰器"><a href="#4-具体装饰器" class="headerlink" title="4, 具体装饰器"></a>4, 具体装饰器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DecoratorRoom1 <span class="keyword">struct</span>&#123;</span><br><span class="line">  room MyRoom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DecoratorRoom1)</span> <span class="title">Decorate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;beautiful room&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *DecoratorRoom1)</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  d.room.Show()</span><br><span class="line">  decorate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  room := MyRoom&#123;&#125;</span><br><span class="line">  decorate :=  DecoratorRoom1&#123;room: room&#125;</span><br><span class="line">  decorate.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>过滤器模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把他们连接起来。</p>
<h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul>
<li>待过滤的对象  </li>
<li>过滤器接口  </li>
<li>过滤器实现</li>
</ul>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h4 id="1，待过滤的对象-Person"><a href="#1，待过滤的对象-Person" class="headerlink" title="1，待过滤的对象 Person"></a>1，待过滤的对象 Person</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Gender <span class="keyword">string</span></span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-待过滤的接口-Filter"><a href="#2-待过滤的接口-Filter" class="headerlink" title="2, 待过滤的接口 Filter"></a>2, 待过滤的接口 Filter</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span>&#123;</span><br><span class="line">  []Person Filter([]Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-过滤器实现-AgeFilter，GenderFilter"><a href="#3，-过滤器实现-AgeFilter，GenderFilter" class="headerlink" title="3， 过滤器实现 AgeFilter，GenderFilter"></a>3， 过滤器实现 AgeFilter，GenderFilter</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AgeFilter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AgeFilter)</span> <span class="title">Filter</span><span class="params">(p []Person)</span>[]<span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret []Person</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> p&#123;</span><br><span class="line">    <span class="keyword">if</span> v.Age &gt; <span class="number">15</span> &#123;</span><br><span class="line">      ret = <span class="built_in">append</span>(ret, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenderFilter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *GenderFilter)</span> <span class="title">Filter</span><span class="params">(p []Person)</span>[]<span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret []Person</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> p&#123;</span><br><span class="line">    <span class="keyword">if</span> v.Gender == <span class="string">&quot;Male&quot;</span> &#123;</span><br><span class="line">      ret = <span class="built_in">append</span>(ret, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-调用"><a href="#4-调用" class="headerlink" title="4, 调用"></a>4, 调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  p := []Person&#123;</span><br><span class="line">    &#123;Name:<span class="string">&quot;Abc&quot;</span>, Gender:<span class="string">&quot;Male&quot;</span>, Age:<span class="number">45</span>&#125;,</span><br><span class="line">    &#123;Name:<span class="string">&quot;Bde&quot;</span>, Gender:<span class="string">&quot;Female&quot;</span>, Age:<span class="number">23</span>&#125;，</span><br><span class="line">  &#125;</span><br><span class="line">  age := AgeFilter&#123;&#125;.Filter(p)</span><br><span class="line">  gender := GenderFilter&#123;&#125;.Filter(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介　"></a>简介　</h3><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分离接口及其实现部分：一个实现未必不变地绑定在一个接口上，抽象类的实现可在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。将abstraction与Implementor分离有助于降低对实现部分编译时刻的依赖性，当改变一个实现类时，不需要重新编译abstraction类和客户重新。为了保证一个类库的不同版本之间二进制兼容性，一定要有这个性质。另外，接口和实现分离有助于分层，从而产生更好的结构化系统，系统的高层部分只要知道abstraction和implementor即可。</li>
<li>提高可扩展性，可以独立对Abstraction和Implementor层次进行扩展。</li>
<li>实现细节对可对客户透明。</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不容易设计，需不需要分离，如何分离等问题。比较难以拿捏。</li>
</ul>
<h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ol>
<li><p>Client 调用端：这是Bridge模式的调用者。</p>
</li>
<li><p>抽象类（Abstraction）：抽象类接口（接口这货抽象类）维护队行为实现（implementation）的引用。它的角色就是桥接类。</p>
</li>
<li><p>Refined Abstraction： 这是Abstraction的子类。</p>
</li>
<li><p>Implementor： 行为实现类接口（Abstraction接口定义了基于Implementor接口的更高层次的操作）</p>
</li>
<li><p>ConcreteImplementor：Implementor的子类</p>
</li>
</ol>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。</p>
<h4 id="1，-行为实现类接口："><a href="#1，-行为实现类接口：" class="headerlink" title="1， 行为实现类接口："></a>1， 行为实现类接口：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DriveType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  DB2 DriverType = <span class="literal">iota</span></span><br><span class="line">  MySql</span><br><span class="line">  Oracle</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span>&#123;</span><br><span class="line">  echoDriver() DriverType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-行为实现类"><a href="#2-行为实现类" class="headerlink" title="2, 行为实现类"></a>2, 行为实现类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DB2Driver <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DB2Driver)</span> <span class="title">echoDriver</span><span class="params">()</span> <span class="title">DriverType</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DB2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySqlDriver <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *MySqlDriver)</span> <span class="title">echoDriver</span><span class="params">()</span> <span class="title">DriverType</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MySql</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OracleDriver <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *OracleDriver)</span> <span class="title">echoDriver</span><span class="params">()</span> <span class="title">DriverType</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Oracle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-桥接类"><a href="#3-桥接类" class="headerlink" title="3, 桥接类"></a>3, 桥接类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bridge <span class="keyword">struct</span>&#123;</span><br><span class="line">  driver Driver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *Bridge)</span> <span class="title">SetDriver</span><span class="params">(driver Driver)</span></span>&#123;</span><br><span class="line">  b.driver = driver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *Bridge)</span> <span class="title">getDriver</span><span class="params">()</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b.driver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-桥接子类"><a href="#4-桥接子类" class="headerlink" title="4, 桥接子类"></a>4, 桥接子类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BridgeManager <span class="keyword">struct</span>&#123;</span><br><span class="line">  Bridge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BridgeManager)</span> <span class="title">getDriverType</span><span class="params">()</span> <span class="title">DriverType</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b.getDriver().echoDriver()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-调用-1"><a href="#5-调用-1" class="headerlink" title="5, 调用"></a>5, 调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  bridge := BridgeManager()</span><br><span class="line">  <span class="comment">//调用OracleDriver</span></span><br><span class="line">  bridge.SetDriver(OracleDriver&#123;&#125;)</span><br><span class="line">  bridge.getDriverType()</span><br><span class="line">  <span class="comment">//调用DB2Driver</span></span><br><span class="line">  bridge.SetDriver(DB2Driver&#123;&#125;)</span><br><span class="line">  bridge.getDriverType()</span><br><span class="line">  <span class="comment">//调用MysqlDriver</span></span><br><span class="line">  bridge.SetDriver(MysqlDriver&#123;&#125;)</span><br><span class="line">  bridge.getDriverType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。</p>
<h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><p>1.抽象对象角色</p>
<p>声明了目标类及代理类对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象。</p>
<p>2.目标对象角色</p>
<p>定义了代理对象所代表的目标对象。</p>
<p>3.代理对象角色</p>
<p>代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象和目标对象具有统一的接口，以便可以再任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或者之后，执行某些操作，而非单纯的将调用传递给目标对象。</p>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><h4 id="1，抽象对象角色-IUserdao"><a href="#1，抽象对象角色-IUserdao" class="headerlink" title="1，抽象对象角色 IUserdao"></a>1，抽象对象角色 IUserdao</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IUserDao <span class="keyword">interface</span>&#123;</span><br><span class="line">    Save()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，目标对象角色-UserDao"><a href="#2，目标对象角色-UserDao" class="headerlink" title="2，目标对象角色  UserDao"></a>2，目标对象角色  UserDao</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserDao <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserDao)</span><span class="title">Save</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;save user success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，代理对象角色-UserProxy"><a href="#3，代理对象角色-UserProxy" class="headerlink" title="3，代理对象角色  UserProxy"></a>3，代理对象角色  UserProxy</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProxy <span class="keyword">struct</span>&#123;</span><br><span class="line">    dao IUserDao</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *UserProxy)</span><span class="title">ProxySave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p.dao.Save()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4，代码调用"><a href="#4，代码调用" class="headerlink" title="4，代码调用"></a>4，代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">var</span> target = UserDao&#123;&#125;</span><br><span class="line">    <span class="comment">//代理对象包装目标对象</span></span><br><span class="line">    <span class="keyword">var</span> proxy = UserProxy&#123;dao:target&#125;</span><br><span class="line">    <span class="comment">//通过代理对象调用目标对象的方法</span></span><br><span class="line">    proxy.ProxySave()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p>
<ol>
<li>修改原有的方法来适应。显然这违反了“对扩展开放，对修改关闭”的原则。</li>
<li>采用一个代理类调用原来的方法，且对产生的结果进行控制。这就是代理模式了。</li>
</ol>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>将对象组合成树形结构以表示“部分整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</li>
<li>客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</li>
<li>定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</li>
<li>更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</li>
</ol>
<h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><p>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联  </p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li>
<li>让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</li>
<li>组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。</li>
<li>组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。</li>
</ol>
<h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><p>展示一颗树结构，里面包含childern节点，下面还包含children节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Label    <span class="keyword">string</span>      <span class="string">`json:&quot;label&quot;`</span></span><br><span class="line">	Type     <span class="keyword">string</span>      <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">	Id       <span class="keyword">string</span>      <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	IsLeaf   <span class="keyword">bool</span>        <span class="string">`json:&quot;isLeaf,omitempty&quot;`</span></span><br><span class="line">	Children []*TreeNode <span class="string">`json:&quot;children,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h3> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">  a := &amp;TreeNode&#123;Label: <span class="string">&quot;A&quot;</span>, Type: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">  b := &amp;TreeNode&#123;Label: <span class="string">&quot;B&quot;</span>, Type: <span class="string">&quot;b&quot;</span>, IsLeaf: <span class="literal">true</span>&#125;</span><br><span class="line">  c := &amp;TreeNode&#123;Label: <span class="string">&quot;C&quot;</span>, Type: <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">  b := &amp;TreeNode&#123;Label: <span class="string">&quot;B&quot;</span>, Type: <span class="string">&quot;b&quot;</span>, IsLeaf: <span class="literal">true</span>&#125;</span><br><span class="line">  c.Children = <span class="built_in">append</span>(c.Children, b)</span><br><span class="line">  a.children = <span class="built_in">append</span>(a.Children, b)</span><br><span class="line">  a.children = <span class="built_in">append</span>(a.Children, c)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最后结构为： a</span></span><br><span class="line">  <span class="comment">//            |--b</span></span><br><span class="line">  <span class="comment">//            |--c</span></span><br><span class="line">  <span class="comment">//               |--d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="外观器模式"><a href="#外观器模式" class="headerlink" title="外观器模式"></a>外观器模式</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。</p>
<p>外观模式通过引入一个新的外观类(Facade)来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。</p>
<p>在外观模式中，那些需要交互的业务类被称为子系统(Subsystem)。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大；而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度。</p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</p>
<p>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用. 外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p>
<h3 id="角色-5"><a href="#角色-5" class="headerlink" title="角色"></a>角色</h3><ul>
<li><p>Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p>
</li>
<li><p>SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>
</li>
</ul>
<h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><h4 id="1，-子系统"><a href="#1，-子系统" class="headerlink" title="1， 子系统"></a>1， 子系统</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cpu <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cpu)</span><span class="title">Startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;cpu startup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cpu)</span><span class="title">Shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;cpu shutdown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Memory)</span><span class="title">Startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;memory startup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Memory)</span><span class="title">Shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;memory shutdown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Disk <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Disk)</span><span class="title">Startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;disk startup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Disk)</span><span class="title">Shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;disk shutdown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2-外观角色"><a href="#2-外观角色" class="headerlink" title="2, 外观角色"></a>2, 外观角色</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ComputerFacade <span class="keyword">struct</span>&#123;</span><br><span class="line">  cpu Cpu</span><br><span class="line">  memory Memory</span><br><span class="line">  disk Disk</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *ComputerFacade)</span> <span class="title">NewFacade</span><span class="params">(cpu Cpu,memory Memory, disk Disk)</span>*<span class="title">ComputerFacade</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;ComputerFacade&#123;</span><br><span class="line">    cpu: cpu,</span><br><span class="line">    memory: memory,</span><br><span class="line">    disk: disk,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (c *ComputerFacade) Startup()&#123;</span><br><span class="line">  c.cpu.Startup()</span><br><span class="line">  c.memory.Startup()</span><br><span class="line">  c.disk.Startup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (c *ComputerFacade) Shutdown()&#123;</span><br><span class="line">  c.cpu.Shutdown()</span><br><span class="line">  c.memory.Shutdown()</span><br><span class="line">  c.disk.Shutdown()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="3，-调用"><a href="#3，-调用" class="headerlink" title="3， 调用"></a>3， 调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  facade := NewFacade(Cpu&#123;&#125;, Memory&#123;&#125;, Disk&#123;&#125;)</span><br><span class="line">  facade.Startup()</span><br><span class="line">  facade.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能.</p>
<p>享元模式从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，从而节省内存以及减少对象数量。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>数据库连接池就是这样的例子，实现如下</p>
<h4 id="1-数据库连接-DBConnect"><a href="#1-数据库连接-DBConnect" class="headerlink" title="1. 数据库连接 DBConnect"></a>1. 数据库连接 DBConnect</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库连接</span></span><br><span class="line"><span class="keyword">type</span> DBConnect <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *DbConnect)</span> <span class="title">Do</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;connecting ... and ... doing ... something ...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-通过享元模式生成数据库连接池-DBConnectPool"><a href="#2-通过享元模式生成数据库连接池-DBConnectPool" class="headerlink" title="2. 通过享元模式生成数据库连接池 DBConnectPool"></a>2. 通过享元模式生成数据库连接池 DBConnectPool</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库连接池</span></span><br><span class="line"><span class="keyword">type</span> DBConnectPool <span class="keyword">struct</span>&#123;</span><br><span class="line">    ConnChan <span class="keyword">chan</span> *DBConnect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDBConnectPool</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>)</span> *<span class="title">DBConnectPool</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DBConnectPool&#123;ConnChan:<span class="built_in">make</span>(<span class="keyword">chan</span> *DBConnect, <span class="built_in">len</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DBConnectPool)</span> <span class="title">Get</span><span class="params">()</span> *<span class="title">DBConnect</span></span>&#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> conn := &lt;- d.ConnChan:</span><br><span class="line">            <span class="keyword">return</span> conn</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//没有新建</span></span><br><span class="line">            conn := <span class="built_in">new</span>(DBConnect)</span><br><span class="line">            d.ConnChan &lt;- conn</span><br><span class="line">            <span class="keyword">return</span> conn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *DBConnectPool)</span> <span class="title">Put</span><span class="params">(conn *DBConnect)</span></span>&#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> d.ConnChan &lt;- conn:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	       <span class="comment">// 满则丢弃</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-代码调用"><a href="#3-代码调用" class="headerlink" title="3. 代码调用"></a>3. 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FlyweightTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pool := NewDBConnectPool(<span class="number">5</span>)</span><br><span class="line">    conn := pool.Get()</span><br><span class="line">    conn.Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>访问者模式是指封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。</li>
<li>访问者模式适用于数据结构相对稳定算法又易变化的系统。</li>
<li>若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。</li>
<li>访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。</li>
<li>访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构，其缺点就是增加新的数据结构很困难。</li>
</ul>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ol>
<li>符合单一职责原则。</li>
<li>优秀的扩展性。</li>
<li>灵活性。</li>
</ol>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>具体元素对访问者公布细节，违反了迪米特原则。</li>
<li>具体元素变更比较困难。</li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
</ol>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ol>
<h3 id="角色-6"><a href="#角色-6" class="headerlink" title="角色"></a>角色</h3><ul>
<li><strong>抽象访问者:</strong> 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</li>
<li><strong>访问者:</strong> 实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</li>
<li><strong>抽象元素类:</strong> 接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</li>
<li><strong>元素类:</strong> 实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</li>
<li><strong>结构对象:</strong> 一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1-抽象元素类"><a href="#1-抽象元素类" class="headerlink" title="1, 抽象元素类"></a>1, 抽象元素类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Object抽象元素可以被Visitor访问者来访问</span></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span> &#123;</span><br><span class="line">	Accept(Visitor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-抽象访问者"><a href="#2-抽象访问者" class="headerlink" title="2, 抽象访问者"></a>2, 抽象访问者</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义访问者Visitor可以访问Object接口对应的元素</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Visit(Object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-元素类"><a href="#3-元素类" class="headerlink" title="3, 元素类"></a>3, 元素类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义元素类，里面包含两个元素A,B， 它实现了Object接口，可以接收Visitor访问者</span></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="keyword">int</span></span><br><span class="line">	B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ab *Number)</span> <span class="title">Accept</span><span class="params">(vi Visitor)</span></span> &#123;</span><br><span class="line">	vi.Visit(ab)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-访问者"><a href="#4-访问者" class="headerlink" title="4, 访问者"></a>4, 访问者</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了2个访问者，分别对Object的元素进行加法和减法的操作</span></span><br><span class="line"><span class="keyword">type</span> AddVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AddVisitor)</span> <span class="title">Visit</span><span class="params">(ds Object)</span></span> &#123;</span><br><span class="line">	data := ds.(*Number)</span><br><span class="line">	sum := data.A + data.B</span><br><span class="line">	fmt.Println(<span class="string">&quot;A+B=&quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *SubVisitor)</span> <span class="title">Visit</span><span class="params">(ds Object)</span></span> &#123;</span><br><span class="line">	data := ds.(*Number)</span><br><span class="line">	sub := data.A - data.B</span><br><span class="line">	fmt.Println(<span class="string">&quot;A-B=&quot;</span>, sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-调用-2"><a href="#5-调用-2" class="headerlink" title="5, 调用"></a>5, 调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVisitor</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//元素类</span></span><br><span class="line">	object := &amp;Number&#123;A: <span class="number">2</span>, B: <span class="number">7</span>&#125;</span><br><span class="line">	<span class="comment">//访问者</span></span><br><span class="line">	add := &amp;AddVisitor&#123;&#125;</span><br><span class="line">	sub := &amp;SubVisitor&#123;&#125;</span><br><span class="line">	<span class="comment">//调用访问者，对元素进行不同的操作</span></span><br><span class="line">	object.Accept(add)</span><br><span class="line">	object.Accept(sub)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.runoob.com/design-pattern/visitor-pattern.html">http://www.runoob.com/design-pattern/visitor-pattern.html</a></li>
<li><a href="https://github.com/BPing/golang_design_pattern/tree/master/pattern">https://github.com/BPing/golang_design_pattern/tree/master/pattern</a></li>
</ul>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</p>
<h3 id="角色-7"><a href="#角色-7" class="headerlink" title="角色"></a>角色</h3><ul>
<li>抽象类（AbstractClass）：实现了模板方法，定义了算法的骨架。</li>
<li>具体类（ConcreteClass)：实现抽象类中的抽象方法，已完成完整的算法。</li>
</ul>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ul>
<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。</li>
<li>子类实现算法的某些细节，有助于算法的扩展。</li>
<li>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>
</ul>
<h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>
</ul>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>在某些类的算法中，用了相同的方法，造成代码的重复。</li>
<li>控制子类扩展，子类必须遵守算法规则。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1-定义游戏模板-Game"><a href="#1-定义游戏模板-Game" class="headerlink" title="1. 定义游戏模板 Game"></a>1. 定义游戏模板 Game</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Game <span class="keyword">interface</span>&#123;</span><br><span class="line">    Start()</span><br><span class="line">    Playing()</span><br><span class="line">    End()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏模版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunGame</span><span class="params">(g Game)</span></span>&#123;</span><br><span class="line">	g.Start()</span><br><span class="line">	g.Playing()</span><br><span class="line">	g.End()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-定义基本游戏-BaseGame"><a href="#2-定义基本游戏-BaseGame" class="headerlink" title="2. 定义基本游戏 BaseGame"></a>2. 定义基本游戏 BaseGame</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BaseGame <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *BaseGame)</span><span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start game&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *BaseGame)</span><span class="title">Playing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;game playing&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *BaseGame)</span><span class="title">End</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;the end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-不同游戏，玩法不同，有FootBall和BasketBall，-同时覆写Playing-方法"><a href="#3-不同游戏，玩法不同，有FootBall和BasketBall，-同时覆写Playing-方法" class="headerlink" title="3. 不同游戏，玩法不同，有FootBall和BasketBall， 同时覆写Playing()方法"></a>3. 不同游戏，玩法不同，有FootBall和BasketBall， 同时覆写Playing()方法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FootBallGame <span class="keyword">struct</span>&#123;</span><br><span class="line">    *BaseGame</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(f *FootBallGame)</span><span class="title">Playing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;playing FootBall&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BasketBalllGame <span class="keyword">struct</span>&#123;</span><br><span class="line">    *BaseGame</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *BasketBalllGame)</span><span class="title">Playing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;playing BasketBall&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-方法调用"><a href="#4-方法调用" class="headerlink" title="4. 方法调用"></a>4. 方法调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TemplateTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RunGame(&amp;FootBallGame&#123;&#125;)</span><br><span class="line">    RunGame(&amp;BasketBallGame&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>策略模式定义了一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
<p>策略模式把对象本身和运算规则区分开来，其功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性的思想。</p>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>当存在以下情况时使用Strategy模式</p>
<ul>
<li>许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。</li>
<li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的算法。当这些变体实现为一个算法的类层次时 ,可以使用策略模式。</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
</ul>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="Strategy模式优点："><a href="#Strategy模式优点：" class="headerlink" title="Strategy模式优点："></a>Strategy模式优点：</h4><ul>
<li>相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。</li>
<li>提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。</li>
<li>消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许多条件语句的代码通常意味着需要使用Strategy模式。<br>实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。</li>
</ul>
<h4 id="Strategy模式缺点"><a href="#Strategy模式缺点" class="headerlink" title="Strategy模式缺点:"></a>Strategy模式缺点:</h4><ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类: 本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。</li>
<li>Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。</li>
<li>策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。 增加了对象的数目 Strategy增加了一个应用中的对象的数目。有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的 Strategy不应在各次调用之间维护状态。</li>
</ul>
<h3 id="模式的组成"><a href="#模式的组成" class="headerlink" title="模式的组成"></a>模式的组成</h3><ul>
<li>环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。</li>
<li>抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。</li>
<li>具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1-抽象策略类"><a href="#1-抽象策略类" class="headerlink" title="1, 抽象策略类"></a>1, 抽象策略类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TravelType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Bus     TravelType = <span class="literal">iota</span></span><br><span class="line">	Airport</span><br><span class="line">	Train</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象策略类,返回使用不同的交通方式来旅游</span></span><br><span class="line"><span class="keyword">type</span> Strategy <span class="keyword">interface</span> &#123;</span><br><span class="line">	TravelAlgorithm() TravelType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-具体策略类"><a href="#2-具体策略类" class="headerlink" title="2, 具体策略类"></a>2, 具体策略类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体策略类，使用公共汽车，飞机，火车等三种方式进行旅游的具体实现</span></span><br><span class="line"><span class="keyword">type</span> BusStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BusStrategy)</span> <span class="title">TravelAlgorithm</span><span class="params">()</span> <span class="title">TravelType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Bus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AirportStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *AirportStrategy)</span> <span class="title">TravelAlgorithm</span><span class="params">()</span> <span class="title">TravelType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Airport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrainStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *TrainStrategy)</span> <span class="title">TravelAlgorithm</span><span class="params">()</span> <span class="title">TravelType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Train</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-环境类"><a href="#3-环境类" class="headerlink" title="3, 环境类"></a>3, 环境类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	strategy Strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">SetStrategy</span><span class="params">(strategy Strategy)</span></span> &#123;</span><br><span class="line">	c.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">TravelAlgorithm</span><span class="params">()</span> <span class="title">TravelType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.strategy.TravelAlgorithm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-代码调用"><a href="#4-代码调用" class="headerlink" title="4, 代码调用"></a>4, 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStrategy</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//choose bus strategy</span></span><br><span class="line">	context := Context&#123;strategy: <span class="built_in">new</span>(BusStrategy)&#125;</span><br><span class="line">	context.TravelAlgorithm()</span><br><span class="line">	<span class="comment">//choose airport strategy</span></span><br><span class="line">	context.SetStrategy(<span class="built_in">new</span>(AirportStrategy))</span><br><span class="line">	context.TravelAlgorithm()</span><br><span class="line">	<span class="comment">//choose train strategy</span></span><br><span class="line">	context.SetStrategy(&amp;TrainStrategy&#123;&#125;)</span><br><span class="line">	context.TravelAlgorithm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>状态模式，又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>Context 定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态</li>
<li>State 定义一个接口封装与context的一个特定状态相关的行为：</li>
<li>ConcreteStateSubClasses 每一子类实现一个与Context的一个状态相关的行为</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>采用interface实现多继承，加入管理类，方便状态切换</p>
<ol>
<li>不同的状态(可能会对应相应的行为)，</li>
<li>不同的行为; 间反复进行切换，则应优先考虑状态模式。</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p> 模拟路上红绿灯切换</p>
<h4 id="1-State-定义一个接口封装与context的一个特定状态相关的行为"><a href="#1-State-定义一个接口封装与context的一个特定状态相关的行为" class="headerlink" title="1, State 定义一个接口封装与context的一个特定状态相关的行为"></a>1, State 定义一个接口封装与context的一个特定状态相关的行为</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LightType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Red    LightType = <span class="literal">iota</span></span><br><span class="line">	Green</span><br><span class="line">	Yellow</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//State 定义一个接口封装与context的一个特定状态相关的行为：</span></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetState() LightType</span><br><span class="line">	Last(*Context)</span><br><span class="line">	Next(*Context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Context-定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态"><a href="#2-Context-定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态" class="headerlink" title="2, Context 定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态"></a>2, Context 定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	state State</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">SetState</span><span class="params">(state State)</span></span> &#123;</span><br><span class="line">	c.state = state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Push</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.state.Last(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Pull</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.state.Next(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ConcreteStateSubClasses-每一子类实现一个与Context的一个状态相关的行为"><a href="#3-ConcreteStateSubClasses-每一子类实现一个与Context的一个状态相关的行为" class="headerlink" title="3, ConcreteStateSubClasses 每一子类实现一个与Context的一个状态相关的行为"></a>3, ConcreteStateSubClasses 每一子类实现一个与Context的一个状态相关的行为</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红灯</span></span><br><span class="line"><span class="keyword">type</span> RedState <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedState)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">LightType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedState)</span> <span class="title">Last</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	c.SetState(<span class="built_in">new</span>(YellowState))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedState)</span> <span class="title">Next</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	c.SetState(<span class="built_in">new</span>(GreenState))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯</span></span><br><span class="line"><span class="keyword">type</span> GreenState <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *GreenState)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">LightType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Green</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *GreenState)</span> <span class="title">Last</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	c.SetState(&amp;RedState&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *GreenState)</span> <span class="title">Next</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	c.SetState(&amp;YellowState&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黄灯</span></span><br><span class="line"><span class="keyword">type</span> YellowState <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *YellowState)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">LightType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *YellowState)</span> <span class="title">Last</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	c.SetState(<span class="built_in">new</span>(GreenState))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *YellowState)</span> <span class="title">Next</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	c.SetState(<span class="built_in">new</span>(RedState))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-调用-1"><a href="#4-调用-1" class="headerlink" title="4, 调用"></a>4, 调用</h4> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">TestState</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	context := <span class="built_in">new</span>(Context)</span><br><span class="line">	state := <span class="built_in">new</span>(RedState)</span><br><span class="line">	context.SetState(state)</span><br><span class="line">	fmt.Println(<span class="string">&quot;current state:&quot;</span>, context.GetState().GetState())</span><br><span class="line">	context.Pull()</span><br><span class="line">	fmt.Println(<span class="string">&quot;next state:&quot;</span>, context.GetState().GetState())</span><br><span class="line">	context.Pull()</span><br><span class="line">	fmt.Println(<span class="string">&quot;next state:&quot;</span>, context.GetState().GetState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>在生活实际中，我们经常会遇到关注一个事物数据变化的情况，例如生活中的温度记录仪，当温度变化时，我们观察它温度变化的曲线，温度记录日志等。对于这一类问题，很接近java设计模式里面的“观察者模式”，它适合解决多种对象跟踪一个对象数据变化的程序结构问题。</p>
<h3 id="涉及角色-1"><a href="#涉及角色-1" class="headerlink" title="涉及角色"></a>涉及角色</h3><ul>
<li>主题（Subject）</li>
<li>观察者（Observer）</li>
</ul>
<h3 id="依赖jdk已有的观察者模式编写代码观测天气变化"><a href="#依赖jdk已有的观察者模式编写代码观测天气变化" class="headerlink" title="依赖jdk已有的观察者模式编写代码观测天气变化"></a>依赖jdk已有的观察者模式编写代码观测天气变化</h3><ol>
<li>主题（WeatherSubject）：Observable类派生出来的子类，只需要定义各被监控的数据及getter()、setter()方法，getter方法主要用于具体观察者“拉”数据，setter方法主要用于更新、设置changed变量及通知各具体观察者进行数据响应。</li>
<li>观察者（WeatherObserver）：编写具体的观察者类实现观察者接口，通过参数传递主题对象获取更新的数据。update()方法主要用于“拉”数据及处理过程。</li>
</ol>
<h3 id="分析依赖jdk实现的观察者模式"><a href="#分析依赖jdk实现的观察者模式" class="headerlink" title="分析依赖jdk实现的观察者模式"></a>分析依赖jdk实现的观察者模式</h3><p>由java JDK实现的观察者模式来看，当在使用时感觉代码很简单，其实去看Observerable类和Observer接口的源码就知道，这些都是专家级的代码，学习了观察者模式后，下面得出一些结论:</br></p>
<ul>
<li>主题要知道哪些观察者对其进行监测，说明主题类中一定有一个集合类成员变量，添加和删除及判断这些观察者对象是否存在。</li>
<li>观察者类一定是多态的，有共同的父类接口。</li>
<li>主题完成的功能基本是固定的，添加观察者、撤销观察者、通知消息给观察者及引起观察者响应（即“拉”数据），可以抽象出来。</li>
</ul>
<h3 id="自定义形式写的观察者模式"><a href="#自定义形式写的观察者模式" class="headerlink" title="自定义形式写的观察者模式"></a>自定义形式写的观察者模式</h3><ol>
<li>编写观察者接口（IObserver）</li>
<li>编写主题接口（ISubject）</li>
<li>增加主题抽象类层（AbstractSubject）</li>
<li>主题子类定义被监控数据（Subject）</li>
<li>观察者对象（Observer）“拉”数据得到数据响应</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1，-观察者接口-Observer"><a href="#1，-观察者接口-Observer" class="headerlink" title="1， 观察者接口 Observer"></a>1， 观察者接口 Observer</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察者接口</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Notify(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-主题-Subject"><a href="#2-主题-Subject" class="headerlink" title="2, 主题  Subject"></a>2, 主题  Subject</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主题</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">	observers []Observer</span><br><span class="line">	state     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加主题订阅者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">Attach</span><span class="params">(observer ...Observer)</span></span> &#123;</span><br><span class="line">	s.observers = <span class="built_in">append</span>(s.observers, observer...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span> <span class="title">SetState</span><span class="params">(state <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	s.state = state</span><br><span class="line">	<span class="comment">//当主题状态发生变化，通过相关订阅者</span></span><br><span class="line">	<span class="keyword">for</span> _, obs := <span class="keyword">range</span> s.observers &#123;</span><br><span class="line">		obs.Notify(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-具体观察者-ConcreteObserver"><a href="#3，-具体观察者-ConcreteObserver" class="headerlink" title="3， 具体观察者 ConcreteObserver"></a>3， 具体观察者 ConcreteObserver</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">type</span> ConcreteObserver <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteObserver)</span> <span class="title">Notify</span><span class="params">(subject <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(c.Id, <span class="string">&quot; receive &quot;</span>, subject.(*Subject).state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-代码调用-1"><a href="#4-代码调用-1" class="headerlink" title="4, 代码调用"></a>4, 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestObserver</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义一个主题</span></span><br><span class="line">	subject := <span class="built_in">new</span>(Subject)</span><br><span class="line">	<span class="comment">//定义两个观察者</span></span><br><span class="line">	observer1 := &amp;ConcreteObserver&#123;Id: <span class="string">&quot;A&quot;</span>&#125;</span><br><span class="line">	observer2 := &amp;ConcreteObserver&#123;Id: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line">	<span class="comment">//两个观察者订阅该主题</span></span><br><span class="line">	subject.Attach(observer1, observer2)</span><br><span class="line">	<span class="comment">//主题状态发生变化，通过到每一个观察者</span></span><br><span class="line">	subject.SetState(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">	subject.SetState(<span class="string">&quot;I know&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>用一个空对象取代 NULL，减少对实例的检查。这样的空对象可以在数据不可用的时候提供默认的行为。</p>
<h3 id="为什么使用这个模式？还需要null吗？"><a href="#为什么使用这个模式？还需要null吗？" class="headerlink" title="为什么使用这个模式？还需要null吗？"></a>为什么使用这个模式？还需要null吗？</h3><p>之所以需要这个模式是因为这个模式可以消除重复。想象一下，假如有多个消费端，每个消费端都要判断一下是否为空，而且对于为空的场景要做特殊的处理，这样就会导致很多重复。一些例子是：日志对象和缓存对象。</p>
<h3 id="参与者-1"><a href="#参与者-1" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>AbstractObject：声明协作对象的接口，如果需要，可以实现默认行为。</li>
<li>RealObject：具体的协作对象类，提供有意义的行为。</li>
<li>NullObject：空对象类，继承自 AbstractObject，但接口实现不做任何事情。</li>
<li>Client：请求协作对象。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Null Object Pattern，作为一种被遗忘的设计模式，却有着不能被遗忘的作用</p>
<ul>
<li>它可以加强系统的稳固性，能有有效地防止空指针报错对整个系统的影响，使系统更加稳定。</li>
<li>它能够实现对空对象情况的定制化的控制，能够掌握处理空对象的主动权。</li>
<li>它并不依靠Client来保证整个系统的稳定运行。</li>
<li>它通过isNull对==null的替换，显得更加优雅，更加易懂。</li>
</ul>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>在一个图书信息查询系统中，你调用一个方法，传过去你要查找图书的ID，然后它返回给你，你要查找的图书对象，这样你就可以调用对象的方法来输出图书的信息。</p>
<h4 id="1，图书对象ConcreteBook"><a href="#1，图书对象ConcreteBook" class="headerlink" title="1，图书对象ConcreteBook"></a>1，图书对象ConcreteBook</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteBook <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span></span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Author <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConcreteBook</span><span class="params">(ID <span class="keyword">int</span>, name, author <span class="keyword">string</span>)</span> *<span class="title">ConcreteBook</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteBook&#123;</span><br><span class="line">		ID:     ID,</span><br><span class="line">		Name:   name,</span><br><span class="line">		Author: author,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteBook)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strconv.Itoa(c.ID) + <span class="string">&quot;**&quot;</span> + c.Name + <span class="string">&quot;**&quot;</span> + c.Author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，工厂提供生产图书对象BookFactory"><a href="#2，工厂提供生产图书对象BookFactory" class="headerlink" title="2，工厂提供生产图书对象BookFactory"></a>2，工厂提供生产图书对象BookFactory</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BookFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BookFactory)</span> <span class="title">getBook</span><span class="params">(ID <span class="keyword">int</span>)</span> *<span class="title">ConcreteBook</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book *ConcreteBook</span><br><span class="line">	<span class="keyword">switch</span> ID &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		book = newConcreteBook(ID, <span class="string">&quot;Desing-Pattern&quot;</span>, <span class="string">&quot;GoF&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		book = newConcreteBook(ID, <span class="string">&quot;forget desing pattern&quot;</span>, <span class="string">&quot;Null-Object&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，代码调用"><a href="#3，代码调用" class="headerlink" title="3，代码调用"></a>3，代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNullObj</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	factory := <span class="built_in">new</span>(BookFactory)</span><br><span class="line">	book := factory.getBook(<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> book == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		book.show()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><p>从上面的调用我们可以看出，在客户端调用过程中，我们需要判断nil的操作，下面我们重构代码，使用空对象模式，消除对nil的判断</p>
<h4 id="1，定义Book接口"><a href="#1，定义Book接口" class="headerlink" title="1，定义Book接口"></a>1，定义Book接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">interface</span> &#123;</span><br><span class="line">	isNull() <span class="keyword">bool</span></span><br><span class="line">	show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，定义空对象实现"><a href="#2，定义空对象实现" class="headerlink" title="2，定义空对象实现"></a>2，定义空对象实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NullBook <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NullBook)</span> <span class="title">isNull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NullBook)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;obj is invalid&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-图书对象ConcreteBook"><a href="#3-图书对象ConcreteBook" class="headerlink" title="3, 图书对象ConcreteBook"></a>3, 图书对象ConcreteBook</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteBook <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span></span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Author <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConcreteBook</span><span class="params">(ID <span class="keyword">int</span>, name, author <span class="keyword">string</span>)</span> *<span class="title">ConcreteBook</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteBook&#123;</span><br><span class="line">		ID:     ID,</span><br><span class="line">		Name:   name,</span><br><span class="line">		Author: author,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteBook)</span> <span class="title">isNull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteBook)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strconv.Itoa(c.ID) + <span class="string">&quot;**&quot;</span> + c.Name + <span class="string">&quot;**&quot;</span> + c.Author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4，-工厂对象BookFactory"><a href="#4，-工厂对象BookFactory" class="headerlink" title="4， 工厂对象BookFactory"></a>4， 工厂对象BookFactory</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BookFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BookFactory)</span> <span class="title">getBook</span><span class="params">(ID <span class="keyword">int</span>)</span> <span class="title">Book</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book Book</span><br><span class="line">	<span class="keyword">switch</span> ID &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		book = newConcreteBook(ID, <span class="string">&quot;Desing-Pattern&quot;</span>, <span class="string">&quot;GoF&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		book = newConcreteBook(ID, <span class="string">&quot;forget desing pattern&quot;</span>, <span class="string">&quot;Null-Object&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		book = &amp;NullBook&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5，客户端调用"><a href="#5，客户端调用" class="headerlink" title="5，客户端调用"></a>5，客户端调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNullObj</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	factory := <span class="built_in">new</span>(BookFactory)</span><br><span class="line">	book := factory.getBook(<span class="number">-1</span>)</span><br><span class="line">	book.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p><strong>备忘录模式</strong>也称之为【备份-恢复】模式，在不破环封装行性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</p>
<h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><p>1.Originator(原发器)<br>保存内部状态的类称为原发器。原发器可以创建一个备忘录，并存储它的当前状态，也可以使用备忘录来恢复其内部状态。</p>
<p>2.Memonto(备忘录)<br>备忘录对象不能直接被其他类使用，根据原发器来决定保存哪些内部状态。</p>
<p>3.Caretaker(负责人)<br>负责人又称管理者，它负责保存备忘录，但不能对备忘录的内容进行检查或者操作。它可以保存一个或者多个备忘录对象。</p>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>更好的封装性：备忘录模式通过使用备忘录对象，来封装原发器对象的内部状态，虽然这个对象是保存在原发器对象的外部，但是由于备忘录对象的窄接口并不提供任何方法，这样有效的保证了对原发器对象内部状态的封装，不把原发器对象的内部实现细节暴露给外部。</li>
<li>简化了原发器：备忘录模式中，备忘录对象被保存到原发器对象之外，让客户来管理他们请求的状态，从而让原发器对象得到简化。</li>
<li>窄接口和宽接口</li>
</ul>
</li>
<li>缺点<ul>
<li>可能会导致高开销：备忘录模式基本的功能，就是对备忘录对象的存储和恢复，它的基本实现方式就是缓存备忘录对象。这样一来，如果需要缓存的数据量很大，或者是特别频繁的创建备忘录对象，开销是很大的。</li>
</ul>
</li>
</ul>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1，-原发器"><a href="#1，-原发器" class="headerlink" title="1， 原发器"></a>1， 原发器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Originator <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserName    <span class="keyword">string</span></span><br><span class="line">	Password    <span class="keyword">string</span></span><br><span class="line">	PhoneNumber <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存备忘录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Originator)</span> <span class="title">saveMemento</span><span class="params">()</span> *<span class="title">Memento</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Memento&#123;</span><br><span class="line">		UserName:    o.UserName,</span><br><span class="line">		Password:    o.Password,</span><br><span class="line">		PhoneNumber: o.PhoneNumber,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复备忘录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Originator)</span> <span class="title">restoreMemento</span><span class="params">(memento *Memento)</span></span> &#123;</span><br><span class="line">	o.UserName = memento.UserName</span><br><span class="line">	o.Password = memento.Password</span><br><span class="line">	o.PhoneNumber = memento.PhoneNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Originator)</span> <span class="title">show</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	fmt.Println(<span class="string">&quot;username:&quot;</span> + o.UserName + <span class="string">&quot;,password:&quot;</span> + o.Password + <span class="string">&quot;,phonenumber:&quot;</span> + o.PhoneNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，-备忘录"><a href="#2，-备忘录" class="headerlink" title="2， 备忘录"></a>2， 备忘录</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Memento <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserName    <span class="keyword">string</span></span><br><span class="line">	Password    <span class="keyword">string</span></span><br><span class="line">	PhoneNumber <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-负责人"><a href="#3，-负责人" class="headerlink" title="3， 负责人"></a>3， 负责人</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Caretaker <span class="keyword">struct</span> &#123;</span><br><span class="line">	memento *Memento</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Caretaker)</span> <span class="title">getMemento</span><span class="params">()</span> *<span class="title">Memento</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.memento</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Caretaker)</span> <span class="title">setMemento</span><span class="params">(memento *Memento)</span></span> &#123;</span><br><span class="line">	c.memento = memento</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4，-代码调用"><a href="#4，-代码调用" class="headerlink" title="4， 代码调用"></a>4， 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMemento</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建原发器</span></span><br><span class="line">	originator := Originator&#123;</span><br><span class="line">		UserName:    <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">		Password:    <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">		PhoneNumber: <span class="string">&quot;12306&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建负责人</span></span><br><span class="line">	taker := Caretaker&#123;&#125;</span><br><span class="line">	originator.show(<span class="string">&quot;初始状态&quot;</span>)</span><br><span class="line">	<span class="comment">//保存状态</span></span><br><span class="line">	taker.setMemento(originator.saveMemento())</span><br><span class="line">	<span class="comment">//修改密码和电话号码</span></span><br><span class="line">	originator.Password = <span class="string">&quot;34567&quot;</span></span><br><span class="line">	originator.PhoneNumber = <span class="string">&quot;234556667&quot;</span></span><br><span class="line">	originator.show(<span class="string">&quot;修改状态&quot;</span>)</span><br><span class="line">	<span class="comment">//恢复状态</span></span><br><span class="line">	originator.restoreMemento(taker.getMemento())</span><br><span class="line">	originator.show(<span class="string">&quot;恢复到初始状态&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h3><p>责任链模式是对象的行为模式。使多个对象都有机会处理请求，从而避免请求的发送者和接受者直接的耦合关系。</p>
<p>将这些对象连成一条链，沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>责任链模式强调的是每一个对象及其对下家的引用来组成一条链，利用这种方式将发送者和接收者解耦。</p>
<h3 id="角色-8"><a href="#角色-8" class="headerlink" title="角色"></a>角色</h3><ul>
<li>抽象处理者角色(Handler:Approver):定义一个处理请求的接口，和一个后继连接(可选)</li>
<li>具体处理者角色(ConcreteHandler:President):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。</li>
<li>客户类(Application):向一个链上的具体处理者ConcreteHandler对象提交请求。</li>
</ul>
<h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低耦合度 ：该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。</li>
<li>职责链可简化对象的相互连接 : 结果是，职责链可简化对象的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。</li>
<li>增强了给对象指派职责(Responsibility)的灵活性 ：当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。</li>
<li>增加新的请求处理类很方便</li>
</ul>
<h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理 —该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。</li>
<li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用</li>
</ul>
<h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><h4 id="1，-抽象处理者-Handler"><a href="#1，-抽象处理者-Handler" class="headerlink" title="1， 抽象处理者 Handler"></a>1， 抽象处理者 Handler</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Request(flag <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，-具体处理者角色1：-ConcreteHandlerA"><a href="#2，-具体处理者角色1：-ConcreteHandlerA" class="headerlink" title="2， 具体处理者角色1： ConcreteHandlerA"></a>2， 具体处理者角色1： ConcreteHandlerA</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteHandlerA <span class="keyword">struct</span> &#123;</span><br><span class="line">	next Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConcreteHandlerA)</span> <span class="title">Request</span><span class="params">(flag <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteHandlerA.Request()&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> flag &#123;</span><br><span class="line">		h.next.Request(flag)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3，-具体处理者角色2：-ConcreteHandlerB"><a href="#3，-具体处理者角色2：-ConcreteHandlerB" class="headerlink" title="3， 具体处理者角色2： ConcreteHandlerB"></a>3， 具体处理者角色2： ConcreteHandlerB</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteHandlerB <span class="keyword">struct</span> &#123;</span><br><span class="line">	next Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConcreteHandlerB)</span> <span class="title">Request</span><span class="params">(flag <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteHandlerB.Request()&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> flag &#123;</span><br><span class="line">		h.next.Request(flag)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4，-具体处理者角色3：-ConcreteHandlerC"><a href="#4，-具体处理者角色3：-ConcreteHandlerC" class="headerlink" title="4， 具体处理者角色3： ConcreteHandlerC"></a>4， 具体处理者角色3： ConcreteHandlerC</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConcreteHandlerC <span class="keyword">struct</span> &#123;</span><br><span class="line">	next Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConcreteHandlerC)</span> <span class="title">Request</span><span class="params">(flag <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteHandlerC.Request()&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-具体调用者"><a href="#5-具体调用者" class="headerlink" title="5, 具体调用者"></a>5, 具体调用者</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  handlerC := &amp;ConcreteHandlerC&#123;&#125;</span><br><span class="line">  handlerB := &amp;ConcreteHandlerB&#123;next: handlerC&#125;</span><br><span class="line">  handlerA := &amp;ConcreteHandlerA&#123;next: handlerB&#125;</span><br><span class="line">  handlerA.Request(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p><strong>Q:</strong> 大家都知道，电脑里面各个配件之间的交互，主要是通过主板来完成的（事实上主板有很多的功能，这里不去讨论）。试想一下，如果电脑里面没有主板，会怎样呢?</p>
<p><strong>A:</strong></p>
<ul>
<li>如果电脑里面没有了主板，那么各个配件之间就必须自行相互交互，以互相传送数据，理论上说，基本上各个配件相互之间都存在交互数据的可能；</li>
<li>由于各个配件的接口不同，那么相互之间交互的时候，还必须把数据接口进行转换才能匹配上，那就更恐怖了.</li>
</ul>
<h3 id="软件开发中遇到的问题"><a href="#软件开发中遇到的问题" class="headerlink" title="软件开发中遇到的问题"></a>软件开发中遇到的问题</h3><p>如果上面的情况发生在软件开发上呢？</p>
<ul>
<li>如果把每个电脑配件都抽象成为一个类或者是子系统，那就相当于出现了多个类之间相互交互，而且交互还很繁琐，导致每个类都必须知道所有需要交互的类，也就是我们常说的类和类耦合了，是不是很麻烦？</li>
<li>在软件开发中出现这种情况可就不妙了，不但开发的时候每个类会复杂，因为要兼顾其它的类，更要命的是每个类在发生改动的时候，需要通知所有相关的类一起修改，因为接口或者是功能发生了变动，使用它的地方都得变，快要疯了吧！</li>
</ul>
<h3 id="中介者模式定义"><a href="#中介者模式定义" class="headerlink" title="中介者模式定义"></a>中介者模式定义</h3><p>用一个中介对象来封装一系列的对象交互。中介者使得各个对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。</p>
<h3 id="应用中介者模式来解决的思路"><a href="#应用中介者模式来解决的思路" class="headerlink" title="应用中介者模式来解决的思路"></a>应用中介者模式来解决的思路</h3><ul>
<li>仔细分析上面的问题，根本原因就在于多个对象需要相互交互，从而导致对象之间紧密耦合，这就不利于对象的修改和维护。</li>
<li>中介者模式的解决思路很简单，跟电脑的例子一样，中介者模式通过引入一个中介对象，让其它的对象都只和中介对象交互，而中介对象知道如何和其它所有的对象交互，这样对象之间的交互关系就没有了，从而实现对象之间的解耦。</li>
<li>对于中介对象而言，所有相互交互的对象，被视为同事类，中介对象就是来维护各个同事之间的关系，而所有的同事类都只是和中介对象交互。</li>
<li>每个同事对象，当自己发生变化的时候，不需要知道这会引起其它对象有什么变化，它只需要通知中介者就可以了，然后由中介者去与其它对象交互。这样松散耦合带来的好处是，除了让同事对象之间相互没有关联外，还有利于功能的修改和扩展。</li>
<li>有了中介者过后，所有的交互都封装到中介者对象里面，各个对象就不再需要维护这些关系了。扩展关系的时候也只需要扩展或修改中介者对象就可以了。</li>
</ul>
<h3 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h3><ul>
<li>Mediator：中介者接口。在里面定义各个同事之间交互需要的方法，可以是公共的通讯方法，比如changed方法，大家都用，也可以是小范围的交互方法。</li>
<li>ConcreteMediator：具体中介者实现对象。它需要了解并维护各个同事对象，并负责具体的协调各同事对象的交互关系。</li>
<li>Colleague：同事类的定义，通常实现成为抽象类，主要负责约束同事对象的类型，并实现一些具体同事类之间的公共功能，比如：每个具体同事类都应该知道中介者对象，也就是具体同事类都会持有中介者对象，就可以定义到这个类里面。</li>
<li>ConcreteColleague：具体的同事类，实现自己的业务，在需要与其它同事通讯的时候，就与持有的中介者通信，中介者会负责与其它的同事交互。</li>
</ul>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><p>要使用中介者模式来实现聊天室，那就要区分出同事对象和中介者对象。很明显，<code>聊天室是作为中介者</code>，而每个注册到该聊天室的都是作为同事对象</p>
<h4 id="1-中介者接口"><a href="#1-中介者接口" class="headerlink" title="1, 中介者接口"></a>1, 中介者接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mediator <span class="keyword">interface</span> &#123;</span><br><span class="line">	SendUserMsg(<span class="keyword">string</span>)</span><br><span class="line">	RegisterUser(*User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-具体中介者实现对象"><a href="#2-具体中介者实现对象" class="headerlink" title="2, 具体中介者实现对象"></a>2, 具体中介者实现对象</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChatRoom <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *ChatRoom)</span> <span class="title">SendUserMsg</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(cr.name + <span class="string">&quot; : &quot;</span> + msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *ChatRoom)</span> <span class="title">RegisterUser</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">	u.cr = cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-同事类"><a href="#3，-同事类" class="headerlink" title="3， 同事类"></a>3， 同事类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Colleague <span class="keyword">interface</span> &#123;</span><br><span class="line">	SendMsg(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-具体同事类"><a href="#4-具体同事类" class="headerlink" title="4, 具体同事类"></a>4, 具体同事类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	cr   *ChatRoom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">SendMsg</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> u.cr != <span class="literal">nil</span> &#123;</span><br><span class="line">		u.cr.SendUserMsg(u.name + <span class="string">&quot; : &quot;</span> + msg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-代码调用"><a href="#5-代码调用" class="headerlink" title="5, 代码调用"></a>5, 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	A := &amp;User&#123;name: <span class="string">&quot;A&quot;</span>&#125;</span><br><span class="line">	B := &amp;User&#123;name: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line">	cr := &amp;ChatRoom&#123;name: <span class="string">&quot;chatRoom1234&quot;</span>&#125;</span><br><span class="line">	cr.RegisterUser(A)</span><br><span class="line">	cr.RegisterUser(B)</span><br><span class="line"></span><br><span class="line">	A.SendMsg(<span class="string">&quot;I am A&quot;</span>)</span><br><span class="line">	B.SendMsg(<span class="string">&quot;I am B&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h3><p>用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<h3 id="角色-9"><a href="#角色-9" class="headerlink" title="角色"></a>角色</h3><ul>
<li>抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。</li>
<li>具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。</li>
<li>集合(Collection)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。</li>
<li>具体集合(ConcreteCollection)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。</li>
<li>客户端(Application)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。</li>
</ul>
<h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><h4 id="1，-迭代角色"><a href="#1，-迭代角色" class="headerlink" title="1， 迭代角色"></a>1， 迭代角色</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	arr []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	pos <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Iterator)</span> <span class="title">previous</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.pos &gt; <span class="number">0</span> &#123;</span><br><span class="line">		c.pos = c.pos - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.arr[c.pos]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Iterator)</span> <span class="title">next</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.pos &lt; <span class="built_in">len</span>(c.arr)<span class="number">-1</span> &#123;</span><br><span class="line">		c.pos = c.pos + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.arr[c.pos]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Iterator)</span> <span class="title">hasNext</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.pos &lt; <span class="built_in">len</span>(c.arr)<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Iterator)</span> <span class="title">first</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	c.pos = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> c.arr[c.pos]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-具体集合角色"><a href="#2-具体集合角色" class="headerlink" title="2,  具体集合角色"></a>2,  具体集合角色</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要迭代的集合</span></span><br><span class="line"><span class="keyword">type</span> Collection <span class="keyword">struct</span> &#123;</span><br><span class="line">	arr []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollection</span><span class="params">(array []<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Collection</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Collection&#123;</span><br><span class="line">		arr: array,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Collection)</span> <span class="title">iterator</span><span class="params">()</span> *<span class="title">Iterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Iterator&#123;</span><br><span class="line">		arr: c.arr,</span><br><span class="line">		pos: <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-代码调用-1"><a href="#3-代码调用-1" class="headerlink" title="3, 代码调用"></a>3, 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>&#125;</span><br><span class="line">	col := NewCollection(arr)</span><br><span class="line">	it := col.iterator()</span><br><span class="line">	<span class="keyword">for</span> ; it.hasNext(); &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;item : &quot;</span> + (it.next().(<span class="keyword">string</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>命令模式是将一个请求封装为一个对象,从而使我们可用不同的请求对客户进行参数化;对请求排队或者记录请求日志,以及支持可撤销的操作.命令模式是一种对象行为型模式,其别名为动作模式或事务模式.</p>
<h3 id="角色-10"><a href="#角色-10" class="headerlink" title="角色"></a>角色</h3><ul>
<li>Command: 命令</li>
<li>Invoker: 调用者</li>
<li>Receiver: 接受者</li>
<li>Client: 客户端</li>
</ul>
<p><strong>客户端通过调用者发送命令,命令调用接收者执行相应操作</strong></p>
<p><strong>调用者→接受者→命令</strong></p>
<h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p>优点</p>
<ul>
<li>降低了系统耦合度;</li>
<li>新的命令可以很容易添加到系统中去。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
</ul>
</li>
</ul>
<h3 id="代码调用-1"><a href="#代码调用-1" class="headerlink" title="代码调用"></a>代码调用</h3><h4 id="1，-定义命令"><a href="#1，-定义命令" class="headerlink" title="1， 定义命令"></a>1， 定义命令</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令接口</span></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，-定义调用者"><a href="#2，-定义调用者" class="headerlink" title="2， 定义调用者"></a>2， 定义调用者</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对命令的调用者</span></span><br><span class="line"><span class="keyword">type</span> Invoker <span class="keyword">struct</span> &#123;</span><br><span class="line">	commandList [] Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Invoker)</span> <span class="title">AddCommand</span><span class="params">(c Command)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	i.commandList = <span class="built_in">append</span>(i.commandList, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Invoker)</span> <span class="title">ExecuteCommand</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> i.commandList &#123;</span><br><span class="line">		val.Run()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-定义接受者"><a href="#3，-定义接受者" class="headerlink" title="3， 定义接受者"></a>3， 定义接受者</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReceiveA <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReceiveA)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;for ConcreteCommandA , how to process CommandA&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4，-定义命令的具体实现"><a href="#4，-定义命令的具体实现" class="headerlink" title="4， 定义命令的具体实现"></a>4， 定义命令的具体实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令接口实现类</span></span><br><span class="line"><span class="keyword">type</span> CommandA <span class="keyword">struct</span> &#123;</span><br><span class="line">	receive ReceiveA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CommandA)</span> <span class="title">SetReceive</span><span class="params">(r ReceiveA)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.receive = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CommandA)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.receive.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5，-代码调用"><a href="#5，-代码调用" class="headerlink" title="5， 代码调用"></a>5， 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//调用者</span></span><br><span class="line">	invoker := &amp;Invoker&#123;commandList: []Command&#123;&#125;&#125;</span><br><span class="line">	<span class="comment">//命令具体实现</span></span><br><span class="line">	commandA := &amp;CommandA&#123;&#125;</span><br><span class="line">	<span class="comment">//接受者</span></span><br><span class="line">	receiveA := &amp;ReceiveA&#123;&#125;</span><br><span class="line">	<span class="comment">//给命令设置接受者</span></span><br><span class="line">	commandA.SetReceive(*receiveA)</span><br><span class="line">  <span class="comment">//将命令加到调用者列表</span></span><br><span class="line">	invoker.AddCommand(commandA)</span><br><span class="line">	<span class="comment">//调用者调用命令</span></span><br><span class="line">	invoker.ExecuteCommand()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><ul>
<li> 1、可扩展性比较好，灵活。</li>
<li> 2、增加了新的解释表达式的方式。</li>
<li> 3、易于实现简单文法。</li>
</ul>
<h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li> 1、可利用场景比较少。</li>
<li> 2、对于复杂的文法比较难维护。</li>
<li> 3、解释器模式会引起类膨胀。</li>
<li> 4、解释器模式采用递归调用方法。</li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li>
<li> 2、一些重复出现的问题可以用一种简单的语言来进行表达。</li>
<li> 3、一个简单语法需要解释的场景。</li>
</ul>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1，-表达式接口"><a href="#1，-表达式接口" class="headerlink" title="1， 表达式接口"></a>1， 表达式接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式接口</span></span><br><span class="line"><span class="keyword">type</span> Expression <span class="keyword">interface</span> &#123;</span><br><span class="line">	Interpret(context <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，-对表达式接口的实现（终结符）"><a href="#2，-对表达式接口的实现（终结符）" class="headerlink" title="2， 对表达式接口的实现（终结符）"></a>2， 对表达式接口的实现（终结符）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终结符</span></span><br><span class="line"><span class="keyword">type</span> TerminalExpression <span class="keyword">struct</span> &#123;</span><br><span class="line">	Word <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TerminalExpression)</span> <span class="title">Interpret</span><span class="params">(context <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(context, t.Word) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，-对表达式接口的实现（或）"><a href="#3，-对表达式接口的实现（或）" class="headerlink" title="3， 对表达式接口的实现（或）"></a>3， 对表达式接口的实现（或）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">type</span> OrExpression <span class="keyword">struct</span> &#123;</span><br><span class="line">	A Expression</span><br><span class="line">	B Expression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *OrExpression)</span> <span class="title">Interpret</span><span class="params">(context <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> o.A.Interpret(context) || o.B.Interpret(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4，-对表达式接口的实现（与）"><a href="#4，-对表达式接口的实现（与）" class="headerlink" title="4， 对表达式接口的实现（与）"></a>4， 对表达式接口的实现（与）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AndExpression <span class="keyword">struct</span> &#123;</span><br><span class="line">	A Expression</span><br><span class="line">	B Expression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AndExpression)</span> <span class="title">Interpret</span><span class="params">(context <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.A.Interpret(context) &amp;&amp; a.B.Interpret(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5，-代码调用-1"><a href="#5，-代码调用-1" class="headerlink" title="5， 代码调用"></a>5， 代码调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	isMail := &amp;OrExpression&#123;&amp;TerminalExpression&#123;<span class="string">&quot;Robert&quot;</span>&#125;, &amp;TerminalExpression&#123;<span class="string">&quot;John&quot;</span>&#125;&#125;</span><br><span class="line">	isMarriedWoman := &amp;AndExpression&#123;&amp;TerminalExpression&#123;<span class="string">&quot;Julie&quot;</span>&#125;, &amp;TerminalExpression&#123;<span class="string">&quot;Married&quot;</span>&#125;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;john is male ?&quot;</span>, isMail.Interpret(<span class="string">&quot;John&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;Julie is a marred woman?&quot;</span>, isMarriedWoman.Interpret(<span class="string">&quot;Married Julie&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>go-patterns</tag>
      </tags>
  </entry>
</search>
